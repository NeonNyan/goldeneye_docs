# Indy management
7F0CFF30	104A60	initializes Indy if not ready
LUI	V1,8005
ADDIU	V1,V1,EAC8
LW	T6,0000 (V1)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFE8
ADDIU	V0,R0,0001
BEQ	V0,T6,7F0CFF54	;return if Indy ready
SW	RA,0014 (SP)
JAL	7F0CFF6C	;initializes Indy if ready
SW	V0,0000 (V1)	;1->8004EAC8: set Indy ready
//7F0CFF50:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
JR	RA
NOP

7F0CFF64	104A94		unconditional return
JR	RA
NOP

7F0CFF6C	104A9C	initializes Indy if ready
LUI	T6,8005
LW	T6,EAC8 (T6)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
BEQL	T6,R0,7F0CFF90	;return if not ready
LW	RA,0014 (SP)
JAL	7F0D0A3C	;post indy.res.cmd structure 1:0:2: initialize
NOP
//7F0CFF90:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
JR	RA
NOP

7F0CFF9C	104ACC	load resource named A0 from Indy to A1
	accepts: A0=p->string, A1=p->target
LUI	T6,8005
LW	T6,EAC8 (T6)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFD8
SW	RA,0014 (SP)
BEQ	T6,R0,7F0CFFD0	;return if Indy not ready
SW	A1,002C (SP)
JAL	7F0D0BA4	;post indy.res.cmd structure 1:7:2: send request for file named A0, size A1
LUI	A1,0040		;A1=size 0x400000
ADDIU	A0,SP,0020	;A0=SP+20: @response1
ADDIU	A1,SP,001C	;A1=SP+1C: @response2
ADDIU	A2,SP,0018	;A2=SP+18: @size
JAL	7F0D17FC	;(A0,A1)= response, A3= p->data of size A2 from indy.res.cmd structure 1:8:2: recieve file A3, size A2
LW	A3,002C (SP)	;A3= A1 f/caller: p->target
//7F0CFFD0:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0028
JR	RA
NOP

7F0CFFE0	104B10	send capture data A1 of size A2 named A0
	accepts: A0=p->string, A1=p->data, A2=size
LUI	T6,8005
LW	T6,EAC8 (T6)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFE0
SW	RA,0014 (SP)
BEQ	T6,R0,7F0D000C	;return if Indy not ready
SW	A1,0024 (SP)
OR	A1,A2,R0	;A1=A2: size
JAL	7F0D0C68	;post indy.res.cmd structure 1:9:2: send capture data A1, size A2 named A0
LW	A2,0024 (SP)	;A2= p->data
JAL	7F0D1864	;A0= response from indy.res.cmd structure 1:A:2: recieve capture data sucess
ADDIU	A0,SP,001C
//7F0D000C:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0020
JR	RA
NOP

7F0D001C	104B4C	load ramrom file named A0 from Indy to buffer A1, size A2
	accepts: A0=p->string, A1=p->target, A2=@filesize
LUI	T6,8005
LW	T6,EAC8 (T6)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFD8
SW	RA,0014 (SP)
BEQL	T6,R0,7F0D0050	;return if Indy not ready
LW	RA,0014 (SP)
JAL	7F0D0D18	;post indy.res.cmd structure 1:F:2: request ramrom file named A0 sent to buffer A1, size A2
NOP
ADDIU	A0,SP,0024
ADDIU	A1,SP,0020
JAL	7F0D18AC	;(A0,A1,A2)= response from indy.res.cmd structure 1:10:2: sucess/failure to load file to A1, size A2
ADDIU	A2,SP,001C
//7F0D004C:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0028
JR	RA
NOP

7F0D005C	104B8C	V0=TRUE if file A0 at hardware A1 of size A2 successfully exported
	accepts: A0=p->string, A1=hardware address, A2=size
LUI	T6,8005
LW	T6,EAC8 (T6)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFE0
SW	RA,0014 (SP)
BEQ	T6,R0,7F0D0088	;return if Indy not ready
SW	A1,0024 (SP)
OR	A1,A2,R0	;A1= A2: size
JAL	7F0D0DD0	;post indy.res.cmd structure 1, D, 2: (game) prof send - filename A0 of size A1 at hardware address A2
LW	A2,0024 (SP)	;A2= A1 f/caller: hardware address
JAL	7F0D1908	;A0= response from indy.res.cmd structure 1:E:2; V0=TRUE if file generated via 1:D:2 indy.res.cmd
ADDIU	A0,SP,001C
//7F0D0088:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0020
JR	RA
NOP

7F0D0098	104BC8	V0=TRUE if resource named A0 found on Indy and filesize set to A1
	accepts: A0=p->string, A1=@filesize
LUI	T6,8005
LW	T6,EAC8 (T6)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFE0
SW	RA,0014 (SP)
BNE	T6,R0,7F0D00B8	;return 0 if Indy not ready
SW	A1,0024 (SP)
BEQ	R0,R0,7F0D00D0
OR	V0,R0,R0
//7F0D00B8:
JAL	7F0D0B0C	;post indy.res.cmd structure 1:5:2
NOP
ADDIU	A0,SP,001C
JAL	7F0D17AC	; A0=TRUE and A1=filesize if file requested by 1:5:2 indy.res.cmd found
LW	A1,0024 (SP)
LW	V0,001C (SP)	;V0= discovery value
//7F0D00D0:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0020
JR	RA
NOP

7F0D00E0	104C10	V0= response from command string A0 sent to host PC via Indy
	accepts: A0=p->string
LUI	T6,8005
LW	T6,EAC8 (T6)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFE0
SW	RA,0014 (SP)
BNE	T6,R0,7F0D0100	;return FALSE if Indy not ready
NOP
BEQ	R0,R0,7F0D0114
OR	V0,R0,R0
//7F0D0100:	send commands and verify
JAL	7F0D0E74	;post indy.res.cmd structure 1:B:2
NOP
JAL	7F0D1950	;A0= response from indy.res.cmd structure 1:C:2
ADDIU	A0,SP,001C	;A0=SP+1C: @response
LW	V0,001C (SP)	;V0= return response
//7F0D0114:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0020
JR	RA
NOP

7F0D0124	104C54	removed: V0= -1
LUI	T6,8005
LW	T6,EAC8 (T6)	;T6=8004EAC8: TRUE if Indy ready
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
BEQL	T6,R0,7F0D0148	;return if Indy not ready
LW	RA,0014 (SP)
JAL	7000CEB0	;removed: V0= -1
NOP
//7F0D0144:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
JR	RA
NOP

7F0D0154	104C84	send close port command to PC
	sends unix commands to console: wait 5 seconds, then kill all instances of ghost and gload
	sleep: delay for a specified amount of time, seconds if no type given
	killall: kill processes by name
	ghost: game host utility
	gload: graphical load monitor
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
LUI	A0,8006
JAL	7F0D00E0	;V0= response from command string A0 sent to host PC via Indy
ADDIU	A0,A0,BFC0	;A0=8005BFC0: "sleep 5; /etc/killall ghost gload"
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
JR	RA
NOP

# Indy: resource entry management
Indy resource entries:
0x0	4	resourceID	[9ABF1623]
0x4	4	type
0x8	4	size
0xC	4	read size of following entry
0x10	4	write size of following entry
0x14	var.	command-specific data

7F0D0180	104CB0	removed: read A1 bytes f/indy.res to A0
	accepts: A0=p->buffer, A1=size of buffer
ADDIU	SP,SP,FFE8
LUI	V1,0001
SW	RA,0014 (SP)
ORI	V1,V1,86A0	;V1=0x186A0
OR	V0,R0,R0
//7F0D0194:	sit-and-spin 0x21A8 times
ADDIU	V0,V0,0004
BNEL	V0,V1,7F0D0198
ADDIU	V0,V0,0004
//7F0D01A0:
JAL	7000CEC0	;unconditional return
NOP
LUI	V1,0001
ORI	V1,V1,86A0	;V1=0x186A0
OR	V0,R0,R0
//7F0D01B4:	sit-and-spin 0x21A8 times
ADDIU	V0,V0,0004
BNEL	V0,V1,7F0D01B8
ADDIU	V0,V0,0004
//7F0D01C0:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
JR	RA
NOP

7F0D01D0	104D00	removed: write A1 bytes to indy.res from A0
	accepts: A0=p->buffer, A1=size of buffer
ADDIU	SP,SP,FFE8
LUI	V1,0001
SW	RA,0014 (SP)
ORI	V1,V1,86A0	;V1=0x186A0
OR	V0,R0,R0
//7F0D01E4:	sit-and-spin 0x61A8 times
ADDIU	V0,V0,0004
BNEL	V0,V1,7F0D01E8
ADDIU	V0,V0,0004
//7F0D01F0:
JAL	7000CEB8	;unconditional return
NOP
LUI	V1,0001
ORI	V1,V1,86A0	;V1=0x186A0
OR	V0,R0,R0
//7F0D0204:	sit-and-spin 0x261A8 times
ADDIU	V0,V0,0004
BNEL	V0,V1,7F0D0208
ADDIU	V0,V0,0004
//7F0D0210:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
JR	RA
NOP

7F0D0220	104D50	post Indy resource command A0 of size A1
	accepts: A0=p->struct, A1=size
ADDIU	SP,SP,FAC0
ADDIU	V0,SP,0040	;V0=SP+40: p->buffer
ANDI	T7,A0,0007
SW	RA,0014 (SP)
SW	A0,0540 (SP)
OR	A2,A1,R0	;A2= A1 f/caller: struct size
OR	V1,V0,R0	;V1= SP+40: p->buffer
BEQ	T7,R0,7F0D02EC	;branch if DW aligned
OR	A3,V0,R0	;A3= SP+40: p->buffer
SLTIU	AT,A1,0501
//7F0D0248:
BNE	AT,R0,7F0D0258	;return FALSE if over 500 bytes
ANDI	T8,V0,0007
BEQ	R0,R0,7F0D0348
OR	V0,R0,R0
//7F0D0258:
BEQ	T8,R0,7F0D0268	;skip if buffer DW aligned
LUI	T0,8005
ADDIU	A3,SP,0044	;A3= SP+44: p->buffer
OR	V1,A3,R0	;V1= SP+44: p->buffer
//7F0D0268:
ADDU	A0,V1,A2	;A0=buffer + size: p->buffer.end
SLTU	AT,V1,A0
BEQ	AT,R0,7F0D0290	;skip if nonexistant buffer
LW	V0,0540 (SP)	;V0= A0 f/caller: p->struct
//7F0D0278:	copy struct to buffer
LBU	T9,0000 (V0)
ADDIU	V1,V1,0001
SLTU	AT,V1,A0
ADDIU	V0,V0,0001
BNE	AT,R0,7F0D0278
SB	T9,FFFF (V1)
//7F0D0290:
LW	T0,EAC4 (T0)	;T0=8004EAC4: Indy Status
ADDIU	A1,A2,0003
ADDIU	AT,R0,FFFC
ANDI	T1,T0,0020
BEQ	T1,R0,7F0D02D8	;skip if flag 0x20 set: 
AND	T2,A1,AT	;T2= size to nearest word
BEQ	A2,R0,7F0D02D8	;skip if no data
OR	V0,R0,R0
ANDI	A0,A2,0003
BEQ	A0,R0,7F0D02CC	;skip if data word aligned
OR	V1,A0,R0
//7F0D02BC:	loop for stray bytes
ADDIU	V0,V0,0001
BNEL	V1,V0,7F0D02C0
ADDIU	V0,V0,0001
BEQ	V0,A2,7F0D02D8
//7F0D02CC:	loop for remaining filesize
ADDIU	V0,V0,0004
BNEL	V0,A2,7F0D02D0
ADDIU	V0,V0,0004
//7F0D02D8:	write to Indy
OR	A0,A3,R0	;A0=p->buffer
JAL	7F0D01D0	;removed: write A1 bytes to indy.res from A0
OR	A1,T2,R0	;A1=T2: size
BEQ	R0,R0,7F0D0348	;return TRUE
ADDIU	V0,R0,0001
//7F0D02EC:
LUI	T3,8005
LW	T3,EAC4 (T3)	;T0=8004EAC4: Indy Status
ADDIU	A1,A2,0003
ADDIU	AT,R0,FFFC
ANDI	T4,T3,0020
BEQ	T4,R0,7F0D0338	;skip if flag 0x20 set: 
AND	T5,A1,AT	;T5= size to nearest word
BEQ	A2,R0,7F0D0338	;skip if no data
OR	V0,R0,R0
ANDI	A0,A2,0003
BEQ	A0,R0,7F0D032C	;skip if data word aligned
OR	V1,A0,R0
//7F0D031C:	loop for stray bytes
ADDIU	V0,V0,0001
BNEL	V1,V0,7F0D0320
ADDIU	V0,V0,0001
BEQ	V0,A2,7F0D0338
//7F0D032C:	loop for remaining filesize
ADDIU	V0,V0,0004
BNEL	V0,A2,7F0D0330
ADDIU	V0,V0,0004
//7F0D0338:	write to Indy
LW	A0,0540 (SP)	;A0 f/caller: p->struct
JAL	7F0D01D0	;removed: write A1 bytes to indy.res from A0
OR	A1,T5,R0
ADDIU	V0,R0,0001	;return TRUE
//7F0D0348:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0540
JR	RA
NOP

7F0D0358	104D88	post two Indy resource commands A0 and A2 of sizes A1 and A3, respectively
	accepts: A0=p->indy.res 1, A1=size of indy.res 1, A2=indy.res 2, A3=size of indy.res 2
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A2,0020 (SP)
JAL	7F0D0220	;post Indy resource command A0 of size A1
SW	A3,0024 (SP)
LW	A0,0020 (SP)	;A0= A2 f/caller: p->struct 2
JAL	7F0D0220	;post Indy resource command A0 of size A1
LW	A1,0024 (SP)	;A1= A3 f/caller: size of struct 2
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D038C	104DBC	post type 1 indy.res.cmd: size of next command A0,A1
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
ADDIU	SP,SP,FFD0
LUI	T6,9ABF
SW	RA,0014 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0001
ADDIU	T8,R0,0014
SW	A0,0028 (SP)	;struct+C= A0 f/caller: 
SW	A1,002C (SP)	;struct+10=A1 f/caller: 
SW	T6,001C (SP)	;struct+0= resourceID
SW	T7,0020 (SP)	;struct+4= type 1
SW	T8,0024 (SP)	;struct+8= 14 bytes
ADDIU	A1,R0,0014	;A1=14 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,001C	;A0=SP+1C: p->struct
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D03D4	104E04	post type 2 indy.res.cmd: commands ready to process
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
ADDIU	SP,SP,FFD0
LUI	T6,9ABF
SW	RA,0014 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0002
ADDIU	T8,R0,0014
SW	A0,0028 (SP)	;struct+C= 
SW	A1,002C (SP)	;struct+10=
SW	T6,001C (SP)	;struct+0= resourceID
SW	T7,0020 (SP)	;struct+4= type 2
SW	T8,0024 (SP)	;struct+8= size: 14 bytes
ADDIU	A1,R0,0014	;A1= 14 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,001C	;A0=SP+1C: p->struct
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D041C	104E4C	post type 0 indy.res.cmd: initialize
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
ADDIU	SP,SP,FFD0
LUI	T6,9ABF
SW	RA,0014 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0014
SW	A0,0028 (SP)	;struct+C= 
SW	A1,002C (SP)	;struct+10=
SW	T6,001C (SP)	;struct+0= resourceID
SW	R0,0020 (SP)	;struct+4= type 0
SW	T7,0024 (SP)	;struct+8= size: 14 bytes
ADDIU	A1,R0,0014	;A1= 14 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,001C	;A0=SP+1C: p->struct
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D0460	104E90	post type 3 indy.res.cmd: 
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string (100 bytes)
ADDIU	SP,SP,FED0
SW	A1,0134 (SP)
LUI	T6,9ABF
SW	A1,002C (SP)	;struct+10=
SW	RA,0014 (SP)
SW	A2,0138 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0003
ADDIU	T8,R0,0114
SW	A0,0028 (SP)	;struct+C= 
OR	A1,A2,R0	;A1=A2: p->string
SW	T6,001C (SP)	;struct+0= resourceID
SW	T7,0020 (SP)	;struct+4= type 3
SW	T8,0024 (SP)	;struct+8= size: 114 bytes
ADDIU	A2,R0,0100	;A2= 100 bytes
JAL	7000A7A0	;strncpy(A0,A1,A2)
ADDIU	A0,SP,0030	;struct+14=target for string
SB	R0,012F (SP)	;NULL terminate string
ADDIU	A0,SP,001C	;A0=SP+1C: p->struct
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A1,R0,0114	;A1= 114 bytes
LW	RA,0014 (SP)
ADDIU	SP,SP,0130
JR	RA
NOP

7F0D04C4	104EF4	post type 4 indy.res.cmd: data recieved
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
ADDIU	SP,SP,FFD0
LUI	T6,9ABF
SW	RA,0014 (SP)
SW	A1,0034 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0004
ADDIU	T8,R0,0018
SW	A0,0024 (SP)	;struct+C= 
SW	A1,0028 (SP)	;struct+10=
SW	T6,0018 (SP)	;struct+0= resourceID
SW	T7,001C (SP)	;struct+4= type 4
SW	T8,0020 (SP)	;struct+8= size: 18 bytes
SW	A2,002C (SP)	;struct+14=
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,0018	;A0=SP+18: p->struct
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D0514	105044	post type 5 indy.res.cmd: printf send
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string (100 bytes)
ADDIU	SP,SP,FED0
SW	A1,0134 (SP)
LUI	T6,9ABF
SW	A1,002C (SP)
SW	RA,0014 (SP)
SW	A2,0138 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0005
ADDIU	T8,R0,0114
SW	A0,0028 (SP)
OR	A1,A2,R0	;A1=A2: p->string
SW	T6,001C (SP)	;struct+0= resourceID
SW	T7,0020 (SP)
SW	T8,0024 (SP)
ADDIU	A2,R0,0100	;A2= 100 bytes
JAL	7000A7A0	;strncpy(A0,A1,A2)
ADDIU	A0,SP,0030	;struct+14: target for string
SB	R0,012F (SP)	;NULL terminate string
ADDIU	A0,SP,001C
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A1,R0,0114
LW	RA,0014 (SP)
ADDIU	SP,SP,0130
JR	RA
NOP

7F0D0578	1050A8	post type 6 indy.res.cmd: printf recieved
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
ADDIU	SP,SP,FFC8
LUI	T6,9ABF
SW	RA,0014 (SP)
SW	A0,0038 (SP)
SW	A1,003C (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0006
ADDIU	T8,R0,001C
SW	A0,0028 (SP)
SW	A1,002C (SP)
SW	T6,001C (SP)
SW	T7,0020 (SP)
SW	T8,0024 (SP)
SW	A2,0030 (SP)
SW	A3,0034 (SP)
ADDIU	A1,R0,001C
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,001C
LW	RA,0014 (SP)
ADDIU	SP,SP,0038
JR	RA
NOP

7F0D05D0	105100	post type 7 indy.res.cmd: log send
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string, A3=
ADDIU	SP,SP,FED0
SW	A1,0134 (SP)
LUI	T6,9ABF
SW	A1,0028 (SP)
SW	RA,0014 (SP)
SW	A0,0130 (SP)
SW	A2,0138 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0007
ADDIU	T8,R0,0118
SW	A0,0024 (SP)
OR	A1,A2,R0	;A1=A2: p->string
SW	A3,013C (SP)
SW	T6,0018 (SP)
SW	T7,001C (SP)
SW	T8,0020 (SP)
ADDIU	A2,R0,0100	;A2= 100 bytes
JAL	7000A7A0	;strncpy(A0,A1,A2)
ADDIU	A0,SP,002C	;struct+14: target for string
LW	T1,013C (SP)
SB	R0,012B (SP)	;NULL terminate string
ADDIU	A0,SP,0018
ADDIU	A1,R0,0118	;A1= 118 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
SW	T1,012C (SP)
LW	RA,0014 (SP)
ADDIU	SP,SP,0130
JR	RA
NOP

7F0D0644	105174	post type 8 indy.res.cmd: log recieved
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=, A3=, SP+10=size of struct 2, SP+14=p->struct 2
ADDIU	SP,SP,FFC8
SW	A3,0044 (SP)
LW	A3,0048 (SP)	;A3= SP+10 f/caller: size of struct 2
ADDIU	AT,R0,FFFC
LW	T4,0044 (SP)
ADDIU	T8,A3,0003
LUI	T6,9ABF
AND	T9,T8,AT	;T9= A3 to nearest word: size of struct 2
SW	RA,0014 (SP)
SW	A0,0038 (SP)
SW	A1,003C (SP)
SW	A2,0040 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0008
ADDIU	T0,T9,0020
SW	A0,0024 (SP)	;struct1+C= 
SW	A1,0028 (SP)	;struct1+10=
SW	A2,002C (SP)	;struct1+14=
SW	T6,0018 (SP)	;struct1+0= resourceID
SW	T7,001C (SP)	;struct1+4= type 8
SW	T0,0020 (SP)	;struct1+8= 20 bytes + size of struct2
LW	A2,004C (SP)	;A2= SP+14 f/caller: p->struct 2
ADDIU	A1,R0,0020	;A1= 20 bytes (size of struct 1)
ADDIU	A0,SP,0018	;A0=SP+18: p->struct 1
SW	A3,0034 (SP)	;struct1+1C=SP+10 f/caller
JAL	7F0D0358	;post two Indy resource commands A0 and A2 of sizes A1 and A3, respectively
SW	T4,0030 (SP)	;struct1+18=A3 f/caller
LW	RA,0014 (SP)
ADDIU	SP,SP,0038
JR	RA
NOP

7F0D06C0	1051F0	post type 9 indy.res.cmd: app. command ready
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string, A3=size of struct 2, SP+10=p->struct 2
ADDIU	SP,SP,FED0
ADDIU	T9,A3,0003
ADDIU	AT,R0,FFFC
SW	A1,0134 (SP)
LUI	T6,9ABF
AND	T0,T9,AT	;T0=A3 to nearest word: size of struct 2
SW	A1,002C (SP)	;struct+10=
SW	RA,0014 (SP)
SW	A0,0130 (SP)
SW	A2,0138 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0009
ADDIU	T1,T0,0114
SW	A0,0028 (SP)	;struct+C= 
OR	A1,A2,R0	;A1=A2: p->string
SW	A3,013C (SP)
SW	T6,001C (SP)	;struct1+0= resourceID
SW	T7,0020 (SP)	;struct1+4= type 9
SW	T1,0024 (SP)	;struct1+8= size: 114 bytes
ADDIU	A2,R0,0100	;A2= 100 bytes
JAL	7000A7A0	;strncpy(A0,A1,A2)
ADDIU	A0,SP,0030	;struct+14= target for string
SB	R0,012F (SP)	;NULL terminate string
ADDIU	A0,SP,001C	;A0=SP+1C: p->struct 1
ADDIU	A1,R0,0114	;A1= 114 bytes (size of struct 1)
LW	A2,0140 (SP)	;A2= SP+10 f/caller: p->struct 2
JAL	7F0D0358	;post two Indy resource commands A0 and A2 of sizes A1 and A3, respectively
LW	A3,013C (SP)	;A3= A3 f/caller: size of struct 2
LW	RA,0014 (SP)
ADDIU	SP,SP,0130
JR	RA
NOP

7F0D0740	105270	post type A indy.res.cmd: app. command received
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
ADDIU	SP,SP,FFD0
LUI	T6,9ABF
SW	RA,0014 (SP)
SW	A1,0034 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,000A
ADDIU	T8,R0,0018
SW	A0,0024 (SP)	;struct+C= 
SW	A1,0028 (SP)	;struct+10=
SW	T6,0018 (SP)	;struct+0= resourceID
SW	T7,001C (SP)	;struct+4= type A
SW	T8,0020 (SP)	;struct+8= size: 18 bytes
SW	A2,002C (SP)	;struct+14=
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,0018	;A0=SP+18: p->struct
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D0790	1052C0	post type F indy.res.cmd: fault send
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string, A3=p->target, SP+10=@filesize
ADDIU	SP,SP,FEC8
SW	A1,013C (SP)
LUI	T6,9ABF
SW	A1,002C (SP)
SW	RA,0014 (SP)
SW	A0,0138 (SP)
SW	A2,0140 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,000F
ADDIU	T8,R0,011C
SW	A0,0028 (SP)	;struct+C= 
OR	A1,A2,R0	;A1=A2: p->string
SW	A3,0144 (SP)
SW	T6,001C (SP)	;struct+0= resourceID
SW	T7,0020 (SP)	;struct+4= type F
SW	T8,0024 (SP)	;struct+8= size: 11C bytes
ADDIU	A2,R0,0100	;A2= 100 bytes
JAL	7000A7A0	;strncpy(A0,A1,A2)
ADDIU	A0,SP,0030	;struct+14= target for string
LW	T1,0144 (SP)
LW	T2,0148 (SP)
SB	R0,012F (SP)	;NULL terminate string
ADDIU	A0,SP,001C	;A0=SP+1C: p->struct
ADDIU	A1,R0,011C	;A1= 11C bytes
SW	T1,0130 (SP)	;struct+114= A3 f/caller: 
JAL	7F0D0220	;post Indy resource command A0 of size A1
SW	T2,0134 (SP)	;struct+118= SP+10 f/caller: 
LW	RA,0014 (SP)
ADDIU	SP,SP,0138
JR	RA
NOP

7F0D080C	10533C	post type 10 indy.res.cmd: fault acknowledged by host
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=, A3=, SP+10=
ADDIU	SP,SP,FFC8
LW	T1,0048 (SP)
LUI	T6,9ABF
SW	RA,0014 (SP)
SW	A0,0038 (SP)
SW	A1,003C (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,0010
ADDIU	T8,R0,0020
SW	A0,0024 (SP)	;struct+C= 
SW	A1,0028 (SP)	;struct+10=
SW	T6,0018 (SP)	;struct+0= resourceID
SW	T7,001C (SP)	;struct+4= type 10
SW	T8,0020 (SP)	;struct+8= size: 20 bytes
SW	A2,002C (SP)	;struct+14=
SW	A3,0030 (SP)	;struct+18=
ADDIU	A1,R0,0020	;A1= 20 bytes
ADDIU	A0,SP,0018	;A0=SP+18: p->struct
JAL	7F0D0220	;post Indy resource command A0 of size A1
SW	T1,0034 (SP)	;struct+1C= SP+10 f/caller: 
LW	RA,0014 (SP)
ADDIU	SP,SP,0038
JR	RA
NOP

7F0D086C	10539C	post type D indy.res.cmd: prof send - filename A2 of size A3 at hardware address SP+10
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string, A3=size, SP+10=hardware address
ADDIU	SP,SP,FEC8
SW	A1,013C (SP)
LUI	T6,9ABF
SW	A1,002C (SP)	;struct+10=
SW	RA,0014 (SP)
SW	A0,0138 (SP)
SW	A2,0140 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,000D
ADDIU	T8,R0,011C
SW	A0,0028 (SP)	;struct+C= 
OR	A1,A2,R0	;A1=A2: p->string
SW	A3,0144 (SP)
SW	T6,001C (SP)	;struct+0= resourceID
SW	T7,0020 (SP)	;struct+4= type D
SW	T8,0024 (SP)	;struct+8= size: 11C bytes
ADDIU	A2,R0,0100	;A2= 100 bytes
JAL	7000A7A0	;strncpy(A0,A1,A2)
ADDIU	A0,SP,0030	;struct+14= target for string
LW	T1,0144 (SP)
LW	T2,0148 (SP)
SB	R0,012F (SP)	;NULL terminate string
ADDIU	A0,SP,001C	;A0=SP+1C: p->struct
ADDIU	A1,R0,011C	;A1= 11C bytes
SW	T1,0130 (SP)	;struct+114= A3 f/caller: 
JAL	7F0D0220	;post Indy resource command A0 of size A1
SW	T2,0134 (SP)	;struct+118= SP+10 f/caller: 
LW	RA,0014 (SP)
ADDIU	SP,SP,0138
JR	RA
NOP

7F0D08E8	105418	post type E indy.res.cmd: prof recieved
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
ADDIU	SP,SP,FFD0
LUI	T6,9ABF
SW	RA,0014 (SP)
SW	A1,0034 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,000E
ADDIU	T8,R0,0018
SW	A0,0024 (SP)	;struct+C= 
SW	A1,0028 (SP)	;struct+10=
SW	T6,0018 (SP)	;struct+0= resourceID
SW	T7,001C (SP)	;struct+4= type E
SW	T8,0020 (SP)	;struct+8= size: 18 bytes
SW	A2,002C (SP)	;struct+14=
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,0018	;A0=SP+18: p->struct
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D0938	105468	post type B indy.res.cmd: host prof request
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string
ADDIU	SP,SP,FBD0
SW	A1,0434 (SP)
LUI	T6,9ABF
SW	A1,002C (SP)	;struct+10=
SW	RA,0014 (SP)
SW	A2,0438 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,000B
ADDIU	T8,R0,0414
SW	A0,0028 (SP)	;struct+C= 
OR	A1,A2,R0	;A1=A2: p->string
SW	T6,001C (SP)	;struct+0= resourceID
SW	T7,0020 (SP)	;struct+4= type B
SW	T8,0024 (SP)	;struct+8= size: 414 bytes
ADDIU	A2,R0,0400	;A2= 400 bytes
JAL	7000A7A0	;strncpy(A0,A1,A2)
ADDIU	A0,SP,0030	;struct+14= target for string
SB	R0,042F (SP)	;NULL terminate string
ADDIU	A0,SP,001C	;A0=SP+1C: p->struct
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A1,R0,0414	;A1= 414 bytes
LW	RA,0014 (SP)
ADDIU	SP,SP,0430
JR	RA
NOP

7F0D099C	1054CC	post type C indy.res.cmd: prof send
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
ADDIU	SP,SP,FFD0
LUI	T6,9ABF
SW	RA,0014 (SP)
SW	A1,0034 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,000C
ADDIU	T8,R0,0018
SW	A0,0024 (SP)	;struct+C= 
SW	A1,0028 (SP)	;struct+10=
SW	T6,0018 (SP)	;struct+0= resourceID
SW	T7,001C (SP)	;struct+4= type C
SW	T8,0020 (SP)	;struct+8= size: 18 bytes
SW	A2,002C (SP)	;struct+14=
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,0018	;A0=SP+18: p->struct
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D09EC	10551C	post type A indy.res.cmd: app. data recieved
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
ADDIU	SP,SP,FFD0
LUI	T6,9ABF
SW	RA,0014 (SP)
SW	A1,0034 (SP)
ORI	T6,T6,1623	;T6=9ABF1623: resourceID
ADDIU	T7,R0,000A
ADDIU	T8,R0,0018
SW	A0,0024 (SP)	;struct+C= 
SW	A1,0028 (SP)	;struct+10=
SW	T6,0018 (SP)	;struct+0= resourceID
SW	T7,001C (SP)	;struct+4= type A
SW	T8,0020 (SP)	;struct+8= size: 18 bytes
SW	A2,002C (SP)	;struct+14=
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0220	;post Indy resource command A0 of size A1
ADDIU	A0,SP,0018	;A0=SP+18: p->struct
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D0A3C	10556C	post indy.res.cmd structure 1, 0, 2: initialize
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
ADDIU	A0,R0,0014
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0014
ADDIU	A0,R0,0014
JAL	7F0D041C	;post type 0 indy.res.cmd
ADDIU	A1,R0,0014
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0A7C	1055AC	post indy.res.cmd structure 1, 3, 2: (game) data send
	accepts: A0=p->string
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0114
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0114
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D0460	;post type 3 indy.res.cmd
LW	A2,0018 (SP)	;A2= A0 f/caller: p->string
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0AC4	1055F4	post indy.res.cmd structure 1, 4, 2: (debug) data rec.
	accepts: A0=
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D04C4	;post type 4 indy.res.cmd
LW	A2,0018 (SP)
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0B0C	10563C	post indy.res.cmd structure 1:5:2: (game) printf send
	accepts: A0=p->string
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0114
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0114
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D0514	;post type 5 indy.res.cmd
LW	A2,0018 (SP)	;A2= A0 f/caller: p->string
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0B54	105684	post indy.res.cmd structure 1, 6, 2: (debug) printf rec.
	accepts: A0=, A1=
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
SW	A1,001C (SP)
ADDIU	A1,R0,001C
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A0,R0,001C
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0018 (SP)
JAL	7F0D0578	;post type 6 indy.res.cmd
LW	A3,001C (SP)
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0BA4	1056D4	post indy.res.cmd structure 1:7:2: send request for file named A0, size A1
	accepts: A0=p->string, A1=size
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
SW	A1,001C (SP)
ADDIU	A1,R0,0118
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A0,R0,0118
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0018 (SP)	;A2= A0 f/caller: p->string
JAL	7F0D05D0	;post type 7 indy.res.cmd
LW	A3,001C (SP)	;A3= A1 f/caller: size
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0BF4	105724	post indy.res.cmd structure 1, 8, 2: 
	accepts: A0=, A1=, A2=size of struct2, A3=p->struct2
ADDIU	SP,SP,FFE0
SW	A0,0020 (SP)
ADDIU	A0,A2,0003
ADDIU	AT,R0,FFFC
SW	RA,001C (SP)
SW	A1,0024 (SP)
AND	T6,A0,AT
SW	A2,0028 (SP)
SW	A3,002C (SP)
ADDIU	A0,T6,0020
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0020
LW	T7,0028 (SP)
LW	T8,002C (SP)
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0020 (SP)
LW	A3,0024 (SP)
SW	T7,0010 (SP)	;SP+10= A2 f/caller: size of struct2
JAL	7F0D0644	;post type 8 indy.res.cmd
SW	T8,0014 (SP)	;SP+14= A3 f/caller: p->struct2
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,001C (SP)
ADDIU	SP,SP,0020
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0C68	105798	post indy.res.cmd structure 1:9:2: send capture data A1, size A2 named A0
	accepts: A0=p->string, A1=size of data, A2=p->data
ADDIU	SP,SP,FFE0
SW	A0,0020 (SP)
ADDIU	A0,A1,0003
ADDIU	AT,R0,FFFC
SW	RA,001C (SP)
SW	A1,0024 (SP)
AND	T6,A0,AT
SW	A2,0028 (SP)
ADDIU	A0,T6,0114
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0114
LW	T7,0028 (SP)
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0020 (SP)	;A2= A0 f/caller: p->string
LW	A3,0024 (SP)	;A3= A1 f/caller: size of data
JAL	7F0D06C0	;post type 9 indy.res.cmd
SW	T7,0010 (SP)	;SP+10= A2 f/caller: p->data
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,001C (SP)
ADDIU	SP,SP,0020
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0CD0	105800	post indy.res.cmd structure 1:A:2: recieve capture data success
	accepts: A0=@success
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D0740	;post type A indy.res.cmd
LW	A2,0018 (SP)	;A2= A0 f/caller: 
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0D18	105848	post indy.res.cmd structure 1:F:2: 
	accepts: A0=p->string, A1=p->target, A2=@filesize
ADDIU	SP,SP,FFE0
SW	RA,001C (SP)
SW	A0,0020 (SP)
SW	A1,0024 (SP)
SW	A2,0028 (SP)
ADDIU	A1,R0,011C
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A0,R0,011C
LW	T6,0024 (SP)
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0020 (SP)	;A2= A0 f/caller: p->string
LW	A3,0028 (SP)	;A3= A1 f/caller: p->target
JAL	7F0D0790	;post type F indy.res.cmd
SW	T6,0010 (SP)	;SP+10= A2 f/caller: @filesize
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,001C (SP)
ADDIU	SP,SP,0020
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0D74	1058A4	post indy.res.cmd structure 1, 10, 2: 
	accepts: A0=, A1=, A2=
ADDIU	SP,SP,FFE0
SW	RA,001C (SP)
SW	A0,0020 (SP)
SW	A1,0024 (SP)
SW	A2,0028 (SP)
ADDIU	A1,R0,0020
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A0,R0,0020
LW	T6,0028 (SP)
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0020 (SP)	;A2= A0 f/caller: 
LW	A3,0024 (SP)	;A3= A1 f/caller: 
JAL	7F0D080C	;post type 10 indy.res.cmd
SW	T6,0010 (SP)	;SP+10= A2 f/caller: 
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,001C (SP)
ADDIU	SP,SP,0020
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0DD0	105900	post indy.res.cmd structure 1, D, 2: (game) prof send - filename A0 of size A1 at hardware address A2
	accepts: A0=p->string, A1=size, A2=hardware address
ADDIU	SP,SP,FFE0
SW	RA,001C (SP)
SW	A0,0020 (SP)
SW	A1,0024 (SP)
SW	A2,0028 (SP)
ADDIU	A1,R0,011C
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A0,R0,011C
LW	T6,0024 (SP)
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0020 (SP)	;A2= A0 f/caller: p->string
LW	A3,0028 (SP)	;A3= A1 f/caller: size
JAL	7F0D086C	;post type D indy.res.cmd
SW	T6,0010 (SP)	;SP+10= A2 f/caller: hardware address
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,001C (SP)
ADDIU	SP,SP,0020
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0E2C	10595C	post indy.res.cmd structure 1:E:2: (host) prof rec.
	accepts: A0=
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D08E8	;post type E indy.res.cmd
LW	A2,0018 (SP)	;A2= A0 f/caller: 
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0E74	1059A4	post indy.res.cmd structure 1:B:2: 
	accepts: A0=p->string
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0414
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0414
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D0938	;post type B indy.res.cmd
LW	A2,0018 (SP)	;A2= A0 f/caller: p->command string
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0EBC	1059EC	post indy.res.cmd structure 1:C:2: 
	accepts: A0=
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D099C	;post type C indy.res.cmd
LW	A2,0018 (SP)	;A2= A0 f/caller: 
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0F04	105A34	post indy.res.cmd structure 1:A:2: 
	accepts: A0=
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D038C	;post type 1 indy.res.cmd
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D09EC	;post type A indy.res.cmd
LW	A2,0018 (SP)
OR	A0,R0,R0
JAL	7F0D03D4	;post type 2 indy.res.cmd
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D0F4C	105A7C	read Indy resource command of size A1 to A0
	accepts: A0=p->buffer, A1=size of buffer
ADDIU	SP,SP,FBC0
ADDIU	V0,SP,0040	;V0=SP+40: p->buffer
ANDI	T7,A0,0007
SW	RA,0014 (SP)
SW	A0,0440 (SP)
OR	A2,A1,R0
OR	V1,V0,R0	;V1=V0: p->buffer
BEQ	T7,R0,7F0D1030	;branch if buffer DW aligned
OR	A3,V0,R0	;A3=V0: p->buffer
SLTIU	AT,A1,0401
BNE	AT,R0,7F0D0F84	;return FALSE if over 0x400 bytes
ANDI	T8,V0,0007
BEQ	R0,R0,7F0D1098
OR	V0,R0,R0
//7F0D0F84:	DW-align buffer
BEQ	T8,R0,7F0D0F94	;skip if buffer DW aligned
ADDIU	A1,A2,0003
ADDIU	V1,SP,0044	;V1=SP+44: p->buffer
OR	A3,V1,R0	;A3=SP+44: p->buffer
//7F0D0F94:
ADDIU	AT,R0,FFFC
AND	T9,A1,AT
OR	A1,T9,R0	;A1=size word aligned
OR	A0,A3,R0	;A0=A3: p->buffer
SW	V1,003C (SP)
JAL	7F0D0180	;removed: read A1 bytes f/indy.res to A0
SW	A2,0444 (SP)
LW	V1,003C (SP)	;V1=p->buffer
LW	A2,0444 (SP)	;A2 f/caller
LW	V0,0440 (SP)	;V0=A0: p->target
LUI	T1,8005
ADDU	A0,V1,A2	;A0= buffer+offset: data.end
SLTU	AT,V1,A0
BEQ	AT,R0,7F0D0FE8	;skip if nothing to copy
NOP
//7F0D0FD0:	copy A2 bytes from buffer to output
LBU	T0,0000 (V1)
ADDIU	V1,V1,0001
SLTU	AT,V1,A0
ADDIU	V0,V0,0001
BNE	AT,R0,7F0D0FD0
SB	T0,FFFF (V0)
//7F0D0FE8:
LW	T1,EAC4 (T1)	;T1=8004EAC4: Indy Status
ANDI	T2,T1,0010
BEQ	T2,R0,7F0D1028	;skip if 0x10 flag not set
NOP
BEQ	A2,R0,7F0D1028	;skip if no data
OR	V0,R0,R0
ANDI	A0,A2,0003
BEQ	A0,R0,7F0D101C	;skip if data word aligned
OR	V1,A0,R0
//7F0D100C:	loop for stray bytes
ADDIU	V0,V0,0001
BNEL	V1,V0,7F0D1010
ADDIU	V0,V0,0001
BEQ	V0,A2,7F0D1028
//7F0D101C:	loop for remaining filesize
ADDIU	V0,V0,0004
BNEL	V0,A2,7F0D1020
ADDIU	V0,V0,0004
//7F0D1028:	return TRUE
BEQ	R0,R0,7F0D1098
ADDIU	V0,R0,0001
//7F0D1030:
ADDIU	A1,A2,0003
ADDIU	AT,R0,FFFC
AND	T3,A1,AT
OR	A1,T3,R0	;A1=A2 to nearest word
LW	A0,0440 (SP)
JAL	7F0D0180	;removed: read A1 bytes f/indy.res to A0
SW	A2,0444 (SP)
LUI	T4,8005
LW	T4,EAC4 (T4)	;T4=8004EAC4: Indy Status
LW	A2,0444 (SP)
ANDI	T5,T4,0010
BEQL	T5,R0,7F0D1098	;return TRUE if 0x10 flag not set
ADDIU	V0,R0,0001
BEQ	A2,R0,7F0D1094	;skip if no data
OR	V0,R0,R0
ANDI	A0,A2,0003
BEQ	A0,R0,7F0D1088	;skip if data word aligned
OR	V1,A0,R0
//7F0D1078:	loop for stray bytes
ADDIU	V0,V0,0001
BNEL	V1,V0,7F0D107C
ADDIU	V0,V0,0001
BEQ	V0,A2,7F0D1094
//7F0D1088:	loop for remaining filesize
ADDIU	V0,V0,0004
BNEL	V0,A2,7F0D108C
ADDIU	V0,V0,0004
//7F0D1094:	return TRUE
ADDIU	V0,R0,0001
//7F0D1098:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0440
JR	RA
NOP

7F0D10A8	105BD8	read two Indy resource commands A0 and A2 of sizes A1 and A3, respectively
	accepts: A0=p->buffer1, A1=size of buffer 1, A2=buffer2, A3=size of buffer 2
ADDIU	SP,SP,FFE8
SW	A1,001C (SP)
ADDIU	A1,A1,0003
ADDIU	AT,R0,FFFC
SW	RA,0014 (SP)
AND	T6,A1,AT
SW	A2,0020 (SP)
SW	A3,0024 (SP)
JAL	7F0D0180	;removed: read A1 bytes f/indy.res to A0
OR	A1,T6,R0	;A1 to nearest word
//7F0D10D0:	load second file
LW	A1,0024 (SP)
ADDIU	AT,R0,FFFC
LW	A0,0020 (SP)	;A0= A2 f/caller
ADDIU	A1,A1,0003
AND	T7,A1,AT
JAL	7F0D0180	;removed: read A1 bytes f/indy.res to A0
OR	A1,T7,R0	;A1= A3 f/caller to nearest word
//7F0D10EC:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D1100	105C30	V0= TRUE if current indy.res.cmd type 1 with expected sizes (A0,A1)
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
ADDIU	SP,SP,FFD0
SW	RA,0014 (SP)
SW	A0,0030 (SP)
SW	A1,0034 (SP)
ADDIU	A1,R0,0014	;A1=14 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,001C	;A0=SP+1C: p->buffer
LW	T6,001C (SP)	;T6=indy.res.cmd.resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D1138	;return FALSE if invalid resourceID
LW	V0,0030 (SP)	;V0= A0 f/caller:  
BEQ	R0,R0,7F0D119C
OR	V0,R0,R0
//7F0D1138:	test if type 1
LW	T7,0020 (SP)	;T7=indy.res.cmd.type
ADDIU	AT,R0,0001
LW	T8,0024 (SP)	;T8=indy.res.cmd.size
BEQL	T7,AT,7F0D1158	;return FALSE if not type 1
ADDIU	AT,R0,0014
BEQ	R0,R0,7F0D119C
OR	V0,R0,R0
//7F0D1154:	test sizes
ADDIU	AT,R0,0014
BEQ	T8,AT,7F0D1168	;return FALSE if size mismatch
NOP
BEQ	R0,R0,7F0D119C
OR	V0,R0,R0
//7F0D1168:	test first value versus A0
BEQ	V0,R0,7F0D1180	;skip if A0 was zero
LW	T9,0028 (SP)	;T9= indy.res.cmd+C: 
BEQL	T9,V0,7F0D1184	;return FALSE if A0 mismatch
LW	T0,002C (SP)
BEQ	R0,R0,7F0D119C
OR	V0,R0,R0
//7F0D1180:	test second value versus A1
LW	T0,002C (SP)	;T0= indy.res.cmd+10: 
LW	T1,0034 (SP)	;T1= A1 f/caller: 
ADDIU	V0,R0,0001
BEQ	T0,T1,7F0D119C	;return TRUE on match
NOP
BEQ	R0,R0,7F0D119C
OR	V0,R0,R0
//7F0D119C:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D11AC	105CDC	V0= TRUE if current indy.res.cmd type 2 with expected values (A0,A1)
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
ADDIU	SP,SP,FFD0
SW	RA,0014 (SP)
SW	A0,0030 (SP)
SW	A1,0034 (SP)
ADDIU	A1,R0,0014	;A1= 14 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,001C	;A0=SP+1C: p->buffer
LW	T6,001C (SP)	;T6=indy.res.cmd.resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D11E4	;return FALSE if invalid resourceID
LW	RA,0014 (SP)
BEQ	R0,R0,7F0D1240
OR	V0,R0,R0
//7F0D11E4:	test if type 2
LW	T7,0020 (SP)	;T7=indy.res.cmd.type
ADDIU	AT,R0,0002
LW	T8,0024 (SP)	;T8=indy.res.cmd.size
BEQL	T7,AT,7F0D1204	;return FALSE if not type 2
ADDIU	AT,R0,0014
BEQ	R0,R0,7F0D1240
OR	V0,R0,R0
//7F0D1200:	test sizes
ADDIU	AT,R0,0014
BEQ	T8,AT,7F0D1214	;return FALSE if size mismatch
LW	T9,0028 (SP)	;T9=indy.res.cmd+C: 
BEQ	R0,R0,7F0D1240
OR	V0,R0,R0
//7F0D1214:	test first value versus A0
LW	T0,0030 (SP)	;T0= A0 f/caller: 
LW	T1,002C (SP)	;T1=indy.res.cmd+10: 
LW	T2,0034 (SP)	;T2= A1 f/caller: 
BEQ	T9,T0,7F0D1230	;return FALSE if wrong value
NOP
BEQ	R0,R0,7F0D1240
OR	V0,R0,R0
//7F0D1230:	test second value versus A1
BEQ	T1,T2,7F0D1240	;return TRUE if value matches
ADDIU	V0,R0,0001
BEQ	R0,R0,7F0D1240
OR	V0,R0,R0
//7F0D1240:	return
JR	RA
ADDIU	SP,SP,0030

7F0D1248	105D78	V0= TRUE if current indy.res.cmd type 4 with expected values (A0,A1); A2= response (struct+14) if TRUE
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response
ADDIU	SP,SP,FFD0
SW	RA,0014 (SP)
SW	A0,0030 (SP)
SW	A1,0034 (SP)
SW	A2,0038 (SP)
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,0018	;A0=SP+18: p->buffer
LW	T6,0018 (SP)	;T6=indy.res.cmd.resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D1284	;return FALSE if invalid resourceID
LW	T7,001C (SP)	;T7=indy.res.cmd.type
BEQ	R0,R0,7F0D12E4
OR	V0,R0,R0
//7F0D1284:	test if type 4
ADDIU	AT,R0,0004
BEQ	T7,AT,7F0D1298	;return FALSE if not type 4
LW	T8,0020 (SP)	;T8=indy.res.cmd.size
BEQ	R0,R0,7F0D12E4
OR	V0,R0,R0
//7F0D1298:	test sizes
ADDIU	AT,R0,0018
BEQ	T8,AT,7F0D12AC	;return FALSE if size mismatch
LW	T9,0024 (SP)
BEQ	R0,R0,7F0D12E4
OR	V0,R0,R0
//7F0D12AC:	test first value versus A0
LW	T0,0030 (SP)
LW	T1,0028 (SP)
LW	T2,0034 (SP)
BEQ	T9,T0,7F0D12C8	;return FALSE if wrong value
NOP
BEQ	R0,R0,7F0D12E4
OR	V0,R0,R0
//7F0D12C8:	test second value versus A1
BEQ	T1,T2,7F0D12D8	;return FALSE if wrong value
LW	T3,002C (SP)
BEQ	R0,R0,7F0D12E4
OR	V0,R0,R0
//7F0D12D8:	return TRUE and set response
LW	T4,0038 (SP)
ADDIU	V0,R0,0001
SW	T3,0000 (T4)	;struct+14 -> A2 f/caller: return response
//7F0D12E4:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D12F4	105E24	V0= TRUE if current indy.res.cmd type 6 with expected values (A0,A1); A2,A3= responses (struct+14,+18) if TRUE
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@reponse1, A3=@response2
ADDIU	SP,SP,FFC8
SW	RA,0014 (SP)
SW	A0,0038 (SP)
SW	A1,003C (SP)
SW	A2,0040 (SP)
SW	A3,0044 (SP)
ADDIU	A1,R0,001C	;A1= 1C bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,001C	;A0=SP+1C: p->buffer
LW	T6,001C (SP)	;T6=indy.res.cmd.resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D1334	;return FALSE if invalid resourceID
LW	T7,0020 (SP)	;T7=indy.res.cmd.type
BEQ	R0,R0,7F0D13A0
OR	V0,R0,R0
//7F0D1334:	test if type 6
ADDIU	AT,R0,0006
BEQ	T7,AT,7F0D1348	;return FALSE if not type 6
LW	T8,0024 (SP)	;T8=indy.res.cmd.size
BEQ	R0,R0,7F0D13A0
OR	V0,R0,R0
//7F0D1348:	test sizes
ADDIU	AT,R0,001C
BEQ	T8,AT,7F0D135C	;return FALSE if size mismatch
LW	T9,0028 (SP)
BEQ	R0,R0,7F0D13A0
OR	V0,R0,R0
//7F0D135C:	test first value versus A0
LW	T0,0038 (SP)
LW	T1,002C (SP)
LW	T2,003C (SP)
BEQ	T9,T0,7F0D1378
NOP
BEQ	R0,R0,7F0D13A0
OR	V0,R0,R0
//7F0D1378:	test second value versus A1
BEQ	T1,T2,7F0D1388
LW	T3,0030 (SP)
BEQ	R0,R0,7F0D13A0
OR	V0,R0,R0
//7F0D1388:	return TRUE and set responses
LW	T4,0040 (SP)
ADDIU	V0,R0,0001
SW	T3,0000 (T4)	;struct+14 -> A2 f/caller
LW	T6,0044 (SP)
LW	T5,0034 (SP)
SW	T5,0000 (T6)	;struct+18 -> A3 f/caller
//7F0D13A0:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0038
JR	RA
NOP

7F0D13B0	105EE0	V0= TRUE if current indy.res.cmd type 8 with expected values (A0,A1); A2,A3= responses (struct+14,+18) if TRUE, SP+14= child indy.res.cmd of size A3
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response1, A3=@response2, SP+10=@size of child indy.res.cmd, SP+14=@child indy.res.cmd
ADDIU	SP,SP,FFC8
SW	RA,0014 (SP)
SW	A0,0038 (SP)	;SP+38= A0
SW	A1,003C (SP)	;SP+3C= A1
SW	A2,0040 (SP)	;SP+40= A2
SW	A3,0044 (SP)	;SP+44= A3
ADDIU	A1,R0,0020	;A1=20 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,0018	;A0=SP+18: p->buffer
LW	T6,0018 (SP)	;T6=struct+0: resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D13F0	;return FALSE if invalid resourceID
LW	T7,001C (SP)	;T7=struct+4: type
BEQ	R0,R0,7F0D1488
OR	V0,R0,R0
//7F0D13F0:	test if type 8
ADDIU	AT,R0,0008
BEQ	T7,AT,7F0D1404	;return FALSE if not type 8
LW	T9,0034 (SP)
BEQ	R0,R0,7F0D1488
OR	V0,R0,R0
//7F0D1404:	test sizes
LW	T8,0020 (SP)	;T8=struct+8: size
ADDIU	V0,R0,FFFC
ADDIU	T0,T9,0003
AND	T1,T0,V0	;T1=T9 to nearest word
ADDIU	T2,T1,0020
BEQ	T8,T2,7F0D1428	;return FALSE if size mismatch
LW	T3,0024 (SP)
BEQ	R0,R0,7F0D1488
OR	V0,R0,R0
//7F0D1428:	test first value versus A0
LW	T4,0038 (SP)
LW	T5,0028 (SP)
LW	T6,003C (SP)
BEQ	T3,T4,7F0D1444
NOP
BEQ	R0,R0,7F0D1488
OR	V0,R0,R0
//7F0D1444:	test second value versus A1
BEQ	T5,T6,7F0D1454
LW	T7,002C (SP)
BEQ	R0,R0,7F0D1488
OR	V0,R0,R0
//7F0D1454:	return TRUE, responses, and child entry
LW	T9,0040 (SP)
SW	T7,0000 (T9)	;struct+14 -> A2 f/caller: 
LW	T1,0044 (SP)
LW	T0,0030 (SP)
SW	T0,0000 (T1)	;struct+18 -> A3 f/caller: 
LW	T8,0034 (SP)	;T8=buffer+1C: data length
LW	T2,0048 (SP)
ADDIU	T3,T8,0003
SW	T8,0000 (T2)	;T8-> SP+10 f/caller: size to nearest word
LW	A0,004C (SP)	;A0=SP+14 f/caller: p->target
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
AND	A1,T3,V0	;A1=size to nearest word
ADDIU	V0,R0,0001	;return TRUE
//7F0D1488:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0038
JR	RA
NOP

7F0D1498	105FC8	V0= TRUE if current indy.res.cmd type A with expected values (A0,A1); A2= response (struct+14) if TRUE
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response
ADDIU	SP,SP,FFD0
SW	RA,0014 (SP)
SW	A0,0030 (SP)
SW	A1,0034 (SP)
SW	A2,0038 (SP)
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,0018	;A0=SP+18: p->buffer
LW	T6,0018 (SP)	;T6=indy.res.cmd.resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D14D4	;return FALSE if invalid resourceID
LW	T7,001C (SP)	;T7=indy.res.cmd.type
BEQ	R0,R0,7F0D1534
OR	V0,R0,R0
//7F0D14D4:	test if type A
ADDIU	AT,R0,000A
BEQ	T7,AT,7F0D14E8	;return FALSE if not type A
LW	T8,0020 (SP)	;T8=indy.res.cmd.size
BEQ	R0,R0,7F0D1534
OR	V0,R0,R0
//7F0D14E8:	test sizes
ADDIU	AT,R0,0018
BEQ	T8,AT,7F0D14FC	;return FALSE if size mismatch
LW	T9,0024 (SP)
BEQ	R0,R0,7F0D1534
OR	V0,R0,R0
//7F0D14FC:	test first value versus A0
LW	T0,0030 (SP)
LW	T1,0028 (SP)
LW	T2,0034 (SP)
BEQ	T9,T0,7F0D1518
NOP
BEQ	R0,R0,7F0D1534
OR	V0,R0,R0
//7F0D1518:	test second value versus A1
BEQ	T1,T2,7F0D1528
LW	T3,002C (SP)
BEQ	R0,R0,7F0D1534
OR	V0,R0,R0
//7F0D1528:	return TRUE and set response
LW	T4,0038 (SP)
ADDIU	V0,R0,0001
SW	T3,0000 (T4)	;struct+14 -> A2 f/caller
//7F0D1534:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D1544	106074	V0= TRUE if current indy.res.cmd type 10 with expected values (A0,A1); A2,A3,SP+10= responses (struct+14,+18,+1C) if TRUE
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response1, A3=@response2, SP+10=@response3
ADDIU	SP,SP,FFC8
SW	RA,0014 (SP)
SW	A0,0038 (SP)
SW	A1,003C (SP)
SW	A2,0040 (SP)
SW	A3,0044 (SP)
ADDIU	A1,R0,0020	;A1= 20 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,0018	;A0=SP+18: p->buffer
LW	T6,0018 (SP)	;T6=indy.res.cmd.resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D1584	;return FALSE if invalid resourceID
LW	T7,001C (SP)	;T7=indy.res.cmd.type
BEQ	R0,R0,7F0D15FC
OR	V0,R0,R0
//7F0D1584:	test if type 10
ADDIU	AT,R0,0010
BEQ	T7,AT,7F0D1598	;return FALSE if not type 10
LW	T8,0020 (SP)	;T8=indy.res.cmd.size
BEQ	R0,R0,7F0D15FC
OR	V0,R0,R0
//7F0D1598:	test sizes
ADDIU	AT,R0,0020
BEQ	T8,AT,7F0D15AC	;return FALSE if size mismatch
LW	T9,0024 (SP)
BEQ	R0,R0,7F0D15FC
OR	V0,R0,R0
//7F0D15AC:	test first value versus A0
LW	T0,0038 (SP)
LW	T1,0028 (SP)
LW	T2,003C (SP)
BEQ	T9,T0,7F0D15C8
NOP
BEQ	R0,R0,7F0D15FC
OR	V0,R0,R0
//7F0D15C8:	test second value versus A1
BEQ	T1,T2,7F0D15D8
LW	T3,002C (SP)
BEQ	R0,R0,7F0D15FC
OR	V0,R0,R0
//7F0D15D8:	return TRUE and set responses
LW	T4,0040 (SP)
ADDIU	V0,R0,0001
SW	T3,0000 (T4)	;struct+14 -> A2 f/caller: 
LW	T6,0044 (SP)
LW	T5,0030 (SP)
SW	T5,0000 (T6)	;struct+18 -> A3 f/caller: 
LW	T8,0048 (SP)
LW	T7,0034 (SP)
SW	T7,0000 (T8)	;struct+1C -> SP+10 f/caller: 
//7F0D15FC:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0038
JR	RA
NOP

7F0D160C	10613C	V0= TRUE if current indy.res.cmd type E with expected values (A0,A1); A2= response (struct+14) if TRUE
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response
ADDIU	SP,SP,FFD0
SW	RA,0014 (SP)
SW	A0,0030 (SP)
SW	A1,0034 (SP)
SW	A2,0038 (SP)
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,0018	;A0=SP+18: p->buffer
LW	T6,0018 (SP)	;T6=indy.res.cmd.resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D1648	;return FALSE if invalid resourceID
LW	T7,001C (SP)	;T7=indy.res.cmd.type
BEQ	R0,R0,7F0D16A8
OR	V0,R0,R0
//7F0D1648:	test if type E
ADDIU	AT,R0,000E
BEQ	T7,AT,7F0D165C	;return FALSE if not type E
LW	T8,0020 (SP)	;T8=indy.res.cmd.size
BEQ	R0,R0,7F0D16A8
OR	V0,R0,R0
//7F0D165C:	test sizes
ADDIU	AT,R0,0018
BEQ	T8,AT,7F0D1670	;return FALSE if size mismatch
LW	T9,0024 (SP)
BEQ	R0,R0,7F0D16A8
OR	V0,R0,R0
//7F0D1670:	test first value versus A0
LW	T0,0030 (SP)
LW	T1,0028 (SP)
LW	T2,0034 (SP)
BEQ	T9,T0,7F0D168C
NOP
BEQ	R0,R0,7F0D16A8
OR	V0,R0,R0
//7F0D168C:	test second value versus A1
BEQ	T1,T2,7F0D169C
LW	T3,002C (SP)
BEQ	R0,R0,7F0D16A8
OR	V0,R0,R0
//7F0D169C:	return TRUE and set response
LW	T4,0038 (SP)
ADDIU	V0,R0,0001
SW	T3,0000 (T4)	;struct+14 -> A2 f/caller
//7F0D16A8:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D16B8	1061E8	V0= TRUE if current indy.res.cmd type C with expected values (A0,A1); A2= response (struct+14) if TRUE
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response
ADDIU	SP,SP,FFD0
SW	RA,0014 (SP)
SW	A0,0030 (SP)
SW	A1,0034 (SP)
SW	A2,0038 (SP)
ADDIU	A1,R0,0018	;A1= 18 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,0018	;A0=SP+18: p->buffer
LW	T6,0018 (SP)	;T6=indy.res.cmd.resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
BEQ	T6,AT,7F0D16F4	;return FALSE if invalid resourceID
LW	T7,001C (SP)	;T7=indy.res.cmd.type
BEQ	R0,R0,7F0D1754
OR	V0,R0,R0
//7F0D16F4:	test if type C
ADDIU	AT,R0,000C
BEQ	T7,AT,7F0D1708	;return FALSE if not type C
LW	T8,0020 (SP)	;T8=indy.res.cmd.size
BEQ	R0,R0,7F0D1754
OR	V0,R0,R0
//7F0D1708:	test sizes
ADDIU	AT,R0,0018
BEQ	T8,AT,7F0D171C	;return FALSE if size mismatch
LW	T9,0024 (SP)
BEQ	R0,R0,7F0D1754
OR	V0,R0,R0
//7F0D171C:	test first value versus A0
LW	T0,0030 (SP)
LW	T1,0028 (SP)
LW	T2,0034 (SP)
BEQ	T9,T0,7F0D1738
NOP
BEQ	R0,R0,7F0D1754
OR	V0,R0,R0
//7F0D1738:	test second value versus A1
BEQ	T1,T2,7F0D1748
LW	T3,002C (SP)
BEQ	R0,R0,7F0D1754
OR	V0,R0,R0
//7F0D1748:	return TRUE and set response
LW	T4,0038 (SP)
ADDIU	V0,R0,0001
SW	T3,0000 (T4)	;struct+14 -> A2 f/caller
//7F0D1754:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP

7F0D1764	106294	A0= response from indy.res.cmd structure 1:4:2
	accepts: A0=@response
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D1100	;V0= TRUE if current indy.res.cmd type 1 with expected values (A0,A1)
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D1248	;V0= TRUE if current indy.res.cmd type 4 with expected values (A0,A1)
LW	A2,0018 (SP)	;A2= A0 f/caller: @response
OR	A0,R0,R0
JAL	7F0D11AC	;V0= TRUE if current indy.res.cmd type 2 with expected values (A0,A1)
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D17AC	1062DC	(A0,A1)= response from indy.res.cmd structure 1:6:2; A0=TRUE and A1=filesize if file requested by 1:5:2 indy.res.cmd found
	accepts: A0=@discovered (TRUE/FALSE), A1=@filesize
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
SW	A1,001C (SP)
ADDIU	A1,R0,001C
JAL	7F0D1100	;V0= TRUE if current indy.res.cmd type 1 with expected values (A0,A1)
ADDIU	A0,R0,001C
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0018 (SP)	;A2= A0 f/caller: @response1
JAL	7F0D12F4	;V0= TRUE if current indy.res.cmd type 6 with expected values (A0,A1)
LW	A3,001C (SP)	;A3= A1 f/caller: @response2
OR	A0,R0,R0
JAL	7F0D11AC	;V0= TRUE if current indy.res.cmd type 2 with expected values (A0,A1)
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D17FC	10632C	(A0,A1)= response, A3= p->data of size A2 from indy.res.cmd structure 1:8:2: recieve file A3, size A2
	accepts: A0=@response1, A1=@response2, A2=@data size, A3=@data
ADDIU	SP,SP,FFE0
SW	RA,001C (SP)
SW	A0,0020 (SP)
SW	A1,0024 (SP)
SW	A2,0028 (SP)
SW	A3,002C (SP)
ADDIU	A1,R0,0020
JAL	7F0D1100	;V0= TRUE if current indy.res.cmd type 1 with expected values (A0,A1)
OR	A0,R0,R0
LW	T6,0028 (SP)
LW	T7,002C (SP)
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0020 (SP)	;A2= A0 f/caller: @response1
LW	A3,0024 (SP)	;A3= A1 f/caller: @response2
SW	T6,0010 (SP)	;SP+10= A2 f/caller: @data size
JAL	7F0D13B0	;V0= TRUE if current indy.res.cmd type 8 with expected values (A0,A1)
SW	T7,0014 (SP)	;SP+14= A3 f/caller: @data
OR	A0,R0,R0
JAL	7F0D11AC	;V0= TRUE if current indy.res.cmd type 2 with expected values (A0,A1)
OR	A1,R0,R0
LW	RA,001C (SP)
ADDIU	SP,SP,0020
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D1864	106394	A0= response from indy.res.cmd structure 1:A:2
	accepts: A0=@response
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D1100	;V0= TRUE if current indy.res.cmd type 1 with expected values (A0,A1)
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D1498	;V0= TRUE if current indy.res.cmd type A with expected values (A0,A1)
LW	A2,0018 (SP)	;A2= A0 f/caller: @response
OR	A0,R0,R0
JAL	7F0D11AC	;V0= TRUE if current indy.res.cmd type 2 with expected values (A0,A1)
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D18AC	1063DC	(A0,A1,A2)= response from indy.res.cmd structure 1:10:2
	accepts: A0=@response1, A1=@response2, A2=@response3
ADDIU	SP,SP,FFE0
SW	RA,001C (SP)
SW	A0,0020 (SP)
SW	A1,0024 (SP)
SW	A2,0028 (SP)
ADDIU	A1,R0,0020
JAL	7F0D1100	;V0= TRUE if current indy.res.cmd type 1 with expected values (A0,A1)
ADDIU	A0,R0,0020
LW	T6,0028 (SP)
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
LW	A2,0020 (SP)	;A2= A0 f/caller: @response1
LW	A3,0024 (SP)	;A3= A1 f/caller: @response2
JAL	7F0D1544	;V0= TRUE if current indy.res.cmd type 10 with expected values (A0,A1)
SW	T6,0010 (SP)	;SP+10= A2 f/caller: @response3
OR	A0,R0,R0
JAL	7F0D11AC	;V0= TRUE if current indy.res.cmd type 2 with expected values (A0,A1)
OR	A1,R0,R0
LW	RA,001C (SP)
ADDIU	SP,SP,0020
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D1908	106438	A0= response from indy.res.cmd structure 1:E:2
	accepts: A0=@response
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D1100	;V0= TRUE if current indy.res.cmd type 1 with expected values (A0,A1)
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D160C	;V0= TRUE if current indy.res.cmd type E with expected values (A0,A1)
LW	A2,0018 (SP)	;A2= A0 f/caller: @response
OR	A0,R0,R0
JAL	7F0D11AC	;V0= TRUE if current indy.res.cmd type 2 with expected values (A0,A1)
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D1950	106480	A0= response from indy.res.cmd structure 1:C:2
	accepts: A0=@response
ADDIU	SP,SP,FFE8
SW	RA,0014 (SP)
SW	A0,0018 (SP)
ADDIU	A0,R0,0018
JAL	7F0D1100	;V0= TRUE if current indy.res.cmd type 1 with expected values (A0,A1)
ADDIU	A1,R0,0018
ADDIU	A0,R0,0014
ADDIU	A1,R0,0014
JAL	7F0D16B8	;V0= TRUE if current indy.res.cmd type C with expected values (A0,A1)
LW	A2,0018 (SP)	;A2= A0 f/caller: @response
OR	A0,R0,R0
JAL	7F0D11AC	;V0= TRUE if current indy.res.cmd type 2 with expected values (A0,A1)
OR	A1,R0,R0
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
ADDIU	V0,R0,0001
JR	RA
NOP

7F0D1998	1064C8	V0= TRUE if current indy.res.cmd matches expected values (A0,A1)
	accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
ADDIU	SP,SP,FFD0
SW	RA,0014 (SP)
SW	A0,0030 (SP)
SW	A1,0034 (SP)
ADDIU	A1,R0,0014	;A1=14 bytes
JAL	7F0D0F4C	;read Indy resource command of size A1 to A0
ADDIU	A0,SP,001C	;A0=SP+1C: p->buffer
LW	T6,001C (SP)	;T6=struct+0: resourceID
LUI	AT,9ABF
ORI	AT,AT,1623	;AT=9ABF1623: resourceID
LW	V0,0030 (SP)
BEQ	T6,AT,7F0D19D4	;return FALSE if invalid resourceID
LW	V1,0034 (SP)
BEQ	R0,R0,7F0D1A08
OR	V0,R0,R0
//7F0D19D4:	test first value versus A0
BEQ	V0,R0,7F0D19EC	;skip if A0 zero
LW	T7,0028 (SP)	;T7=struct+C: 
BEQ	T7,V0,7F0D19EC	;return FALSE if values differ
NOP
BEQ	R0,R0,7F0D1A08
OR	V0,R0,R0
//7F0D19EC:	test second value versus A1
BEQ	V1,R0,7F0D1A04
LW	T8,002C (SP)	;T8=struct+10: 
BEQL	T8,V1,7F0D1A08	;return TRUE if values same
ADDIU	V0,R0,0001
BEQ	R0,R0,7F0D1A08
OR	V0,R0,R0
//7F0D1A04:	return TRUE
ADDIU	V0,R0,0001
//7F0D1A08:	return
LW	RA,0014 (SP)
ADDIU	SP,SP,0030
JR	RA
NOP
