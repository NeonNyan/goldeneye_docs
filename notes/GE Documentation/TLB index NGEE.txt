At Boot:
70005D30	initialize stuff in 21990 at boot, before title screen
70005FF4	
		SW 1->800241B4; fries AT,T6

TBL index---------

base conversion for runtime addresses
	note: 70- is pure rdram; shown below are copied from rom to region
	 1000	70000400	memset (blanks) 8005D2E0 - 8008E360, sets SP->803AB410, JR to 80000450
		technically, this is used in bootcode and used prior to TLB registration
	 1050	70000450	registers 70000000-70400000 in TLB, JR to 70000510
		technically, this is used in bootcode and used prior to TLB registration
	 10BC	700004BC	V0=80020D90: target address for 21990 (USA)
	 10C8	700004C8	V0=21990: ROM address of main compressed block (USA)
	 10D4	700004D4	V0=33590: ROM address of 70200000 RareZip ASM [33590-34B30 ROM] (USA)
	 10E0	700004E0	V0=33590: ROM address of 70200000 RareZip ASM [33590-34B30 ROM] (USA)
	 10EC	700004EC	V0=34B30: ROM address of 7F- TLB routines (USA)
	 10F8	700004F8	redirect to 7020141C: decompression routine
		accepts: A0=p->source, A1=p->target, A2=p->buffer
		sets A3=7020141C, then jumps to address
	 1110	70000510	???	initializes TLB index...
		copies compressed 21990 to virtual address 701EE400, using 70200000 to decompress
	 12F0	700006F0	V0= new stack pointer; A0+A1-8
		accepts: A0=base address, A1=size
	 12FC	700006FC	1->80023044, 10000000->80023048
	 1318	70000718	A0->SP+0, infinite loop
	 1338	70000738	Null thread; executes 70000718
	 1390	70000790	Indi board detection thread; now forcably returns INDI_NOT_DETECTED (1)
	 13EC	700007EC
	 149C	7000089C	start main game setup and loop
		calls command line parser, debug console setup, etc.
		called by 70000510, using 7000D430: A0=8005D640, A1=3, A2=7000089C, A3=0, SP+10=[803B3948], SP+14=0xA
		never returns; 7000601C is an infinite loop
	 1508	70000908	V0= p->last entry in copy of debug handler code/name table; fries AT,V1,T0,T1,T6,T9
		copies table from 8002304C-80023084 to stack
	 1570	70000970	A0-> stderr.activated	[80023098]; fry AT
	 157C	7000097C	A0-> stderr.enable		[80023094]; fry AT
	 1588	70000988	A0-> stderr.permitted	[8002309C]; fry AT
	 1594	70000994	A0-> user.Compare		[800230A0]; fry AT
	 15A0	700009A0	test to display stderr and update Count
	 15F8	700009F8	test to display stderr every 16th frame
	 1688	70000A88	store current Count to 800230A4
	 16AC	70000AAC	(thread management)
	 1814	70000C14
	 1870	70000C70
	 18F8	70000CF8	V0= A0+78
	 1900	70000D00
	 1AB4	70000EB4
	 1C14	70001014
	 1D1C	7000111C	V0= 8005DB30: target for DP Cmd clock, buffer counter, pipe counter, and tmem counter
	 1D28	70001128
	 1DE0	700011E0
	 1E30	70001230
	 1FD8	700013D8
	 2040	70001440	(DPC fill)
	 2160	70001560
	 219C	7000159C	???
		uses TLB pointers at 80028400
		7000167C	3
		70001704	2,6,7
		70001758	default; 1,4,5
	 2380	70001780	sets TLB indexed entry 0 to mirror 1KB of rdram from 80000000 to C0000000
		uncached, dirty, valid, global
	 23E0	700017E0	establishes 7F- TLB buffer and management table
	 2498	70001898	???; pointless conditional tests, will reset 800230D0
	 24C0	700018C0	searches TLB index for an entry matching A0
		V0=index of match or 80000000 if not found
		accepts: A0=TLB pointer
	 2520	70001920	find and remove TLB entry A0
		accepts: A0=TLB pointer
		redirects to 700018C0, 7000D3D0
	 2554	70001954	remove index A0 TLB entry from table at 8005E3F0
		table format:
			0x0	1 if dirty
			0x1	chunk # (7F000000 | chunk<<D)
	 25D8	700019D8	loads ROM range for 7F- TLB entries
	 26F8	70001AF8	V0=p->TLB memory, or alternately end of free memory [8005E4A8]
	 2710	70001B10	V0= random value for TLB random entries [800230E0]
	 2760	70001B60	loads/resolves TLB address, writting random entry
	 29B0	70001BB0	sets #hardwired TLB entries to 2
	 29D0	70001BD0
# audio manager
	 2B58	70001F58	insert sound manager thread
		redirect to 7000D580: A0=8005E530
	 2B7C	70001F7C
	 2E44	70002244
		accepts: A0=, A1=p->audio packet
	 2FE4	700023E4
	 3024	70002424
	 31D8	700025D8
	 3210	70002610
	 3330	70002730	(DL generator)
	 33A4	700027A4
	 3410	70002810
	 3454	70002854
	 3558	70002958	draw "display speed" display
		accepts: A0=p->display list
	 38D8	70002CD8
	 3C60	70003060
	 3D24	70003124	initialize both video buffers
	 3D90	70003190	???; 2->800232BC
	 3DA0	700031A0
	 3E98	70003298
	 4704	70003B04	???; 800232B4=(word)F12, 800232B8=0xA
		accepts: F12=
	 4764	70003B64
	 47B0	70003BB0
	 4800	70003C00	sets colour output mode to 16bit	[800232AC=1]
	 4810	70003C10	sets colour output mode to 32bit	[800232AC=0]
	 481C	70003C1C	V0= p->video2's buffer [p@800232A8+28]; fry T6
	 482C	70003C2C	V0= p->video1's buffer [p@800232A4+28]; fry T6
	 483C	70003C3C	A0->video2's buffer [p@800232A8+28]; fry T6
	 484C	70003C4C	V0= halfword [80060824]
	 4858	70003C58
	 4AB4	70003EB4
	 4AF8	70003EF8	generate a generic fillrect; fries: AT,A1,A2,A3,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		V0=new display list address
		accepts: A0=p->display list
	 4B64	70003F64
	 	accepts: A0=p->display list
	 4F84	70004384	A0->[800232A0]
	 4F90	70004390	V0= [800232A0]
	 4F9C	7000439C	A0->[8002329C]
	 4FA8	700043A8	V0= [8002329C]
	 4FB4	700043B4
		A0->[p@800232A8+18], SP+0; fry V0,T0,T1
		A1->[p@800232A8+1A], SP+4
	 4FD8	700043D8	V0= [p@800232A8+18]; fry T6
	 4FE8	700043E8	V0= [p@800232A8+1A]; fry T6
	 4FF8	700043F8	set video2 text clip width (A0) and height (A1); fries V0,T0,T1
		A0->[p@800232A8+4], SP+0
		A1->[p@800232A8+6], SP+4
	 501C	7000441C	V0= video2 text clip width  [p@800232A8+4]; fry T6
	 502C	7000442C	V0= video2 text clip height [p@800232A8+6]; fry T6
	 503C	7000443C	set video2 width (A0) and height (A1)
	 509C	7000449C	V0= video2 lrx [p@800232A8+1C]; fry T6
	 50AC	700044AC	V0= video2 lry [p@800232A8+1E]; fry T6
	 50BC	700044BC	set video2 ulx (A0) and uly (A1)
	 5114	70004514	V0= video2 ulx [p@800232A8+20]; fry T6
	 5124	70004524	V0= video2 uly [p@800232A8+22]; fry T6
	 5134	70004534	A0->[p@800232A8+24]; fry T6
	 5144	70004544
	 5190	70004590	F12->video2 page width [p@800232A8+C] and something else...
	 51DC	700045DC	F0= [p@800232A8+8]; fry T6
	 51EC	700045EC
	 5250	70004650
	 52AC	700046AC	copies [p@800232A8+10-14] to A0; fries V0,T6,T7,F4,F6
	 52D0	700046D0	setfillcolour(&A0,A1,A2,A3); generates a setfillcolour op
		mode determined by flag at 800232AC: 0=32bit, 1=16bit
		accepts: A0=p->display list target, A1=red, A2=green, A3=blue
		returns: V0=updated display list target (A0 also updated)
		fries: V1,A0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
	 5358	70004758	image capture routine, jpeg 16bit colour
	 54D4	700048D4	image capture routine, jpeg 32bit colour
	 5660	70004A60	image capture routine, rgb 16bit colour
	 57B4	70004BB4	image capture routine, rgb 32bit colour
# debug notice list manager 
	 5920	70004D20	V0=p->match in debug.notice.list [800232E8] or NULL if not found
		accepts: A0=p->name, A1=p->data
	 5980	70004D80	V0=p->entry of size A0 allocated in debug.notice.list; entry allocated in block 6 on failure
		accepts: A0=size
	 59E0	70004DE0	V0=p->new entry added in debug.notice.list
	 	accepts: A0=p->name, A1=p->data
	 5A2C	70004E2C	V0= p->debug.notice.list entry for boss_c_debug using data at 800241A0
	 5A60	70004E60	V0=p->debug.notice.list entry for name A1 and data A0; generates if not found
	 	accepts: A0=p->data, A1=p->name
	 5A98	70004E98	V0=0; scan debug.notice.list until a NULL pointer
		likely this would have executed some function for each entry...
	 5ABC	70004EBC	unconditional return
	 5AC4	70004EC4	A0->SP+0, A1->SP+4, A2->SP+8
# 
	 5AE0	70004EE0
	 5B54	70004F54
	 5CAC	700050AC	V0= SP, A3=SP usage within function range (A1,A0) with initial SP A2
		accepts: A0=p->opcode.cur, A1=p->opcode.start, A2=SP w/i function, A3=p->register buffer
	 5DE0	700051E0	V0=TRUE if opcode that set RA A0 was a JAL or JALR type within bounds (70000450,70020D90)
	 	accepts: A0=p->70-mapped TLB function, presumably from RA
	 5E58	70005258	V0= strlen(A0); used exclusively for scanning ind.rea.buf
		accepts: A0=p->string
	 5E94	70005294	V0= total size of one word, two strings at hardware A0
		accepts: A0=hardware address
	 5F40	70005340	scan for and load resourceID A0 from indy.read.buf
		accepts: A0=resourceID
	 5FC8	700053C8	V0= TRUE if valid indy.read.buf.resourceID	[matches 826475BE]
	 5FFC	700053FC	unconditional return
	 6004	70005404	unconditional return
	 600C	7000540C	unconditional return
	 6014	70005414	V0= indy.read.buf.resourceID	[80063664]
	 6020	70005420	V0=hardcoded SP for debug thread A1, corrected for address range A0
		accepts: A0=p->address space, A1=entry#
	 60E4	700054E4	V0=hardcoded SP for debug thread A1, corrected for address range A0
		accepts: A0=p->address space, A1=entry#
	 6160	70005560	V0= TRUE if F12 a normal single precision float
		accepts: F12= single-precision float
	 61A4	700055A4	V0= TRUE if A1 a normal single precision float; would have set result as short at A0
		accepts: A0=(unused) p->target, A1=single-precision float
	 61C8	700055C8	removed: set normality of single-precision floats A1, A2, A3, SP+10 in table at A0
	 6228	70005628	unconditional return
# stderr manager
	 6230	70005630	write char A2 to (A0,A1) in stderr
		accepts: A0=xpos, A1=ypos, A2=char
	 62BC	700056BC	write char A0 to stderr
		accepts: A0=char
	 63CC	700057CC	scroll stderr down one line
		accepts: A0=ypos
	 645C	7000585C	print char A2 to stderr screen position (A0,A1) in video buffer 1
		accepts: A0=xpos, A1=ypos, A2=char
	 6584	70005984	set pointers to video buffers 1 & 2 to A0 and A1, respectively
		sets values to uncached addresses
		A0 | A0000000 -> 8002417C
		A1 | A0000000 -> 80024180
	 65A4	700059A4	set pointers to video buffers 1 & 2
		calls 70005984: A0=803B5000, A1=803DA800
	 65D0	700059D0	write stderr to video buffer A0
		accepts: A0=p->video buffer
# 
	 6710	70005B10	V0=value of RA previously saved to the stack or -1 if impossible to retrieve
	 	Searches backward from caller for last instance of RA saved to stack.
	 6760	70005B60	???; calls 7000D6D0: A0=800636F0, A1=800636E8
	 6790	70005B90	read A2 bytes from hardware A1 to rdram A0
		accepts: A0=p->target, A1=hardware address, A2=size
	 67F0	70005BF0	???; calls 7000DDD0: A0=800636F0, A1=0, A2=1
	 681C	70005C1C	loads A2 bytes from hardware A1 to rdram A0
		accepts: A0=p->rdram, A1=p->hardware, A2=size
		calls: 70005B90, 70005BF0
	 6844	70005C44	V0=p->data at target A0 from hardware A1 of size A2; calls 70005C1C
		accepts: A0=p->rdram, A1=p->hardware, A2=size
	 68A8	70005CA8	write A2 bytes from rdram A0 to hardware A1
		accepts: A0=p->rdram, A1=p->hardware, A2=size
	 6908	70005D08	loads A2 bytes from rdram A0 to hardware A1
		accepts: A0=p->rdram, A1=p->hardware, A2=size
		calls: 70005CA8, 70005BF0
	 6930	70005D30	??? - uses "-level_", "-m" strings
	 6BF4	70005FF4	1 ->"show mem use" debug memory display [800241B4]; fry AT,T6
	 6C04	70006004	toggle "show mem bars" [800241B8]; fries V0,T6,T7
	 6C1C	7000601C	loads primary resources and starts main program loop
		this is infinite.  Loops unconditionally: JAL 70006060
	 6C60	70006060	main program loop
			70006090 tests memstring for "-level_##"
			700060DC if not title, tests memstring for "-hard#"
			70006160 follows...
			700061FC test if debug console unconnected [800241A4]
			700062EC follows...
			700062FC tests memstring for "-ma"
			7000633C allocates "-ma" bytes to mem bank 4
			7000635C reset player data pointers
			70006364 offsets stage number based on number of players unless main menu
			700063A0 parses and sets memory allocation, loads stage, etc.
			...
			70006708 displays memory usage when active
			70006724 displays in-game debugger when active
			7000674C writes a full sync, end display list combo
			7000676C display mem use when active	[800241B4]
			700067A8 display mem bars when active	[800241B8]
			700067C0 follows...
			700067D8 tests if "u64.taskgrab.#.core" activated and dumps memory
			70006854 follows... (700068BC - stop demos)
	 7530	70006930	run title [0x5A->loaded stage#]; fry AT
		redirect to 70006950: A0=0x5A
	 7550	70006950	A0->loaded stage# [800242FC]; fry AT
		0x5A jumps to folder select
		0x5B 
		0x63 
	 755C	7000695C	V0= stage# [800241A8]
	 7568	70006968	return to title screen from stage
	 75B4	700069B4	V0=state of debug menu (1:on; 0:off) [80024300]
	 75C0	700069C0	V0= p->debug.notice.list entry for boss_c_debug using data at 800241A0
	 75F0	700069F0
	 7630	70006A30	loads sound and music banks into memory segment 6
	 7A7C	70006E7C	play first music track A0
	 7BD0	70006FD0	stop playing first music track
	 7C30	70007030	V0= [80024338]
	 7C3C	7000703C	??? - sets something for currently running music track...
		accepts: A0=value
	 7CA0	700070A0
	 7CF8	700070F8
	 7D68	70007168
	 7E04	70007204
	 7F58	70007358
	 7FB8	700073B8	V0= [80024340]
	 7FC4	700073C4
	 8028	70007428
	 8080	70007480
	 80F0	700074F0
	 818C	7000758C
	 82E0	700076E0
	 8340	70007740	V0= 7FFF [80024348]
	 834C	7000774C
	 83B0	700077B0
	 8408	70007808
	 8478	70007878
	 8514	70007914
	 8720	70007B20
	 89DC	70007DDC
	 8A80	70007E80	???
		accepts: A0=???, A1=???
		uses TLB pointer table at 80029160
		70007FBC	entry 0
		70008388	entry 1
		7000847C	entry 3
		700084F0	entry F
		700085C8	entry 7
		700088D4	default: entries 2,4,5,6,8,9,A,B,C,D,E
	 9548	70008948
	 95C4	700089C4
	 9630 	70008A30
	 96F0 	70008AF0
	 9770	70008B70
		accepts: A0=sound data offset?, A1=sample address?
	 9904	70008D04
	 99D8	70008DD8	A1->A0+0x36.  value is set in sound effect buffer?
		accepts: A0=p->SE buffer?, A1=value truncated to byte
	 99F0	70008DF0	V0= TRUE if SE playing flag set [A0+0x3F]
		value is set only when sound defaults have been set
		accepts: A0=p->SE buffer
	 9A08	70008E08	sets sound effect; used by sound effect routines
		accepts: A0=p->SE buffer, A1=SE #, A2=p->data
			data:	0x0	4	p->SE entry
				0x4	4	target volume
				0x8	4	audible range (timer)
				0xC	4	initial volume
				0x10	4	p->preset emitting sound
				0x14	4	p->object emitting sound
	 9C20	70009020	decativates sound effect
		accepts: A0=p->SE buffer
	 9C6C	7000906C
	 9D24	70009124	redirect to 7000906C: A0=1
	 9D44	70009144	redirect to 7000906C: A0=11
	 9D64	70009164	redirect to 7000906C: A0=3
	 9D84	70009184
	 9DC8	700091C8	redirect to 70009264: A0=0
	 9DE8	700091E8
	 9E38	70009238
	 9E64	70009264	V0= halfword A0 in table at [80063BA8]; fries T6,T7,T8,T9
	 9E84	70009284
	 9F80	70009380	V0=p->debug.notice.list entry for memp_c_debug
	 9FAC	700093AC	initialize memory allocation table and set font and text bank sizes
		accepts: A0=p->buffer, A1=size
		uses "-mf", "-ml", "-me" strings
	 A114	70009514	initialize allocations using table A0
		accepts: A0=p->allocation sizes
	 A320	70009720	V0=p->A0 bytes of memory allocated in bank A1; fries: AT,V0,V1,A0,A1,A2,A3,T0,T2,T5,T6,T7,T8,T9
		accepts: A0=size, A1=bank
	 A404	70009804	???; updates bank A2 size registry in light of entry at A0 of size A1
		accepts: A0=p->allocated data, A1=size of data, A2=bank#
	 A4F0	700098F0	V0=8 -- loop eight times, needlessly; fries AT,T6
		used by "show mem use", step 1; probably originally listed all eight memory allocations
	 A510	70009910	V0= total allocated size of bank A0
		accepts: A0=bank#
	A570	70009970	allocate A0 coded #bytes in bank
		accepts: A0=size/bank# entry (ssssssss ssssssss sssssssss sssssbbb)
	 A59C	7000999C	reset memory bank A0 [0-6]
		copies base address for memory bank A0 to +4, fry +C
	 A5C4	700099C4
		accepts: A0=bank#
	 A610	70009A10	swap allocation entries A0 and A1; fries V0,V1,T6,T7
		accepts: A0=p->DW1, A1=p->DW2
	 A634	70009A34	merge allocation entry A1 with A0, removing A1; fries T6,T7,T8
	 A650	70009A50	check memory allocation table, merging and sorting entries.  V0=TRUE if table A0 altered; fries AT,A0,A1,V1,T6,T7,T8
		accepts: A0=p->allocation table, usually at 80063C28
	 A718	70009B18	merge and sort default memory allocation table until at its most efficient
		calls 70009A50 until table 80063C28 no longer changes
	 A760	70009B60
	 A874	70009C74
	 A96C	70009D6C	V0=p->debug.notice.list entry for mema_c_debug
	 A998	70009D98	resets entire memory table and starts over with mem[0]=A0, size A1
		accepts: A0=p->allocated memory, A1=size
	 AA10	70009E10	merge and sort entries in default memory allocation table;
		calls 70009A50: A0=80063C28
	 AA34	70009E34
	 ABA8	70009FA8
	 ABFC	70009FFC
	 AC20	7000A020	redirect to 70009C74
	 AC40	7000A040	V0=80064C08, V1=80063C28.  loop and add +0x20 to V1 until it matches V0
		this one really makes you wonder...
	 AC64	7000A064
	 AD00	7000A100	generate ordered list of 200 largest allocated blocks of memory
		note: this string is not output and invalid on return
	 AE9C	7000A29C	debug memory table sort and merge function: generate memory block table, sort and merge table, then generate a new list
		used by "show mem use", step 2
	 AEF8	7000A2F8
	 AF70	7000A370
	 AFDC	7000A3DC
	 B050	7000A450	V0= random number [80024460]; fries AT,A0,A1,A2
	 B098	7000A498	set random random number to A0+1	ret. A0=0; fries AT,A0
	 B0AC	7000A4AC	V0= rand num, using double at A0 as base; fries A1,A2,A3,V0
	 B0F0	7000A4F0	V0= strtok(A0,' ') - breaks up string A0, replacing spaces with NULLs
		up to 0x28 entries allowed (more will cause issues)
			80024470	#strings
			80024474	p->current substring#
			80024478	list of pointers to the start of each string
			note this routine has a glitch:
			it tests only for ' ' at 7000A518, but at 7000A55C tests for all values < 0x21
	 B18C	7000A58C	strtok(strcpy(80064C30, string),' '); used to handle memory allocation string
		redirect: 7000A770: A0=80064C30, A1=p->string; 7000A4F0: A0=80064C30
		accepts: A0=p->string
	 B1C0	7000A5C0	parse command line options
		tests if debug console present [redirect to 7000CEA8]
		if not, 0->80064C30.  Else, copies FFB000-FFB280 -> 80064C30, treated as a pointer to a string
		if "-d" set, returns V0=1; "-s" set, disable sound=1 [800243F8]; "-j" set, language=1 [800484D0]
		if returns 1, set debug with 7000D740: A0=NULL
		uses "-d", "-s", "-j" flags
	 B2A0	7000A6A0	V0= p->A0th instance of token A1
		used to return numerical part following memory allocation values, for example
		implies you've already used a strtok() command on a string.
		typical usage would be A0=1 for first match, A0=2=second match, etc.
	 B370	7000A770	V0= strcpy(A0,A1) - copy string A1 to A0; fries V1,A1
	 B3A0	7000A7A0	V0= strncpy(A0,A1,A2) - copy A2 bytes from string A1 to A0; fries V1,A0,A1,A2
	 B3FC	7000A7FC	V0= strcat(A0,A1) - append string A1 on A0; fries V1,A1,T6,T7
	 B44C	7000A84C	V0= strcmp(A0,A1) - test if strings A0 and A1 identical; fries AT,V1,A0,A1
		returns V0= 0 if true, 1 if A0<A1, -1 if A0>A1; A0 and A1 will be p->first differing character
	 B490	7000A890	unused return
	 B498	7000A898	V0= strncmp(A0,A1,A2) - test if the next A2 bytes in strings A0 and A1 identical; fries AT,V1,A0,A1,A2
		returns V0= 0 if true, 1 if A0<A1, -1 if A0>A1; A0 and A1 will be p->first differing character
	 B4F8	7000A8F8	V0=toupper(A0) - if 60<A0<7B, subtract 0x20; fries AT,T6,T7
	 B530	7000A930	V0=isdigit(A0) - if 30<A0<3A, return TRUE; fries T6
	 B550	7000A950	V0=isalpha(A0) - if A0 is A-Z or a-z, return TRUE; fries V1,T6
	 B58C	7000A98C	V0=isspace(A0) - if A0=0x20, 0x9, 0xA, 0xC, 0xB, return TRUE; fries T6
	 B5E0	7000A9E0	V0=strtol(A0,A1,A2)
		accepts: A0=p->string, A1=@last character read or NULL, A2=base (hex by default)
		Operates rougly like normal strtol() C-function.  A1, if defined, is an address to store a pointer to the last character read.  Used primarily when parsing pad values.
		if A2 is zero, decimal implied unless the value uses operators.  Otherwise, state what base the value is in (0xA for base 10, 0x10 for hex, etc.).
	 B870	7000AC70	V0= mempcpy(A0,A1,A2) - copies A2 bytes from A1 to A0, returning p->next byte; fries V1,A2,T6
		redirect to 70013850.  V0= result+A2
	 B894	7000AC94	sprintf(A0,A1,A2,A3,...) - calls c-parser; NULL terminates strings it outputs
		accepts: A0=p->final string, A1=p->string to parse, A2=argument1, A3=argument2, SP+10=argument3, etc...
		calls: 70013F60; A2 and A3 are set as arguments.  This routine would access SP+10 as though it were the next entry in the list, magically
		argument format:
			long value for all integer types
			double value for float types; use two sequential arguments for upper and lower half of value
			pointer for string type
			character (as int) for char type
	 B8F0	7000ACF0
# video manager
	 B930	7000AD30	unconditional return
	 B938	7000AD38	vi_c_debug: 
	 B980	7000AD80	A0->SP+0, A1->SP+4, V0=0
	 B990	7000AD90	A0->SP+0, A1->SP+4, V0=0
	 B9A0	7000ADA0	unconditional return
	 B9A8	7000ADA8	unconditional return
	 B9B0	7000ADB0	reset stdout display; redirects to 7000AF00
	 B9D0	7000ADD0	write char A2 to stdout at position (A0,A1)
	 	accepts: A0=xpos, A1=ypos, A2=char
	 BADC	7000AEDC	reset stdout x and y positions to upper left margin
		copies 80024FA0/4 -> 80024FA8/C
	 BB00	7000AF00	reset stdout display
	 BB84	7000AF84	removed: copy stdout char from position (A0,A1) to (A2,A3)
		accepts: A0=source x, A1=source y, A2=target x, A3=target y
		now only copies A0->SP+0, A1->SP+4, A2->SP+8, A3->SP+C
	 BB98	7000AF98	scroll stdout A0 lines; A0 should be a negative offset (-2 scrolls up two lines)
		accepts: A0=number of lines to push up
	 BC40	7000B040	translates and saves stdout text position (A0,A1); fries AT,A0,A1,T6,T7
		accepts: A0=xpos, A1=ypos
	 BC6C	7000B06C	set stdout text (foreground) color, alpha inverted [800268AC]; fries T0,T1,T2,T3,T6,T7,T8,T9
		accepts: A0=red, A1=green, A2=blue, A3=alpha (inverted)
	 BC98	7000B098	set stdout background color, alpha inverted [800268B4]; fries T0,T1,T2,T3,T6,T7,T8,T9
		accepts: A0=red, A1=green, A2=blue, A3=alpha (inverted)
	 BCC4	7000B0C4	write char A0 to stdout (debug menu)
		accepts: A0=char
	 BDC0	7000B1C0	write char A2 to (A0,A1) in stdout, translating position (debug menu)
		accepts: A0=xpos, A1=ypos, A2=char
		calls: 7000B040, 7000B0C4
	 BDE8	7000B1E8	write string A0 to stdout (debug menu)
		accepts: A0=p->string
	 BE30	7000B230	write string A2 to (A0,A1) in stdout
		accepts: A0=xpos, A1=ypos, A2=p->string
	 BE7C	7000B27C	7000B27C	BE7C	write stdout to screen
		accepts: A0=p->display list
# joystick manager
	 C160	7000B560	joy_c_debug: 
	 C2AC	7000B6AC
	 C328	7000B728	removed: V0=3 (output enabled | slot filled); V0=3, A0->SP+0
		accepts: A0=p->controller packet
		V0 is forced to return "output enabled" | "slot filled"
		org. V0= state of mempak dictated by controller packet A0
	 C334	7000B734	tests controller A0's for a rumble pak, generating rumble on/off commands if found
	 C410	7000B810	tests for disconnected controllers
	 C5F8	7000B9F8	V0= #controllers plugged in; fries V1,T0,T1,T6,T7,T8,T9
	 C670	7000BA70	V0= flags indicating which controllers are plugged in [800268D0]
	 C67C	7000BA7C	??? - oscillates rumble pak when required
	 C7A8	7000BBA8	A0-> ramrom replay TLB handler [80026924], A1-> #controllers (command size) [80065324]; fries AT
		A0 is a pointer to a TLB address, probably to handle the ramrom file loaded
		A1 is the #controllers, which also is the size of the commands
	 C7BC	7000BBBC	A0->ramrom record TLB handler [80026928]; fries AT
		must be a pointer [7F0BFE5C] or NULL
	 C7C8	7000BBC8	???
		accepts: A0=p->controller input index
	 C90C	7000BD0C	redirect to ramrom replay and record handlers if set
	 C988	7000BD88
	 CCEC	7000C0EC	V0= current position left<->right of controller A0's control stick
		fries: V1,A0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
	 CD74	7000C174	V0= previous position left<->right of controller A0's control stick
		fries: V1,A0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
	 CDFC	7000C1FC	V0= current position up<->down of controller A0's control stick
		fries: V1,A0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
	 CE84	7000C284	V0= previous position up<->down of controller A0's control stick
		fries: V1,A0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
	 CF0C	7000C30C	test player A0's controller for button mask A1 held; fries V1,A0,A1,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		looks to 80064F30 for buffered sets of 6 bytes per player
	 CFAC	7000C3AC	test player A0's controller for button mask A1 pressed; fries V1,A0,A1,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		used on main menus, so probably doesn't use control type mask
			8000	A button
			4000	B button
			2000	Z button
			1000	Start button
			0800	up-Dpad
			0400	down-Dpad
			0200	left-Dpad
			0100	right-Dpad
			0020	L button
			0010	R button
			0008	up-C button
			0004	down-C button
			0002	left-C button
			0001	right-C button
	 D030	7000C430	print controller button state: print 16 bits in A1 as ' ' or '1' to A0, top to bottom
		accepts: A0=p->address, A1=value
		Reads from 0x8000 to 0x1.  If set prints '1', else ' '.
	 D070	7000C470	V0=#controllers connected; loops and redetects once for each controller
	 D0B4	7000C4B4	V0=state of player A0's control stick; -2 left : 1 right; fries AT,V1,A0,A1,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		accepts: A0=player#, A1=mask?, A2=1?
		these values probably indicate the deadzone or something
	 D128	7000C528	V0=state of player A0's control stick; -2 down : 1 up; fries AT,V1,A0,A1,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		accepts: A0=player#, A1=low range (-2)?, A2=high range (1)?
	 D19C	7000C59C	??? - tests control stick left/right
	 D20C	7000C60C	??? - tests control stick up/down
	 D27C	7000C67C
	 D2BC	7000C6BC
	 D2FC	7000C6FC
	 D334	7000C734
	 D378	7000C778
	 D3BC	7000C7BC
	 D408	7000C808
	 D454	7000C854	triggers A1 seconds of rumble on controller A0; fries: AT,V0,V1,A0,T0,T1,T2,T6,T7,T8,F4,F6,F8,F12
		accepts: A0=player#, A1=(float) time; multiplied by 60.0 in function
	 D4DC	7000C8DC	reset controller and rumble pak detection
	 D530	7000C930	set controller input index to set A0 [800268C4]; fries: AT,T6,T7,T8
	 D554	7000C954	V0=current controller input index (80064F30 + V0*0x1FC)
		fries: AT,T6,T7
	 D580	7000C980	send rumble off packet to PIFram [800655A0+offset]
		accepts: A0=p->controller packet for player
	 D6AC	7000CAAC	send rumble on packet to PIFram [800656A0+offset]
		accepts: A0=p->controller packet for player
	 D7DC	7000CBDC	generate PIF command: A3=request write data at A2 to block A1 of channel A0; exclusively used for rumble pak
		accepts: A0=channel#, A1=block#, A2=p->start.buffer, A3=@target (0x40)
	 D938	7000CD38	rumble pak output handler; tests for valid paks and generates rumble on/off PIF commands
		accepts: A0=p-> [80065350], A1=p->controller packet [800653F8+pl.*0x68], A2=controller#
	 DAA0	7000CEA0	unconditional return; 
	 DAA8	7000CEA8	V0= 1; would have returned 0 if debug console present
		if it were zero, would attempt to copy a memory range from FFB000 to 80064C30-80064EB0, 0x280 large
	 DAB0	7000CEB0	V0= -1
	 DAB8	7000CEB8	unconditional return; called by 7F0D01D0
	 DAC0	7000CEC0	unconditional return; 
	 DAC8	7000CEC8	unconditional return; 
	 DAD0	7000CED0	unconditional return; 
	 DAD8	7000CED8	unconditional return; 
	 DAE0	7000CEE0	unconditional return; 
	 DAE8	7000CEE8	write A2 chars in string A1 to stderr
		accepts: A0=p->target(unused), A1=p->source, A2=length
	 DB44	7000CF44	c-style expansion of string A0 to stderr
		accepts: A0=p->string, A1=arg.1, A2=arg.2, A3=arg.3, SP+10,n=arg.n
		calls 70013F60: A0=7000CEE8, A1=0, A2=[A0], A3=SP+24
			SP+24=[A1], SP+28=[A2], SP+2C=[A3], SP+30,n=[SP+10,n]
	 DB90	7000CF90	sets PI request
		accepts: A0=mode (0-write;1-read), A1=p->source, A2=p->target, A3=size
	 DC70	7000D070	V0= PI status [A4600010]; fries T6
	 DC80	7000D080	initialize PIF, interrupt handlers, C0- and 7F- TLB segments, init NMIbuffer if cold run, init 64DD if present
	 DF20	7000D320	CACHE 80000000 - 80002000; fries AT,T0,T1,T2
	 DF50	7000D350	invalidate Cache for A1 bytes at A0
		accepts: A0=p->address, A1=size
	 DFD0	7000D3D0	removes TLB index A0 without damaging previously set EntryHi
	 E010	7000D410	V0= control register from COP1 (F31)
	 E020	7000D420	V0= COP1 control, then sets COP1 control to A0
	 E030	7000D430	initialize thread entry at A0
		accepts: A0=p->target, A1=set to thread+18, A2=p->function executing thread, A3= value passed to A2 as A0, SP+10=p->stack, SP+14=p->parent list
		thread entry:
			0x0	4	p->entry
			0x4	4	priority
			0x8	4	p->parent
			0xC	4	p->previous
			0x10	2	index 1-8
			0x12	2	
			0x14	4	
			0x18	4	True sets FPU regs
			all values 20-100 are doublewords set to AT-RA
			0x108	8	Mult LO
			0x110	8	Mult HI
			0x118	4	COP0 Status mask
			0x11C	4	function to execute 'game' when table erets
			0x120	4	
			0x124	4	
			0x128	4	MI Interrupt mask
			0x12C	4	COP1 Status
			all values 0x130 - 0x1B0 are double float values set to F0-F30
	 E120	7000D580	insert thread A0 and execute if no thread running
		accepts: A0=p->thread
	 E2D0	7000D6D0	???; thread management
		80027720->A0+0, 80027720->A0+4, 0->A0+8, 0->A0+C, A2->A0+10, A1->A0+14
		accepts: A0=@target, A1=p->???, A2=value
	 E340	7000D740	??? - looks like this sets the debug console interface
		accepts: A0=p->value or NULL
			7000D7A4	4 or A0=NULL
				1->@80027730, redirect to 700107AC: A0=0
			7000D7C4	2 or 8
			7000D7E0	default
	 E400	7000D800	change priority to A1 for thread A0 or current thread if NULL
		accepts: A0=p->thread or NULL, A1=priority
	 E4E0	7000D8E0	V0= COP0 Count
	 E4F0	7000D8F0
	 E678	7000DA78
	 E850	7000DC50	set interrupt table entry #A0 with p->data A1 and value A2
		accepts: A0=entry#, A1=p->data, A2=value
		
		7000DD30
		7000DDD0	??? - something with thread management
		accepts: A0=p->thread list, A1=p->buffer or NULL, A2=permit errors (True/False)
		7000DF10	???
		accepts: A0=p->???, A1=??, A2=???
		7000E060
		7000E0D0
		7000E200
		7000E260
	 EED0	7000E2D0	set or unset (A0=1,0) 0x20 flag in short at @80028044+0; fries AT,V0,A0,T0,T1,T2,T6,T7,T8,T9
		7000E340
	 EFC0	7000E3C0	sets DPC counters to A0; clock, buffer, pipe, and tmem respectively
		accepts: A0=p->target
		7000E410
		7000E450
		7000E490
	 F0E0	7000E4E0	A0-> DPC Status
		7000E4F0
		7000E60C
		7000E76C
	 F3B0	7000E7B0	sets A3 bytes of commands at A0 to DP Cmd Start/End
		accepts: A0=p->commands, A1=(unused), A2=(no application), A3=size
	 F460	7000E860	set signal 0 in RSP Status register; fry A0
		redirects to 70018EE0: A0=00000400
	 F480	7000E880	V0= TLB address assigned to index A0; moves A0->index, V0 from EntryHi
	 F4B0	7000E8B0	V0=rdram offset derived from pointer A0; fries: AT,V0,A0,T0,T1,T2,T3,T4,T5,T6,T7
		used to produce microcode memory addresses for ops
		A0 should be a valid pointer, but may be to rdram, uncached memory, or a TLB address
		7000E930
		
	 F71C	7000EB1C
	 F750	7000EB50	V0= p->A3 blocks of data of SP+10 bytes each allocated in sound buffer entry A2
		accepts: A0=(unused), A1=(unused), A2=p->sound buffer entry, A3=#blocks, SP+10=block size
	 F7B0	7000EBB0
	 F840	7000EC40	(V0,V1) = (A0,A1) >> (A2,A3) [logical], treating each pair as a doubleword
			accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
	 F86C	7000EC6C	(V0,V1) = (A0,A1) % (A2,A3), treating each pair as a doubleword
			accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
	 F8A8	7000ECA8	(V0,V1) = (A0,A1) / (A2,A3), treating each pair as a doubleword
			accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
	 F8E4	7000ECE4	(V0,V1) = (A0,A1) << (A2,A3), treating each pair as a doubleword
			accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
	 F910	7000ED10	(V0,V1) = (A0,A1) % (A2,A3), treating each pair as a doubleword
			accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
	 F94C	7000ED4C	(V0,V1) = (A0,A1) / (A2,A3) [signed], treating each pair as a doubleword
			accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
	 F9A8	7000EDA8	(V0,V1) = (A0,A1) * (A2,A3), treating each as a DW pair
			accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
			V0=upper word of product, V1 lower word of product
	 F9D8	7000EDD8	divide DW (A2,A3) by short at SP+12, placing quotient in A0 and modulo in A1
		accepts: A0=p->quotient, A1=p->modulo, A2=DW upper, A3=DW lower, SP+12=[short] divisor
	 FA38	7000EE38	(V0,V1) = (A0,A1) % (A2,A3) [signed], treating each pair as a doubleword
		accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
	 FAD4	7000EED4	(V0,V1) = (A0,A1) >> (A2,A3) [arithmetic], treating each pair as a doubleword
		accepts: A0=DW1 upper, A1=DW1 lower, A2=DW2 upper, A3=DW2 lower
	 FB00	7000EF00	set p->audio A0 of length A1 in AI Register; V0=0 okay or -1 on error
		accepts: A0=p->audio, A1=length
	 FBB0	7000EFB0	V0=AI Length
	 FBC0	7000EFC0	unconditional return
		7000EFC8
		7000F020
		7000F058
		7000F0B8
		7000F0D0
	 FD00	7000F100	unconditional return
		7000F108
		7000F3A0
	102A0	7000F6A0	send PI transfer request; 80027790 must be set!
		V0=0 normally, -1 if not available
		accepts: A0=p->???, A1=???, A2=mode (0-read;1-write), A3=p->hardware, SP+10=p->rdram, SP+14=size, SP+18=p->???
		7000F7B0
	10570	7000F970	V0=p->A2 bytes copied from A0 to A1
		accepts: A0=p->source, A1=p->target, A2=size
		7000FC80
		7000FEB0
		7000FF10
		70010010
		70010098
		700100C8
	10D80	70010180	V0=80027734: 
	10D90	70010190	jump for interrupt handler, copied serially
		K0=700101A0, JR K0
	10DA0	700101A0	interrupt handler
		???	uses TLB pointers at 80029460, selecting with offsets at 80029440
		700103C8	2,3
		700103D4	4,5,6,7
		700103E0	8,9,A,B,C,D,E,F
		70010400	18,19,1A,1B,1C,1D,1E,1F
		70010454	14,15,16,17
		70010594	1
		700105F0	12,13
		70010610	11	reset?
		70010648	0,10
	113AC	700107AC	update current thread's registers, then insert in queue and execute
		accepts: A0=p->thread queue or NULL
	114AC	700108AC	insert thread A1 into thread queue A0
		accepts: A0=p->thread queue, A1=thread entry
	114F4	700108F4	V0= popped thread
		accepts: A0=p->tbl
	11504	70010904	switch and execute threads
	11680	70010A80	default return address for all threads; JAL 7001BB60: A0=0
	11690	70010A90	remove thread A1 from thread queue A0
		accepts: A0=p->thread queue, A1=p->thread entry
	116D0	70010AD0	set priority of current thread to 2, then update, insert, and execute
	11720	70010B20	cache A1 bytes at A0 prior to hardware read request
	117D0	70010BD0	cache A1 bytes at A0 prior to hardware write request
		70010C50
	11930	70010D30	initialize sound buffer entry A0 with buffer A1 and size A2
		accepts: A0=p->entry, A1=p->buffer, A2=buffer size
	11970	70010D70	unconditional return
	11978	70010D78	unconditional return
		70010D80
		
	11A6C	70010E6C	unconditional return
	11A74	70010E74	expand all offsets in soundtable A0, wavebank A1
		accepts: A0=p->"B1" soundtable, A1=hardware address
	11B78	70010F78
		accepts: A0=p->list of entries, A1=base for conversion
		70010FC0
		70011030
	11C64	70011064	unconditional return
		7001106C
		7001123C
	12664	70011A64	unconditional return
		70011A6C
		70012080
		700121F0
	12E30	70012230	V0= TRUE if music playing [V0=A0+2C]
		accepts: A0=p->music controller
		70012240
		700122E0
		70012380
		70012444
	1309C	7001249C	unconditional return
		700124A4
		7001279C
		700128B0
		70012A1C
		70012A24
		70012B20
		70012B8C
	13900	70012D00	??? - do something to music at controller A0
		redirects to 70012EFC: A0+=48, A1=@{000D0000, A1<<10}, A2=0
		accepts: A0=p->music controller, A1=value
	13940	70012D40	??? - do something to music at controller A0
		redirects to 70012EFC: A0+=48, A1=@{000F0000}, A2=0
		accepts: A0=p->music controller
	13970	70012D70	??? - do something to music at controller A0
		redirects to 70012EFC: A0+=48, A1=@{00110000}, A2=0
		accepts: A0=p->music controller
	139A0	70012DA0	??? - do something to music at controller A0
		redirects to 70012EFC: A0+=48, A1=@{000A0000, A1<<10}, A2=0
		accepts: A0=p->music controller, A1=value
		70012DE0
		70012E8C
		70012EFC
		accepts: A0=p->???, A1=p->values (4 shorts?), A2=???
		70013020
		700130AC
		70013120
		70013170
		70013258
		700133A0
		70013440
		700134D0
		70013560
		700135F0
		70013690
		70013710
		700137C0
	14410	70013810	copies word from p->hardware A0 to p->rdram A1
		V0=0 (70017BE0 always=0)
		redirect to 7001D760; return V0=70017BE0: A0, A1; 7001D7A4
		accepts: A0=p->hardware address, A1=rdram address
	14450	70013850	V0= memcpy(A0,A1,A2) - copy A2 bytes from A1 to A0; fries V1,A2,T6
	1447C	7001387C	V0= strlen(A0); fries V1,T6,T7
	144A4	700138A4	V0= strchr(A0,A1) - V0=TRUE if value A1 occurs in string A0; fries V1,A0,T6
		700138F0
	14B60	70013F60	parses c-style variables, replacing them with values
		accepts: A0=copy function [7000AC70], A1=p->final string, A2=string to parse, A3=p->arguments, each in sequence
		returns: V0=strlen, p->final string @ A1
		known allowed commands:
			%#0d	(long) value
			%#0o	(long) value
			%#0x	(long) value
			%#0X	(long) value
			%+-.#0f	(double) value; use two sequential arguments for upper and lower half of value
			%s	p->string
			%c	(long) char value
		700145B0
	
	15340	70014740	returns device plugged into controller port A2
		V0=flags
			1	output enabled
			2	controller slot filled
			8	rumble pak in slot
		accepts: A0=p->[80065350], A1=p->controller packet, A2=channel#, A3=p->[800268D8+pl.offset]
	153F4	700147F4	V0=state of controller slot A1
		retrieve current controller status from PIF, storing to 80067D70
		returns V0=error state	0-OK, 1-slot empty, 2-no slot response, 4-bad address CRC, 8-not present
		accepts: A0=???, A1=channel#
	15500	70014900	???; sets A1=presence flags and A2=status list for channels 0-4
		accepts: A0=???, A1=p->presence flags target, A2=p->status list target
	156F8	70014AF8	return device presence flags in A0, status list in A1 for current PIF status in buffer
	157C8	70014BC8	generate PIFram command: request status for #channels at 80067CE1
		places command at 80067CA0
		accepts: A0=???
	158C0	70014CC0	retrieve current controller status from PIF, storing at 80067CA0
	15944	70014D44	return status list in A0 for current PIF status in buffer
		calls 70014AF8: A0=SP+1F, A1=A0 f/caller
	15970	70014D70	retrieve controller input from PIF, storing at 80067CA0
	15A34	70014E34	copy data or errors for controllers - used during runtime
	15ADC	70014EDC	generate PIFram command: read controller input to 80067CA0
		70014FD0
	15C40	70015040
	15E30	70015230
	15F40	70015340
	160F0	700154F0
	161FC	700155FC
	16420	70015820
		70015960
	166A0	70015AA0	set flags for each present device in A1; V0=-1 if SI error occurred
		accepts: A0=, A1=p->buffer for presence flags
	16840	70015C40	generate PIFram command: request status for #channels at 80067CE1
		places command at 80067D70
		accepts: A0=???
	1693C	70015D3C	generates status list from ram PIFram output at A1
		accepts: A0=???, A1=p->target
		status list format:
			0x0	2	controller type (byteswapped from PIFram)
			0x2	1	controller slot state
			0x3	1	error byte: 8-not present, 4-I/O error
	16A10	70015E10
	16A60	70015E60
	16AA4	70015EA4	calls 7000DF10: A0=80067DB8, A1=0, A2=0
	16AD0	70015ED0	read or write data from PIFram: SI I/O operations
		V0=0 on success, -1 otherwise
		accepts: A0=mode (0-read; 1-write), A1=p->RDRAM target or source
	16B80	70015F80	V0= PIFram address.CRC for address A0; fries: AT,A0,A1,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
	16C30	70016030	V0= PIFram data.CRC for data at A0; fries: AT,A0,A1,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		accepts: A0=p->data
	16D00	70016100	sends data A3 to controller slot A1 at address A2, returning status
		will not operate on blocks 1-6
		accepts: A0=p->???, A1=channel#, A2=block#, A3=p->data, SP+10=
	16F30	70016330	generate PIFram command: request write data at A2 to block A1 of controller A0's slot
		places command at 80067D70
		accepts: A0=channel#, A1=block#, A2=p->data
	170B0	700164B0	reads block A2 from controller A1 to @A3
		accepts: A0=, A1=channel#, A2=block#, A3=p->data
	172F4	700166F4	generate PIFram command: request read of block A1 from controller A0's slot
		places command at 80067D70
		accepts: A0=channel#, A1=block#
	17460	70016860
	17720	70016A20
	17770	70016A70
	177C4	70016BC4
	17830	70016C30	redirects to 70016C60: A0 |= 0x4000 (forces second table)
	17860	70016C60	V0= next eye intro drift
		accepts: A0=previous drift value
			draws from 80027FCE table if 0x4000 set
			draws from 800277D0 table if 0x4000 not set
	178D0	70016CD0
		70016D18
		70016D70
		70016E90
		70016EE4
		70016F30
		70017370
		700173F0
		700176A8
		70017720
		700178B4
		70017910
		7001792C
		70017948
	18684	70017A84	F0= double (A1<<32 | A0); fries T6,F4,SP+0,SP+4
	1869C	70017A9C	F0= float (A1<<32 | A0); fries T6,F4,SP+0,SP+4
		70017AB4
		70017AE8
	18720	70017B20	A0-> COP0 status register
	18730	70017B30	V0= COP0 status register
	18740	70017B40	SI direct read: copy value from uncached address A0 to A1; V0=0 if okay or -1 if SI error
		accepts: A0=SI/PIF address, A1=p->target
	18790	70017B90	SI direct write: write value A1 to uncached address A0; V0=0 if okay or -1 if SI error
		accepts: A0=SI/PIF address, A1=value
	187E0	70017BE0	PI direct read: copies word from uncached hardware address A0 to A1; V0=0 if successful; fries AT,A2,T0,T1,T2,T3,T6,T7,T8,T9
		accepts: A0=hardware address, A1=p->target
		A1= @(A0000000 | @80000308 [B0000000] | A0)
	18840	70017C40	initialize A1 bytes at A0 to zero
		accepts: A0=p->target, A1=value
		70017CE0
		70017D30
		70018414
		700184FC
	191F0	700185F0	V0= COP0 status interrupt enabled flag; fries AT,T0,T1
		unsets flag in COP0 status
	19210	70018610	Set flags A0 in COP0 status; fries T0
		70018630
		700186BC
	19434	70018834	increment COP0 Count by A1
		accepts: A0=???, A1=increment
		700188A8
	19630	70018A30	V0=priority of thread A0 or cur.thread if NULL
		accepts: A0=p->thread
		70018A50
	19760	70018B60	V0=80028040: 
		70018B70
	19AD0	70018ED0	V0= RSP status register; fries T6
	19AE0	70018EE0	A0->RSP status register; fries T6
		70018EF0
	19B30	70018F30	read or write (A0) A3 bytes between RSP address A1 and rdram A2; fries AT,A0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		returns V0=0 if set, or nonzero if not ready
		sets A1->RSP_MEM_ADDR, A2->RSP_DRAM_ADDR, A3->RSP_RD or RSP_WR depending on mode
		accepts: A0=mode (0-write; 1-read), A1=RSP address, A2=rdram address, A3=length
	19BC0	70018FC0	V0= TRUE if RSP Status flags 0x1C set; fries A0,T6,T7
	19BF0	70018FF0	V0= TRUE if DPC Status DMA busy flag (0x100) set; fries A0,T6,T7
	19C20	70019020	V0= rdram offset corresponding to TLB address A0, or -1 if invalid; fries: AT,T0,T1,T2,T3,T4,T5
		note this returns an offset, not true address starting 80/A0
	19CE0	700190E0	0->A0+0
		700190F0
		70019120
		70019164
		700191B8
		7001920C
		70019294
		7001933C
		700193E0
	1A080	70019480	??? - uses TLB pointers at 80029830
		70019528	1: S3=80028050
		70019534	2: S3=800280B8
		7001954C	3: S3=80028168
		70019558	4: S3=80028190
		70019540	5: S3=80028140
		70019564	6: S3=V0+20: 
		7001956C	default: S3=800281B8
	1A4C0	700198C0
		70019960
		70019990
		70019AB0
		70019C84
		7001A030
		7001A15C
	1B200	7001A600	??? - uses TLB pointers at 80029850
		7001A630	1
		7001A6C0	2,3,5,6,default
		7001A638	4
		7001A6A4	7
		7001A6B4	8
		7001A674	9
	1B2EC	7001A6EC
		7001A900
		7001A928
		7001A950
		7001AA14
		7001AAF4
	1B7B4	7001ABB4	displays debug messages if S2 nonzero
		if S1=0 generates "\n--- ASSERTION FAULT - source - env.c, line 373\n\n"
	1BA54	7001AE54	unconditional return
	1BA5C	7001AE5C	???	uses TLB pointers at 80029968
		7001AF74	D
		7001B0B4	B,C,10
		7001B304	E
		7001B358	F
		7001B398	0
		7001B3B8	default
	1C0E0	7001B4E0
		7001B510
		7001B5F0
		7001B624
		7001B6B0
	1C400	7001B800	if 80027790 !0, V0=80027798, else V0=0; fries T6
		7001B830
		7001B970
		7001B9A0
		7001BB60
		7001BC60
		7001BCB4
		7001BD34
	1C9E8	7001BDE8	unconditional return
		7001BDF0
		7001BE14
		7001BE9C
		7001BFC8
		7001C070
		7001C0E0
		7001C1BC
		7001C234
		7001C27C
		7001C2F0
		7001C360
	1D05C	7001C45C	???	uses TLB pointers at 80029A50
		7001C4A0	90
		7001C7F4	80
		7001C84C	A0
		7001C8B4	D0
		7001C92C	B0
			uses TLB pointers at 80029BD4
			7001C994	V0=A
			7001C9F0	V0=7
			7001CA84	V0=10
			7001CA9C	V0=40
			7001CB48	V0=5B
			7001CC64	default
		7001CB98	C0
		7001CBCC	E0
		7001CC64	default
	1D874	7001CC74	unconditional return
	1D87C	7001CC7C	???	uses TLB pointers at 80029C28
		7001CCE0	0
		7001CD8C	9
		7001CDAC	5
		7001CDF8	6
		7001CE5C	16
		7001CF6C	17
		7001CFF4	2
		7001D014	7
		7001D028	F
		7001D04C	10
		7001D0BC	11
		7001D14C	A
		7001D1B4	B
		7001D1D0	C
		7001D1EC	D
		7001D23C	E
		7001D24C	default
	1DEA0	7001D2A0
		7001D3A4
		7001D414
		7001D5A0
		7001D690
	1E310	7001D710	???
		1->800282E0, redirect to 7000D6D0: A0=80068FE8, A1=80068FE0, A2=1; 7000DF10: A0=80068FE8, A1=0, A2=0
	1E360	7001D760	if [800282E0] not set, redirect to 7001D710
		redirect to 7000DDD0: A0=80068FE8, A1=SP+1C, A2=1
	1E3A4	7001D7A4	redirect to 7000DF10: A0=80068FE8, A1=0, A2=0
		7001D7D0
		7001DA70
		7001DFD8	unconditional return
		7001DFE0
	1F130	7001E530	request I/O with hardware A0; read/write (A1) SP+10 bytes between hardware offset A2 and rdram A3
		accepts: A0=BSD hardware entry, A1=read/write (0,1), A2=hardware offset, A3=p->rdram, SP+10=length
	1F210	7001E610	???	uses TLB pointers at 80029CF0
		7001E814	A
		7001E854	B
		7001E890	E
		7001E8D8	F
		7001E920	9
		7001E940	default
	1F5C0	7001E9C0
	1F61C	7001EA1C	generate CRC16s for 0x1C bytes of mempak data
		accepts: A0=p->source, A1=@(short) CRC, A2=@(short) invert CRC
	1F684	7001EA84	??? - called when mempak blocks 1-7 + 0x18 isn't 0001 or file corrupt
		accepts: A0=p->controller packet, A1=p->data from mempak block, A2=p->buffer for new mempak block
	1FA9C	7001EE9C	tests mempak blocks 1,3,4,6 for a valid entry, copying it to blocks 1,3,4,6
		returns V0=0 if OK, 4 if SI I/O error, 8 if not present, A if all CRCs invalid (corrupt mempak)
		accepts: A0=p->controller packet, A1=p->data from mempak block
	1FC34	7001F034	tests validity of mempak file; if present, pulls mempak blocks 1 and 7
		7001F290
		7001F38C
	202AC	7001F6AC	sends a block set to packet+65 to controller slot block 0x400; presumably resets device
		accepts: A0=p->controller packet
	20320	7001F720	V0= TRUE if SI not ready, FALSE otherwise
	20350	7001F750	??? - concerns distance...; fries: F0,F2,F4,F6,F8,F10,F12,F14,F16,F18
		accepts: A0=p->xyz position set1, A1=p->xyz position set2, A2=p->xyz position set3
	203E0	7001F7E0	F0= square root of F12	[sqrt(F0)]
		7001F7F0	sets PI Domain 2 hardware entry for 64DD; V0=p->entry (80069000)
		7001F8E0	A0->COP1 Compare register
	204F0	7001F8F0	??? - initialize ?; A1->A0+4, A2->A0+8, A3->A0+10
		accepts: A0=p->???, A1=???, A2=???, A3=???
		7001F910
		7001F9B8
		7001FA70
		7001FBF8
		7001FD84
	20BA8	7001FFA8	??? - uses TLB pointers at 80029D10
		accepts: A0=???, A1=routine, A2=???
			7001FFD4	A1=2
			70020004	A1=3
			70020034	A1=5
			70020064	A1=4
			70020094	A1=0,6
			700200C4	A1=7
			70020108	A1=8
			70020184	A1=1,9
		700201C0
		700201D8	??? - utilizes JAL to previously-registered routine
		70020520
		7002053C
	21158	70020558	V0=A0+C; 
	21160	70020560	unconditional return
		70020568
		70020738
		70020858
		7002093C
		70020990
		700209E8
		70020A38
		70020A68
	21740	70020B40	??? - saves A0->SP+0, A2->SP+8, A2->A1+16
		accepts: A0=???, A1=p->???, A2=(short) ???
		70020B50
		70020C50
		70020CE0
	21940	70020D40	store word A2 to offset A1 using BSD hardware entry A0
		accepts: A0=BSD hardware entry, A1=hardware offset, A2=value
	21990	70020D90	ENDPOINT

+-+

RareZip decompression library
Secondary bank, assigned to rdram range
conversion factor	+701CCA70
	33590	70200000	decompress.buildtable
	33BE4	70200654	decompress.inflate
	33FD8	70200A48	decompress.type0: store
	3412C	70200B9C	decompress.type1: fixed-table
	34294	70200D04	decompress.type2: dynamic-table
	347B8	70201228	decompress.table: figures out table type if present or end of file, pushing to decompressor for type
	348D8	70201348	decompress.start: presumes the first five registers filled
	349AC	7020141C	V0=size of data A0 decompressed to A1 using buffer A2: sets state of decompression object and decompresses
		accepts: A0=p->source, A1=p->target, A2=p->buffer
		70201474
	
data segment and registers
	34A10	70201480	RESERVED	p->source
	34A14	70201484	RESERVED	p->target
	34A18	70201488	RESERVED	cur. offset in source
	34A1C	7020148C	RESERVED	decompressed data count
	34A20	70201490	RESERVED	p->buffer (alias table, I think...)
	34A24	70201494	order (19 bytes)
	34A38	702014A8	length codes base (31 short values)
	34A74	702014E4	RESERVED
	34A78	702014E8	length codes extra bits (bytes)
	34A98	70201508	distance codes base (32 short values)
	34AD4	70201544	distance code extra bits (32 bytes)
	34AF4	70201564	RESERVED	sample
	34AF8	70201568	RESERVED	bits in sample
	34AFC	7020156C	masks (12 short values)
	34B20	70201590	
	34B24	70201594	
	34B28	70201598	RESERVED
	34B2C	7020159C	RESERVED

+-+

conversion factor	+7EFCB4D0
 34B30:	7F000000
	34B30	7F000000	initialize menus and data at power-on; 	fries AT,V0,V1,F0,F4
	34C10	7F0000E0
		calls 7F06C460: A0=7F01F53C; 7F000518
	34C40	7F000110	reset counters for random bodies and heads
	34D20	7F0001F0
	34DC0	7F000290
	34E5C	7F00032C
	34F9C	7F00046C
	35000	7F0004D0
	35048	7F000518
	354B0	7F000980	redirect to 7F0009A0
	354D0	7F0009A0
	35500	7F0009D0	unconditional return
	35510	7F0009E0	A0-> [80036414], A1-> [80036418], A2-> [8003641C]; fries AT
	35530	7F000A00	expand animation table entries; fries: V0,V1,A1,A2,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		animation source at ROM 0x124AC0
		accepts: A0=p->list of animation table entries
	355DC	7F000AAC	allocate, load, and expand animation tables
	35690	7F000B60	???; 8003C580 -> 8003C650
	356B0	7F000B80
	356F0	7F000BC0	unconditional return
	35700	7F000BD0
		??? - searches image index...
	357A0	7F000C70	allocate introduction matrices
	35850	7F000D20	initialize menus or reset
	35970	7F000E40
	359E8	7F000EB8	allocate and intialize A0 + 10 GUARDdata entries
		accepts: A0= #guards; actual allocation is A0 + 0xA
	35A80	7F000F50	set new random heads and bodies
	35B50	7F001020	initialize objective register and difficulty multipliers
		0->80030978, 1.0->8002CE40, 1.0->8002CE44, 1.0->8002CE4C, 0->8002CE50
	35B8C	7F00105C	allocate false actor GUARDdata to execute global actions in setup file (1xxx type)
	35D88	7F001258	debug object load feature: loads all models mentioned in action block table
		detects commands 04,1B,BD,BE,BF,C0
	35F3C	7F00140C	debug weapon load feature: load each model in table at 8002A23C
	35FE0	7F0014B0	initialize sound effects registers [80069B70]; fries V0,V1
	36010	7F0014E0
	36100	7F0015D0	allocate lookup buffers
	36280	7F001750	reinitializes stuff when switching menus
		7F001910
		7F001928
		7F001940
	36488	7F001958	write monitor animation control blocks to 80075B98
	36638	7F001B08	initialize 80071E00-80071E78
	36680	7F001B50
	36704	7F001BD4
	368CC	7F001D9C	prepares and loads object
	36958	7F001E28	inhibit respawn flag: "The Living Daylights"
	36984	7F001E54	inhibit respawn flag: "Man with the Golden Gun"
 36B30:	7F002000
	37268	7F002738	expand type 08 object; sets guard and MP weapons
	373A0	7F002870	expansion routine for all 8 MP weapons
	374D8	7F0029A8
	3754C	7F002A1C	redirect to 7F001D9C; used by 04 key object expansion
		REMOVED IN REVISED ROMS
	3756C	7F002A3C
		
	37788	7F002C58	expand type 0D object - autoturret
		accepts: A0=, A1=, A2=
	3794C	7F002E1C	redirect to 7F001D9C
	3796C	7F002E3C
		
	38720	7F003BF0	stage loading code; contains setup, object parsing, and when finished playing cleans up memory
		tests memory string for -nochr, -noprop, -noobj
 38B30:	7F004000	Object data expansion routines:
	uses TLB pointer table at 8004EF68
		38EB8	7F004388	12	actor attribute
		38F10	7F0043E0	01	door
		38EEC	7F0043BC	09	actor
		38F40	7F004410	02	door scale
		38F64	7F004434	08	item; calls 7F002738
		38F98	7F004468	04	key
		38FCC	7F00449C	11	hat
		39000	7F0044D0	06	surveillance camera
		39030	7F004500	0D	autogun
		39060	7F004530	0C	rack
		39090	7F004560	0A	single-screen display
		390C0	7F004590	0B	multi-screen display
		390F0	7F0045C0	15	body armour
		39144	7F004614	2F	tinted glass
		39260	7F004730	03, 05, 07, 24, 29, 2A, 2B
		39290	7F004760	14	ammo box
		39344	7F004814	2D	tank
		393D4	7F0048A4	27	wheeled vehicle
		39484	7F004954	28	aircraft
		394FC	7F0049CC	16	tag
		39530	7F004A00	25	rename
		39564	7F004A34	23	solo briefing text entry; calls 7F004FA0
		39574	7F004A44	2E	viewport position
		395F4	7F004AC4	17	create objective; calls 7F004FB8
		39604	7F004AD4	20	subobjective: enter room; calls 7F004FF4
		39614	7F004AE4	21	subobjective: deposit in room; calls 7F00500C
		39624	7F004AF4	1E	subobjective: photograph target
		3962C	7F004AFC	0E, 0F, 10, 13, 18-1D, 1F, 22, 26, 2C
	uses TLB pointer table at 8004F02C	
		39940	[7F004E10]	reset 80075D00 pointers when unloading stage
		399B0	[7F004E80]	quit stage loader
	399F0	7F004EC0
	
	39AB8	7F004F88	set A0's parent (A0+8) and set as current tag entry [80075D80]; fries: V0,T6
		accepts: A0=p->setup type 16 entry
	39AD0	7F004FA0	set setup briefing text entry A0's parent (A0+C) and store as final entry [80075D84]; fries V0,T6
		accepts: A0=p->setup briefing entry (setup type 23)
	39AE8	7F004FB8	add pointer to objective A0 in 80075D30 table
		also sets objective# to 800322F0 if highest
		accepts: A0=p->setup objective entry (setup type 17)
	39B24	7F004FF4	set A0's parent (A0+C) and set as current "enter room" subobjective entry [80075D88]; fries: V0,T6
		accepts: A0=p->setup type 20 entry
	39B3C	7F00500C	set A0's parent (A0+10) and set as current "object depositted in room" subobjective entry [80075D8C]; fries: V0,T6
		accepts: A0=p->setup type 21 entry
	39B54	7F005024	set A0's parent (A0+C) and set as current "photograph object" subobjective entry [80075D90]; fries: V0,T6
		accepts: A0=p->setup type 1E entry
	39B70	7F005040
	39C00	7F0050D0	initialize current player's BONDdata and statistics
	39F80	7F005450
	3A050	7F005520
	3A064	7F005534
	3A070	7F005540
	3A154	7F005624
	3A240	7F005710	sets weapon models for thrown/generated objects: calls next 13 entries
		3A270	7F005740	03	A1=00BA	throwing knife
		3A278	7F005748	18	A1=00CB	grenade launcher round
		3A280	7F005750	19	A1=00CA	rocket
		3A288	7F005758	1A	A1=00C4	grenade
		3A290	7F005760	1B	A1=00C9	timed mine
		3A298	7F005768	1C	A1=00C8	proximity mine
		3A2A0	7F005770	1D	A1=00C7	remote mine
		3A2A8	7F005778	20	A1=00CA	rocket
		3A2B0	7F005780	21	A1=00E2	bombcase
		3A2B8	7F005788	22	A1=0111	plastique
		3A2C0	7F005790	2F	A1=00F5	bug
		3A2C8	7F005798	30	A1=00F6	microcamera
		3A2CC	7F00579C	default
	3A2F4	7F0057C4	load camera/intro type value: calls next 9 entries
		3A5AC	7F005A7C	0 spawn point
		3A620	7F005AF0	1 weapon
		3A6A8	7F005B78	2 ammo
		3A6D0	7F005BA0	3 swirling intro camera
		3A758	7F005C28	4 intro animation
		3A76C	7F005C3C	5 cuff/character
		3A780	7F005C50	6 fixed cameras
		3A844	7F005D14	7 watch time
		3A8BC	7F005D8C	8 credits
 3AB30:	7F006000
	3AD20	7F0061F0
	3AD8C	7F00625C	allocate and initialize 0x1E + A0 inventory entries for cur. player
		accepts: A0=#additional inventory entries
	3ADF0	7F0062C0
	3AEBC	7F00638C
	3B2F0	7F0067C0
	3B3C0	7F006890
	3B8C0	7F006D90	allocate explosion, smoke, casings, scorch, and impact buffers
	3BCB0	7F007180
	3BDC0	7F007290
	3BDE0	7F0072B0
	3BE28	7F0072F8	disable on-screen text(?); sets 0->BONDdata+12B4, 0->BONDdata+12B5
	3BE50	7F007320	set -mt texture allocation
	3BEE0	7F0073B0
 
		7F007700
		7F007770
		7F007800
		7F007920
	3C4A0	7F007970	unconditional return
	3C4B0	7F007980
	3C570	7F007A40
		accepts: A0=p->display list
	3C6C4	7F007B94	insert sight backdrop in Eye intro
		accepts: A0=p->display list
		7F007CC8
	3C8BC	7F007D8C	insert sniper sight in Eye intro
		accepts: A0=p->display list
		7F007E70
 
 3CB30:	7F008000
 
	3CDF8	7F0082C8	insert Bond in Eye intro
		accepts: A0=p->display list
	3CFF0	7F0084C0	load and display Rare logo
	3D688	7F008B58
		
	3D900	7F008DD0
		??? - loads 0x2A4D50
		7F008E80
		
		7F009254
		
		7F009744
	3E290	7F009760	writes text to screen at absolute coordinates
		if english, redirects to 7F0ADABC
		if japanese, redirects to 7F0AE6EC using background colour at 8002A9B0
		accepts: A0=p->display list target, A1=p->x position, A2=p->y position, A3=p->text,
			SP+10=p->2nd font table, SP+14=p->1st font table, SP+18=font colour,
			SP+1C=clip width, SP+20=clip height, 
			SP+24=y offset, SP+28=x offset
	3E378	7F009848	V0= TRUE if cheat A0 is available; jumps to unlock detection routines
		7F009874	default - nonmenu cheats
		7F00987C	Invincible
		7F00989C	All Guns
		7F0098BC	No Radar
		7F0098DC	Fast Animation
		7F0098FC	Bond Invisible
		7F00991C	Infinitie Ammo
		7F00993C	DK Mode
		7F00995C	Tiny Bond
		7F00997C	Slow Animation
		7F00999C	Paintball Mode
		7F0099BC	Silver PP7
		7F0099DC	Gold PP7
		7F0099FC	Enemy Rockets
		7F009A1C	2x Rocket L.
		7F009A3C	2x Grenade L.
		7F009A5C	2x RC-P90
		7F009A7C	2x Throwing Knife
		7F009A9C	2x Hunting Knife
		7F009ABC	2x Laser
		7F009ADC	Turbo Mode
		7F009AFC	(Cradle Completed)
		7F009B10	(Aztec Completed)
		7F009B24	(Egypt Completed)
		7F009B38	DO NOT USE - infinite loop
		7F009B40	return for all types
	3E680	7F009B50	V0= p->name of player A0's favored weapon in hand A1
		calls: 7F0670DC: 800696F0 + player*8 + hand*4
		accepts: A0=player#, A1=hand (0-left : 1-right)
	3E6B4	7F009B84	??? - handles control stick tracking for menus
	3EA38	7F009F08	loads and draws selected icon for folder select [8002A918]
		0=sight, 1=copy, 2=delete
 3EB30:	7F00A000
	3EBB0	7F00A080	Add tab 1 ("START")?
	3ED14	7F00A1E4	V0=TRUE if cursor is on tab 1; fries AT,F4,F6,F8,F10
			h.pos>390.0 & v.pos<=130.5 (800519D8)
	3ED68	7F00A238	Add tab 3 ("PREVIOUS")
	3EECC	7F00A39C	V0=TRUE if cursor is on tab 3; fries AT,F4,F6,F8,F10
			h.pos>390.0 & v.pos>=223.0
	3EF20	7F00A3F0	set cursor position to tab 2; fries AT,F4,F6
			h.pos=399.0 (800519DC), v.pos=144.0
	3EF44	7F00A414	Add tab 2 ("NEXT")
	3F0A8	7F00A578	V0=TRUE if cursor is on tab 2; fries AT,F0,F4,F6,F8,F10
			h.pos>400.0 &  130.5 (800519E0)<v.pos<=233.0
	3F118	7F00A5E8	initialize menu 00: legal screen
		7F00A6B0
	3F20C	7F00A6DC	menu 00 interface: legal screen
	3F2C8	7F00A798	menu 16 interface: no controller warning
	3F314	7F00A7E4	display aligned white text to screen
		accepts: A0=display list target, A1=x pos, A2=y pos, 
			A3=alignment type (0-left, 1-center, 2-right)
			SP+10=width multiplier, SP+14=p->text, SP+18=p->2nd font table, SP+1C=p->1st font table
		uses 7F0ADABC to write text
	3F410	7F00A8E0	menu 00 constructor: legal screen
	3F61C	7F00AAEC	0->menu timer [8002A8CC]; fry AT
	3F628	7F00AAF8	unconditional return to RA
	3F630	7F00AB00	menu 17 interface: switch screens
	3F6D8	7F00ABA8	menu 17 constructor: switch screens
	3F6F8	7F00ABC8	initialize menu 01: Nintendo logo
		7F00ACA4
	3F7F8	7F00ACC8	menu 01 interface: Nintendo logo
	3F8C8	7F00AD98	menu 01 constructor: Nintendo logo
	3FB94	7F00B064	initialize menu 02: Rare logo
	3FBD4	7F00B0A4
		unconditional return to RA
	3FBDC	7F00B0AC	menu 02 interface: Rare logo
	3FC64	7F00B134	menu 02 constructor: Rare logo
	3FC84	7F00B154	initialize menu 03: Eye intro
		7F00B190
	3FCE0	7F00B1B0	menu 03 interface: Eye intro
	3FD68	7F00B238	menu 03 constructor: Eye intro
	3FD88	7F00B258	initialize menu 04: GoldenEye splash screen
	3FE34	7F00B304	set menus have run [8002A930=0] and ignore title splash on skip [8002A960=0]; fries AT,A0
		calls: 7F06C234
	3FE60	7F00B330	menu 04 interface: GoldenEye splash screen
	3FFAC	7F00B47C	menu 04 constructor: GoldenEye splash screen
	40254	7F00B724	disable all switches in object A0 (hide all)
	402F0	7F00B7C0	sets item A1 in object instance A0 to mode A2 (1=visible:0=invisible)
		accepts: A0=p->obj. instance, A1=#offset in header for item, A2=in/visible (0:1)
	40338	7F00B808	selects and loads Bond picture (A1) used on folders
		accepts: A0=p->obj. instance, A1=[beta] selected Bond (0-3)
	403DC	7F00B8AC	loads walletbond, used to construct main menus
		7F00B990
	40518	7F00B9E8	initialize menu 05: file select screen (4 folders)
	40610	7F00BAE0
	4064C	7F00BB1C	V0= chapter briefing entry# for briefing A0
	40698	7F00BB68	??? - toggle deletion minimenu on folder A0
		accepts A0=folder#
	406FC	7F00BBCC	menu 05 interface: file select screen (4 folders)
 40B30:	7F00C000
	40EB4	7F00C384	V0= p->name of difficulty A0
	40F38	7F00C408	menu 05 constructor: file select screen (4 folders)
	41D80	7F00D250	initialize menu 06: main folder menu (mode select menu)
	41DC0	7F00D290	unconditional return
	41DC8	7F00D298	menu 06 interface: main folder menu
	42118	7F00D5E8
	4232C	7F00D7FC	main folder menu - set cursor position to mode setting A0; fries: AT,T6,T7,F4,F6,F8
		x=126.0, y=226.0+A0*32.0
		accepts: A0=mode setting (0-solo, 1-multi, 2-cheats)
	42358	7F00D828	menu 06 constructor: main folder menu
	427F0	7F00DCC0	V0=briefing for solo stage A0 or -1; fries V1,T6,T7,T8
		also: T6=stage text ID
	4283C	7F00DD0C	detect if solo stage A0 completed on difficulty A1 in current eeprom folder; redirects to 7F01E2C0
		uses briefing data, called on solo stage select
	42890	7F00DD60	V0=highest unlocked difficulty for solo stage A0
		accepts: A0=solo stage# (Dam=0, Facility=1, etc.)
	42980	7F00DE50	initialize menu 07: solo mission select
	429E0	7F00DEB0	unconditional return; used at 7F01A898
	429E8	7F00DEB8	menu 07 interface: solo mission select
 42B30:	7F00E000
	42F10	7F00E3E0	set cursor position to stage A0 on solo mission select page; fries AT,V0,T0,T1,T6,T7,T8,T9,F4,F6,F8,F10
	42F88	7F00E458	menu 07 constructor: solo mission select
	432B0	7F00E780	initialize menu 08: mission objectives
	432E8	7F00E7B8	unconditional return
	432F0	7F00E7C0	menu 08 interface: mission objectives
	435EC	7F00EABC	print current solo briefing stage name to screen
		accepts: A0=p->display list, A1=string buffer (sprints to this address)
	43894	7F00ED64	set cursor position for difficulty A0 on selection page
	438C8	7F00ED98	menu 08 constructor: mission objectives
	43E30	7F00F300	initialize menu 09: 007 options and tabs, loading folder resources
	43E9C	7F00F36C	unconditional return; used at 7F01A8D0
	43EA4	7F00F374	menu 09 interface: 007 options
	442C8	7F00F798	menu 09 constructor: 007 options
 44B30:	7F010000
	44BEC	7F0100BC	V0= player's control style; A0=player# 0-3, fry T6
	44C00	7F0100D0	V0= TRUE if MP stage entry A0 is unlocked; fry AT,V0,V1,A0,A1,T6,T7,T8,T9
	44CA0	7F010170	handles selecting game length under different scenarios
	44D08	7F0101D8	copy aim settings to player data; fries AT,A0,V0,V1,T6,T7,T8
	44D6C	7F01023C	advance aim settings selection; fries AT,A0,V0,V1,T6,T7,T8
	44DB0	7F010280	set 64 MP characters available; fry AT,T6
	44DC0	7F010290	V0= selected MP # players or 1; fry AT,T6 (T6=mode)
	44DEC	7F0102BC	V0= MPchar head; A0=player# 0-3, fry A0,V0,V1,T6,T7,T8
	44E3C	7F01030C	V0= MPchar gender; A0=player# 0-3, fry A0,V0,V1,T6,T7,T8
	44E8C	7F01035C	V0= MPchar body; A0=player# 0-3, fry A0,V0,V1,T6,T7,T8
	44EDC	7F0103AC	F0= player handicap; A0=player# 0-3, fry AT,A0,T6,T7,T8,F0
	44F00	7F0103D0	F0= MPchar height; A0=player# 0-3, fry AT,A0,V0,T6,T7,T8,F0
	44F50	7F010420	V0= time f/ selected MP length; fries T6,T7 (T6=#selected)
	44F74	7F010444	V0= score f/ selected MP length; fry T6,T7 (T6=#selected)
	44F98	7F010468	reset MP options for selected scenario [A0]
		7F0104DC	set normal and team scenario specific settings
		7F01051C	set you only live twice scenario specific settings
		7F010550	set the living daylights scenario specific settings
		7F010594	set man with the golden gun scenario specific settings
		7F0105C8	set license to kill scenario specific settings
	45138	7F010608	initialize MP menu for current scenario and player count
		accepts: A0=#players selected
	4526C	7F01073C	initialize menu 0E: multiplayer options
	45370	7F010840	unconditional return
	45378	7F010848	menu 0E interface: multiplayer options
		[7F010DD8]	press A: start stage
		[7F010DF4]	press A: 'Players' selected
		[7F010E34]	press A: 'Scenario' selected
		[7F010E50]	press A: 'Level' selected
		[7F010E6C]	press A: 'Game Length' selected
		[7F010E84]	press A: 'Select Character' selected
		[7F010EA0]	press A: 'Weapons' selected
		[7F010EB8]	press A: 'Health' selected
		[7F010ED4]	press A: 'Control Style' selected
		[7F010EF0]	press A: 'Aim' selected
		[7F010F04]	return
	45A40	7F010F10	menu 0E constructor: multiplayer options
	46708	7F011BD8	V0= #players who have selected MP character entry A0; fries AT,V1,A0,A1,A2,A3,T0,T6,T7,T8,T9
	467EC	7F011C3C	initialize menu 0F: MP character selection window
	469FC	7F011ECC	unconditional return - used at 7F01A978
	46A04	7F011ED4	menu 0F interface: character select
 46B30:	7F012000
		7F0122A8
		7F01231C
	472C4	7F012794	menu 0F constructor: character select
	47960	7F012E30	initialize menu 10: handicap select
	479EC	7F012EBC	unconditional return - used at 7F01A9B0
	479F4	7F012EC4	menu 10 interface: handicap select
	47CAC	7F01317C	menu 10 constructor: handicap select
	480A4	7F013574	initialize menu 11: control style
	48130	7F013600	unconditional return - used at 7F01A9CC
	48138	7F013608	menu 11 interface: control style
	484B0	7F013980	menu 11 constructor: control style
	488A8	7F013D78	initialize menu 12: multiplayer stage select menu and load folder resources
		calls: 7F00B8AC
	488FC	7F013DCC	unconditional return - used at 7F01A9E8
	48904	7F013DD4	menu 12 interface: multiplayer stage select
 48B30:	7F014000
	48B80	7F014050	menu 12 constructor: multiplayer stage select
	49288	7F014758	V0= MP scenario
	49294	7F014764	initialize menu 13: scenario select folder tabs and load folder resources
		calls: 7F00B8AC
	492E0	7F0147B0	unconditional return - used at 7F01A95C
	492E8	7F0147B8	menu 13 interface: scenario select
	49578	7F014A48	menu 13 constructor: scenario select
	497B8	7F014C88	V0= player A0's team/scenario item flag (stats+69); fries T6
	497D4	7F014CA4	A1->player A0's team/scenario item flag (stats+69); fries AT,T6
	497F0	7F014CC0	initialize menu 14: team setup
		resets folder tab selection and highlight
		3->80069788 if scenario 2vs1; else 2->80069788
		0->8002B560
		jumps to 7F00B8AC
	49870	7F014D40	unconditional return - used at 7F01A994
	49878	7F014D48	menu 14 interface: team setup
	49C68	7F015138	menu 14 constructor: team setup
	4A040	7F015510	A0->current menu 0A briefing page [8002A914]
	4A050	7F015520	load briefing and text for selected stage
		returns V0= #entries in briefing
	4A124	7F0155F4	initialize menu 0A: mission briefings
		7F015640
	4A1CC	7F01569C	menu 0A interface: mission briefings
	4A538	7F015A08	print objectives and their status to main menus
		accepts: A0=p->display list, A1=y position, A2=p->string buffer, A3=1-print status
	4A8A4	7F015D74	menu 0A constructor: mission briefings
 4AB30:	7F016000
	4AB94	7F016064	initialize menu 0B: stage active
		calls: 70006950: A0=stage# [8002A8F4]; 7F0BFC1C: A0=difficulty [8002A8FC]
	4ABC4	7F016094	initialize menu 0C: mission failed
	4AC38	7F016108	unconditional return
	4AC40	7F016110	menu 0C interface: mission failed
	4AE4C	7F01631C

	4AF1C	7F0163EC	menu 0C constructor: mission failed
	4B1AC	7F01667C	initialize menu 0D: mission complete
	4B200	7F0166D0	unconditional return
	4B208	7F0166D8	menu 0D interface: mission complete
	4B538	7F016A08	menu 0D constructor: mission complete
	4C680	7F017B50	initialize menu 15: cheat menu
		builds 800697F0 cheat menu table using available cheats
	4C724	7F017BF4
		??? - involves selected cheat options
	4C7B8	7F017C88
	
	4C7B8	7F017C88	menu 15 interface: cheat menu
	4CA8C	7F017F5C	menu 15 constructor: cheat menu
 4CB30:	7F018000
	4CF68	7F018438	initialize menu 16: no controller warning
		unconditional return - used at 7F01AC80
	4CF70	7F018440	unconditional return - used at 7F01AA20
	4CF78	7F018448	menu 16 interface: no controller - unconditional return
	4CF80	7F018450	menu 16 constructor: no controller warning
	4D1A0	7F018670	if A0 TRUE, play extended actor intro [8002B5FC] and do not play intro movie [8002B5E8]
	4D1CC	7F01869C	initialize menu 18: actor intro
		4D34C	7F01881C	use blue suit (17) w/ solo head (4B) for Bond
		4D360	7F018830	use camo (18) w/ solo head (4B) for Bond
		4D374	7F018844	use snowsuit (19) w/ solo head (4B) for Bond
		4D388	7F018858	use tux (05) w/ multi head (4E) for Bond
		4D3F0	7F0188C0	construct character for cast intro - calls true random head
	4DA48	7F018F18
	4DA90	7F018F60	menu 18 interface: actor intro
	4DE58	7F019328	menu 18 constructor: actor intro
 4EB30:	7F01A000
	4EECC	7F01A39C	initialize menu 19: beta - Spectrum emulator
	4EFB0	7F01A480	unconditional return - used at 7F01AA58
	4EFB8	7F01A488	menu 19 interface: beta - Spectrum emulator
	4F010	7F01A4E0	menu 19 constructor:  beta - Spectrum emulator
	4F104	7F01A5D4	set to menu A0 in mode A1 (0-current,1-return); fry AT,T6,T7
	4F140	7F01A610	V0= current menu
	4F14C	7F01A61C	menu update, initialization, and interface handler
			7F01AAC8	menu 00 initialization - redirect to 7F00A5E8
			7F01AADC	menu 01 initialization - redirect to 7F00ABC8
			7F01AAF0	menu 02 initialization - redirect to 7F00B064
			7F01AB04	menu 03 initialization - redirect to 7F00B154
			7F01AB18	menu 04 initialization - redirect to 7F00B258
			7F01AB2C	menu 05 initialization - redirect to 7F00B9E8
			7F01AB40	menu 06 initialization - redirect to 7F00D250
			7F01AB54	menu 07 initialization - redirect to 7F00DE50
			7F01AB68	menu 08 initialization - redirect to 7F00E780
			7F01AB7C	menu 09 initialization - redirect to 7F00F300
			7F01AB90	menu 0A initialization - redirect to 7F0155F4
			7F01ABA4	menu 0B initialization - copies stage and difficulty settings; redirect to 7F016064
			7F01ABB8	menu 0C initialization - redirect to 7F016094
			7F01ABCC	menu 0D initialization - redirect to 7F01667C
			7F01ABE0	menu 0E initialization - redirect to 7F01073C
			7F01ABF4	menu 13 initialization - redirect to 7F014764
			7F01AC08	menu 0F initialization - redirect to 7F011C3C
			7F01AC1C	menu 14 initialization - redirect to 7F014CC0
			7F01AC30	menu 10 initialization - redirect to 7F012E30
			7F01AC44	menu 11 initialization - redirect to 7F013574
			7F01AC58	menu 12 initialization - redirect to 7F013D78
			7F01AC6C	menu 15 initialization - redirect to 7F017B50
			7F01AC80	menu 16 initialization - redirect to 7F018438
			7F01AC94	menu 18 initialization - redirect to 7F01869C
			7F01ACA8	menu 19 initialization - redirect to 7F01A39C
			7F01ACB8	menu 17 initialization	
		uses TLB table at 80051C1C for interface reroute
			7F01ACDC	menu 00 interface reroute
			7F01ACEC	menu 17 interface reroute
			7F01ACFC	menu 01 interface reroute
			7F01AD0C	menu 02 interface reroute
			7F01AD1C	menu 03 interface reroute
			7F01AD2C	menu 04 interface reroute
			7F01AD3C	menu 05 interface reroute
			7F01AD4C	menu 06 interface reroute
			7F01AD5C	menu 07 interface reroute
			7F01AD6C	menu 08 interface reroute
			7F01AD7C	menu 09 interface reroute
			7F01AD8C	menu 0A interface reroute
			7F01AD9C	menu 0C interface reroute
			7F01ADAC	menu 0D interface reroute
			7F01ADBC	menu 0E interface reroute
			7F01ADCC	menu 13 interface reroute
			7F01ADDC	menu 0F interface reroute
			7F01ADEC	menu 14 interface reroute
			7F01ADFC	menu 10 interface reroute
			7F01AE0C	menu 11 interface reroute
			7F01AE1C	menu 12 interface reroute
			7F01AE2C	menu 15 interface reroute
			7F01AE3C	menu 16 interface reroute
			7F01AE4C	menu 18 interface reroute
			7F01AE5C	menu 19 interface reroute
			7F01AE6C	menu 0B interface
			[7F01AEF0]	return
	4FA2C	7F01AEFC	menu construction
			7F01AF34	menu 00 constructor reroute
			7F01AF44	menu 17 constructor reroute
			7F01AF54	menu 01 constructor reroute
			7F01AF64	menu 02 constructor reroute
			7F01AF74	menu 03 constructor reroute
			7F01AF84	menu 04 constructor reroute
			7F01AF94	menu 05 constructor reroute
			7F01AFA4	menu 06 constructor reroute
			7F01AFB4	menu 07 constructor reroute
			7F01AFC4	menu 08 constructor reroute
			7F01AFD4	menu 09 constructor reroute
			7F01AFE4	menu 0A constructor reroute
			7F01AFF4	menu 0C constructor reroute
			7F01B004	menu 0D constructor reroute
			7F01B014	menu 0E constructor reroute
			7F01B024	menu 13 constructor reroute
			7F01B034	menu 0F constructor reroute
			7F01B044	menu 14 constructor reroute
			7F01B054	menu 10 constructor reroute
			7F01B064	menu 11 constructor reroute
			7F01B074	menu 12 constructor reroute
			7F01B084	menu 15 constructor reroute
			7F01B094	menu 16 constructor reroute
			7F01B0A4	menu 18 constructor reroute
			7F01B0B4	menu 19 constructor reroute
			7F01B0C0	menu 0B - no reroute
	4FC04	7F01B0D4
		fill
		7F01B0E0
		7F01B134
		7F01B1C8
		7F01B240
		7F01B6E0
	50608	7F01BAD8
		fill
		7F01BAE0
		7F01BFF8
 50B30:	7F01C000
	50C00	7F01C0D0	insert image DL, stats at 800232A8
		7F01C1A4
		7F01C284	V0=state of bleeding animation, ???, probably sets red screen animation	uses data at 8002BB30
		accepts: A0=start(0) or stop(1) animation
		7F01C400
		accepts: A0=p->display list
		7F01C670
		7F01CA18
	51610	7F01CAE0	decrypts red bleeding animation binaries
		accepts: A0=p->source, A1=width, A2=height, A3=p->target, SP+10=p->address for base offset value
		7F01CC94
		7F01CCEC
		7F01CEEC
		7F01D02C
		7F01D16C
		7F01D1C0
		7F01D2B0	F0= reaction speed 007 modifier
		7F01D2E8	F0= health 007 modifier
		7F01D324	F0= damage 007 modifier
		7F01D360	F0= accuracy 007 modifier
		7F01D39C
		???
		probably saves current completion time to eeprom
	52030	7F01D500	uses current eeprom folder to set options at start of game; redirects to 7F01F030, A0=folder#
	52054	7F01D524	redirects to 7F01F184, A0=folder#
	52078	7F01D548	redirects to 7F01F29C, A0=folder#; possibly copies working copy to permanent
	5209C	7F01D56C	[beta] would have ret. V0=bond for cur. folder; now A0=folder#
		redirects to 7F01EBC0, A0=folder#
	520C0	7F01D590	A0-> folder# (8002A8E8); fries AT
	520CC	7F01D59C	A0-> difficulty (8002A8FC); fries AT,V0(difficulty)
		note: invalid difficulties are forced to 0 (agent)
	5211C	7F01D5EC	set stage A0, mode solo, p->briefing data (8002A8F8); fries AT,V0,V1,T6,T7,T8
	5214C	7F01D61C	V0= p->eeprom file	redirects to 7F01F394, A0=folder#
	52174	7F01D644
		???	copies folder# to 8002A8EC, sets current to 64, redirects to 7F01F45C
		loads eeprom file to temporary buffer, for demos especially
	521B0	7F01D680	sets favored items for cur.player; fries V0,V1,T6,T7,T8,T9
		writes values to appropriate 800696F0 register
		accepts: A0=right item, A1=left item
	521F0	7F01D6C0	redirect to 7000C6FC
		7F01D6E0
		7F01D758
		7F01D7A0
		7F01D840
	
	523F8	7F01D8C8	V0= eeprom A0's folder# [eeprom+8's & 0x7]; fries T6
		accepts: A0=p->eeprom folder
	52408	7F01D8D8	set eeprom A0's folder# to A1 [eeprom+8's & 0x07]; fries T0,T6,T8,T9
		accepts: A0=p->eeprom folder, A1=value (0-7)
	52424	7F01D8F4	V0= eeprom+8's & 0x18 value (0-3); fries T6
		accepts: A0=p->eeprom folder
	52434	7F01D904	reset eeprom+8's & 0x18 value to A1; fries T0,T1,T6,T8,T9
		accepts: A0=p->eeprom folder, A1=value (0-3)
	52454	7F01D924	V0= selected Bond [eeprom+8's & 0x60]; fries T6
		accepts: A0=p->eeprom folder
	52464	7F01D934	set selected Bond to A1 [eeprom+8's & 0x60]; fries T0,T1,T6,T8,T9
		accepts: A0=p->eeprom folder, A1=value (0-3)
	52484	7F01D954	V0= TRUE if eeprom+8's & 0x80 flag set (0<[A0+8]&0x80); fries T6
		accepts: A0=p->eeprom folder
	52494	7F01D964	A1 sets (1) or unsets (0) & 0x80 flag in eeprom+8; fries T6,T7,T8,T9
		accepts: A0=p->eeprom folder, A1=mode (0-unset:1-set)
	524C0	7F01D990	V0= completion time for stage A1 on difficulty A2
		accepts: A0=p->eeprom folder, A1=stage#(0-13), A2=difficulty(0-3)
		fries: AT,V0,V1,A0,A3,T0
	52614	7F01DAE4
		???
		accepts: A0=, A1=solo stage#, A2=difficulty, A3=time
		7F01DC20
	52790	7F01DC60	V0= TRUE if stage A1 completed on difficulty A2
		accepts: A0=p->eeprom folder, A1=stage#(0-13), A2=difficulty(0-3)
	527E0	7F01DCB0
		???
		accepts: A0=, A1=solo stage#, A2=difficulty, A3=max completion time
	52850	7F01DD20	V0= TRUE if cheat A1 in eeprom folder A0 is unlocked
		7F01DD74
		
	528F4	7F01DDC4	V0= p->eeprom folder A0; fries AT,V0,A0,T6
		7F01DE50
		7F01DEB4
		7F01DF90
 52B30:	7F01E000
	52DBC	7F01E28C	V0= TRUE if A0 is a valid folder number (0-3 or 64)
	52DF0	7F01E2C0	V0= TRUE if stage A1 complete on difficulty A2 in eeprom folder A0
			returns 1 if this was the highest difficulty unlocked
			returns 3 if this was the highest difficulty completed
	53034	7F01E504
	53128	7F01E5F8
		??? - unlock stage A1 in folder A0 on difficulty A2
		accepts: A0=folder#, A1=solo stage#, A2=difficulty(?), A3=???
		7F01E760
		??? - probably sets current completion time for stage A1 in folder A0
		accepts: A0=folder#, A1=solo stage#
	533A4	7F01E874	returns the highest stage and difficulty completed for eeprom folder A0
		accepts: A0=eeprom folder#, A1=p->ret. stage#, A2=p->ret. difficulty
	53444	7F01E914	V0= TRUE if Egypt completed in eeprom folder A0 on any difficulty
	534C8	7F01E998	V0= TRUE if Egypt completed on any difficulty in any folder
	53524	7F01E9F4	V0= TRUE if Cradle completed in eeprom folder A0 on any difficulty
	5358C	7F01EA5C	V0= TRUE if Aztec completed in eeprom folder A0 on secret or 00 agent
	535D8	7F01EAA8	V0= TRUE if Egypt completed in eeprom folder A0 on 00 agent
	53600	7F01EAD0	V0= TRUE if Cradle completed on any difficulty in any folder
	53650	7F01EB20	V0= TRUE if Aztec completed on secret or 00 agent in any folder
	536A0	7F01EB70	V0= TRUE if Egypt completed on 00 agent in any folder
	536F0	7F01EBC0	[beta] V0=selected Bond for folder A0
		A0->SP+0, V0=0
	536FC	7F01EBCC	set selected bond for folder A0 to 0 (Brosnan); fries AT,T6
		[beta] set selected Bond to A1 for folder A0 (table at 8002C510)
		0->entry A0 (0-3) in table at 8002C510, A1->SP+4
	53724	7F01EBF4
		???	A0->SP+0
	5372C	7F01EBFC
		???	A0->SP+0
	53734	7F01EC04	delete eeprom folder# A0
		7F01ED10
		
	53A40	7F01EF10	updates eeprom controller config & options flags with current solo watch settings
		accepts: A0=p->eeprom file
	53B60	7F01F030
		???	copies volume, screen+ratio settings at start of MP game from eeprom folder A0...
	53CB4	7F01F184
		???	either deletes or updates eeprom file A0
	53DCC	7F01F29C	update eeprom: copy eeprom file A0 or eeprom @ 8002C840 to stack, sets folder number
		[beta] - selected Bond doesn't match the 0x60 value, set it to the selected Bond
	53EC4	7F01F394	copy eeprom file A0's data to A1, or if invalid file# copy a blank file 
		A0=folder#, A1=p->target eeprom data
	53F8C	7F01F45C	copy eeprom file A0's data from A1 to buffer (80069B00)
		A0=folder#, A1=p->target eeprom data
	53FD0	7F01F4A0	V0=TRUE if 007 mode unlocked: 007 flag set in eeprom folder A0 or all 00 stages complete
	54060	7F01F530	V0= # guards [8002CC68]
	5406C	7F01F53C	V0=p->allocated block for A0 vertices; fries V0,A2,T6,T7,T8
		redirect to 7F0BD714: A0<<4
	5408C	7F01F55C	A0->show patrols debug flag [8002CC5C]; fry AT
	54098	7F01F568	V0=show patrols debug flag [8002CC5C]
	540A4	7F01F574
	54118	7F01F5E8
		set or unset GUARDdata+12 0100 flag; fries: T6,T7,T8,T9
		accepts: A0=p->GUARDdata, A1=mode (0=set,1=unset)
		7F01F614
		
		7F01FC10
		
	54AF0	7F01FFC0	returns V0=next available guard ID#; fries AT,A0,A1,A2,V0,V1,T6
 54B30:	7F020000
	54B48	7F020018
	54BEC	7F0200BC	initializes GUARDdata using set values
		accepts: A0=p->pos.data (8006), A1=p->GUARDdata, A2=p->(float)xyz position, A3=(float) rotation(?), SP+10=p->tile, SP+14=p->action block or NULL
	54EE8	7F0203B8	append (and replace) newly-initialized GUARDdata entry using set values
		accepts: A0=p->GUARDdata, A1=p->(float)xyz position, A2=(float) rotation, A3=p->tile, SP+10=p->action block or NULL
		calls 7F0200BC if 7F03A430 successfully generates an entry
	54F44	7F020414	???; disables sounds attached to player, then something else
		accepts: A0=p->BONDdata.pos.data
	55070	7F020540	F12->animation speed.  sets to loaded guards as well
	55114	7F0205E4	F0= animation speed [8002C900]; fry AT
		7F0205F0
		
	56650	7F021B20
		???
		A0=p->GUARDdata
		7F021BB4

 56B30:	7F022000
 
 
		7F022E1C
		7F022E24
 
	57AF8	7F022FC8	V0= p->GUARDdata if guard# A0 is loaded; fries AT,V1,A0,A1,A2,A3,T6,T7
	57B5C	7F02302C	V0= p->position data of item in hand A1 (0-R,1-L) listed at p->GUARDdata A0; fries T6,T7
	57B6C	7F02303C	V0= TRUE if a weapon is in hand A1 (0-R,1-L) of p->GUARDdata A0; fries V1,A0,A1,T6,T7
		if item's 'gadget' attribute set, will return FALSE
		7F02308C
	
	57DC0	7F023290	load body/head entry A0 if not already loaded
	57E18	7F0232E8
		loads models for guards?  returns V0= pointer to model stuff
		if SP+14 not set, calls 7F06C23C
		accepts: A0=body, A1=head, A2=p->body header, A3=p->head header, SP+10=TRUE if sunglasses set, SP+14=p->???
	57FD8	7F0234A8
		redirect to 7F0232E8: SP+14=0
		accepts: A0=body, A1=head, A2=p->body header, A3=p->head header, SP+10=TRUE if sunglasses set
	58000	7F0234D0	retrieves header info for body and head; calls 7F0234A8
		accepts: A0=body, A1=head, A2=bitflags
	580C0	7F023590	returns V0=current random body; fries T6,T7
	580DC	7F0235AC	solo select pseudorandom heads (4 male, 1 female); fries 
	58190	7F023660	V0=random head
	5823C	7F02370C	expand 09 characters; A1=pointer to 09 command
		
	58440	7F023910	V0= TRUE if item is held like a pistol
		A0=p->item's position data (8006)
		7F023948
		7F023A94
		7F023B5C
		7F023BC0
		7F023C54
		7F023CB8
		7F023E14
	58978	7F023E48
		??? - redirects to 7F023CB8, sets A0+40 = 1
		7F023E74
	58B14	7F023FE4	actor at A0 performs animation A1
		accepts: A0=p->GUARDdata, A1=animation, A2=run length?, A3=start point?, SP+10=action type, SP+14=[data+8]		
 58B30:	7F024000
	58C80	7F024150
	58D68	7F024238	Throw weapon in guard's hand
		accepts: A0=p->GUARDdata, A1=p->weapon's pos.data (8006), A2=hand (R-0:L-1), A3=1 if using a temp object
		
	58F48	7F024418	actor (A0=p->GUARDdata) shuffles feet
		
	59078	7F024548	actor (A0=p->GUARDdata) looks around flustered
		
	59178	7F024648	actor (A0=p->GUARDdata) throws away weapons and surrenders
	592E8	7F0247B8	actor (A0=p->GUARDdata) fades away
		7F024800
		
	59828	7F024CF8
		???
		accepts: A0=p->GUARDdata, A1=p->???
		
	59ABC	7F024F8C
		???; accepts: A0=p->GUARDdata
		7F02516C
		
	5A090	7F025560
		???
		accepts: A0=p->GUARDdata, A1=, A2=
		
	5A220	7F0256F0
		???
		accepts: A0=p->GUARDdata, A1=???, A2=target actor ID
		
	5A3AC	7F02587C
		accepts: A0=p->GUARDdata, A1=[0-walk, 1-run]
		
 5AB30:	7F026000
	
	5B038	7F026508
		??? - triggered when shot/hit somebody
		accepts: A0=p->Player's GUARDdata, A1=???, A2=???, A3=???, SP+10=???
		7F026F30
		
	5BB90	7F027060	play sound for shot actor
		accepts: A0=p->GUARDdata
	5BDAC	7F02727C	handles shot actors
		increases player shot record, handling hat hits
		set guard shot and action registers in response
		accepts: A0=p->GUARDdata, A1=body part shot, A2=???, A3=???, SP+10
		7F027804
	5C6F4	7F027BF4	V0= p->preset in path preset table matching p->tile [A0]; fries V0,V1,A0,A1,A2,A3,T6,T7,T8
		used in search routines.  Preset's tile pointer should match tile pointer A0
	5C760	7F027C60	V0= TRUE if any path preset lies on tile A0; fries V1,A0,A1,A2,A3,T6,T7,T8
		accepts: A0=p->tile
		7F027C84
		
		7F027CD4
 
		7F027E70
		
		7F027E90
 
 5CB30:	7F028000
		
		7F028474
		
		7F028494
		
	5D58C	7F028A5C
		???, sound effect related
		accepts: A0=p->GUARDdata, A1=distance, A2=gender
	5D8D0	7F028DA0	play SE for hit actor at appropriate volume
		accepts: A0=p->GUARDdata
		calls 7F028A5C: A0=p->GUARDdata, A1=distance (GUARDdata+59), A2=gender
	5D90C	7F028DDC	plot course for actor @ A0 to position A1 in room A2 at speed A3
		accepts: A0=p->GUARDdata, A1=p->[float]xyz positions, A2=p->tile, A3=speed (0-walk, 1-jog, 2-run)
		7F028FAC
		
	5DC28	7F0290F8	set actor on path
		accepts: A0=p->GUARDdata, A1=p->path
	5DDC8	7F029298	GUARDdata cur.timer= cur.timer [A0+0xE8= 8004837C]; fries T6
		7F0292A8
		7F0294BC
		
	5E100	7F0295D0	V0= TRUE if actor in same room as position
		accepts: A0=p->GUARDdata, A1=p->(float) xyz position, A2=p->tile
		
	5E78C	7F029C5C	V0= TRUE if actor A0 not moving
		accepts: A0=p->GUARDdata
		7F029D70
 
 5EB30:	7F02A000
		
	5EC1C	7F02A0EC
		???
		accepts: A0=p->GUARDdata, A1=???, A2=[float] ???
 
	5ED88	7F02A258	V0= TRUE if actor is dying, fading, limping, or shot
		accepts: A0=p->GUARDdata
	5EDD4	7F02A2A4	V0= TRUE if actor dying or fading away; fries V1
		accepts: A0=p->GUARDdata
	5EDF8	7F02A2C8	actor steps sideways
		accepts: A0=p->GUARDdata		
	5EF58	7F02A428	actor hop sideways
		accepts: A0=p->GUARDdata
	5F0B8	7F02A588	actor runs sideways
		accepts: A0=p->GUARDdata
	5F234	7F02A704	actor walks while firing
		accepts: A0=p->GUARDdata
	5F328	7F02A7F8	actor runs while firing
		accepts: A0=p->GUARDdata
	5F41C	7F02A8EC	actor rolls, fires crouched
		accepts: A0=p->GUARDdata
	5F54C	7F02AA1C	if actor is not dead or injured and has a weapon, aim at actor ID A2
		accepts: A0=p->GUARDdata, A1=???, A2=target actor ID
	5F5B8	7F02AA88	if actor is not dead or injured and has a weapon, kneel and aim at actor ID A2
		accepts: A0=p->GUARDdata, A1=???, A2=target actor ID
	5F624	7F02AAF4
		???
		skips if anim!=firing standing still (8)
		A1->GUARDdata+0x4C, A2->GUARDdata+0x50
	5F674	7F02AB44	TRUE if actor set to stand still, sets if possible
		if standing still, returns TRUE
		accepts: A0=p->GUARDdata, A1=???, A2=target actor ID
	5F6E4	7F02ABB4	actor moves to preset A1 at speed A2
		accepts: A0=p->GUARDdata, A1=preset, A2=speed (0-walk, 1-jog, 2-run)
		
	5F884	7F02AD54	V0= TRUE on success; if actor is not dead or injured and has a weapon, set actor on path
		accepts: A0=p->GUARDdata, A1=p->path
		7F02AD98
		
	602A4	7F02B774	manage guard fade on death; time=1.5 sec/5A ticks
		
 60B30:	7F02C000
 
	61CB4	7F02D184
		???; accepts: A0=p->GUARDdata, A1=[float] ???
 
		7F02D244
		
 
 62B30:	7F02E000
 64B30:	7F030000
 66B30:	7F032000
 
	67698	7F032B68
		???; fries AT,T6,T7
		V0=TRUE if (counter at +0xD4 vs [8004837C]) < 600
		accepts: A0=p->GUARDdata
	676D0	7F032BA0
		???; fries AT,T6,T7
		V0=TRUE if (counter at +0xF0 vs [8004837C]) < 600
		accepts: A0=p->GUARDdata
	67708	7F032BD8	F0= distance between actor and position; 
		accepts: A0=p->GUARDdata, A1=p->xyz positions
	6777C	7F032C4C	F0= distance between actor and cur. player's position; 
		accepts: A0=p->GUARDdata
	677A8	7F032C78
		
	678A0	7F032D70	F0= angle between actor and cur.player; fries AT,V1,T6,F4,F6,F8,F10,F12,F14,F16
		accepts: A0=p->GUARDdata
		7F032DE4
		
	67A2C	7F032EFC	V0=TRUE if room containing preset A1 loaded
		accepts: A0=p->GUARDdata, A1=preset
	67AC4	7F032F94	V0 & A1= preset, retrieving guard 2328 preset if necessary; fries AT
		accepts: A0=p->GUARDdata, A1=preset
	67ADC	7F032FAC	V0=converted actor ID value; fries AT
		accepts A0=p->GUARDdata, A1=ID #
	67B70	7F033040	V0= handle to guard ID# A1
	67BF4	7F0330C4	F0= distance between current actor and actor ID# A1
		puts into account y as well as lateral distance
		accepts: A0=p->GUARDdata, A1=actor ID#
		
	67C84	7F033154	F0= distance b/w current player and preset
		accepts: A0=p->GUARDdata, A1=preset
	
		7F033260
		7F033290
		7F0332C0
	67E2C	7F0332FC	toggles bitflags A1 in objective flag register [80030978]; fries V0,T6,T7
		accepts: A0=[unused], A1=flags
	67E48	7F033318	untoggles bitflags A1 in objective flag register [80030978]; fries V0,T6,T7,T8
		accepts: A0=[unused], A1=flags
	67E68	7F033338	V0= TRUE if any of objective flags A1 set; fries T6,T7
		tests against word at 80030978
		accepts: A0=[unused], A1=flags
	67E84	7F033354	V0= TRUE if actor's 02 bitflag set [A0+0x12 & 2]; fries T6
	67E94	7F033364	V0= TRUE if animation triggered; if actor is not dead or injured, surrender
		accepts: A0=GUARDdata
	67ED0	7F0333A0	V0= TRUE; redirect to 7F0247B8
		accepts: A0=GUARDdata
	67EF4	7F0333C4	reset and start loop counter; fries T6,T7
		sets +0x110 = 0,  0x40 bitflag at +0x12
		accepts: A0=p->GUARDdata
	67F08	7F0333D8	F0=loop counter time in seconds; fries AT,T6,F4,F6,F8
		divides +0x110 by 60.0
		7F0333F8
	67FC0	7F033490	V0= TRUE if actor (A0=p->GUARDdata) is invisible (+0x14 & 4); fries T6
	67FD0	7F0334A0	actor moves to cur.player at speed A1
		accepts: A0=p->GUARDdata, A1=speed (0-walk, 1-jog, 2-run)
	6803C	7F03350C	actor moves to actor ID A1's position at speed A2
		accepts: A0=p->GUARDdata, A1=actor ID#, A2=speed (0-walk, 1-jog, 2-run)
	680D4	7F0335A4	V0= #times actor shot [A0+0xB]
	680DC	7F0335AC	V0= #shots near actor [A0+0xA]
	680E4	7F0335B4	V0= TRUE if actor's (A0=p->GUARDdata) FA target set; fries T6
	680F4	7F0335C4	V0= TRUE if actor's (A0=p->GUARDdata) FB target set; fries T6
		7F0335D4
	68140	7F033610
		TRUE if animation triggered; if actor is not dead or injured, shuffle feet
		accepts: A0=GUARDdata
		
	6817C	7F03364C	TRUE if animation triggered; if actor is not dead or injured, fawn on shoulder
		accepts: A0=GUARDdata
	681B8	7F033688	TRUE if animation triggered; if actor is not dead or injured, look around flustered
		accepts: A0=GUARDdata
	681F4	7F0336C4	TRUE if animation triggered; if actor is not dead or injured, kneel
		accepts: A0=GUARDdata
	68230	7F033700	TRUE if animation triggered; if actor is not dead or injured, perform animation A1
		redirects to 7F023FE4
		accepts: A0=GUARDdata, A1=animation, A2=[0A:3|4], A3=[0A:5|6], SP+10=action type, SP+14=[data+8]
	68290	7F033760	redirects to 7F055E50
		7F033780
		
	684C8	7F033998	V0= TRUE if 2328 preset set using method A1
		accepts: A0=p->GUARDdata, A1=method
			20	next step in path
			10	go to cur.player's position
			08	go to cur.player if within long range
			04	go to cur.player if within range
			02	go to cur.player if within mid range
			01	go to cur.player if within short range
	685DC	7F033AAC
		
		
	688F4	7F033DC4
		???
		accepts: A0=p->GUARDdata
		
	68A78	7F033F48	V0=unknown; linked in guard spawn; possibly accepts pad pointer
		accepts: A0=p->[SP+30], A1=p->[SP+28], A2=, A3=[TRUE if flag 0x10 set]
 68B30:	7F034000
	68C8C	7F03415C	the action block guard constructor used by BD/BE
		accepts: A0=body, A1=head, A2=p->preset, A3=p->pad, SP+10=(float)???, SP+14=p->action, SP+18=bitflags
		returns: V0=p->guard or NULL
	68D88	7F034258	guard constructor called immediately by BD action type
		accepts: A0=p->GUARDdata, A1=body, A2=head, A3=preset, SP+10=p->action, SP+14=bitflags
	68E38	7F034308	guard constructor called immediately by BE action type
		accepts: A0=p->GUARDdata, A1=body, A2=head, A3=preset, SP+10=p->action, SP+14=bitflags
	68EB8	7F034388	V0= TRUE if actor ID# A1 is at preset A2
		accepts: A0=p->GUARDdata, A1=actor ID, A2=preset
	68F7C	7F03444C	V0= TRUE if actor is at preset A1
		accepts: A0=p->GUARDdata, A1=preset
	6902C	7F0344FC	V0= FALSE; removed actor animation routine [action 27]
	69038	7F034508	V0= FALSE; removed actor animation routine [action 2B]
	69044	7F034514
		
		
	690AC	7F03457C	actor (A0=p->GUARDdata) draws and throws a grenade at cur.player if possible
	6922C	7F0346FC	actor (A0=p->GUARDdata) drops item type A2 on ground, setting timer to A1
		
	692D0	7F0347A0	sets sound effect source to location
		accepts: A0=slot# (0-8);
		expects 80069B60 slot to contain sound information:
			0x0	4	p->SE data
			0x4	4	volume	(default 7FFF)
			0x8	4	audibile range
			0xC	4	maximum volume	(default 7FFF)
			0x10	4	p->preset or NULL
			0x14	4	p->object or NULL
	69414	7F0348E4	loops 7F0347A0 for slots 0-8
	69454	7F034924	set sound effect A1 to slot A0; calls 70008E08
		7F0349BC
	6952C	7F0349FC	V0= length of action block command at offset A1 in block A0
		accepts: A0=p->start of block, A1=current position offset
			7F034A24	action 00 length
			7F034A2C	action 01 length
			7F034A34	action 02 length
			7F034A3C	action 03 length
			7F034A44	action 04 length
			7F034A4C	action 05 length
			7F034A54	action 06 length
			7F034A5C	action 07 length
			7F034A64	action 08 length
			7F034A6C	action 09 length
			7F034A74	action 0A length
			7F034A7C	action 0B length
			7F034A84	action 0C length
			7F034A8C	action 0D length
			7F034A94	action 0E length
			7F034A9C	action 0F length
			7F034AA4	action 10 length
			7F034AAC	action 11 length
			7F034AB4	action 12 length
			7F034ABC	action 13 length
			7F034AC4	action 14 length
			7F034ACC	action 15 length
			7F034AD4	action E8 length
			7F034ADC	action E7 length
			7F034AE4	action 16 length
			7F034AEC	action 17 length
			7F034AF4	action 18 length
			7F034AFC	action 19 length
			7F034B04	action 1A length
			7F034B0C	action 1B length
			7F034B14	action 1C length
			7F034B1C	action 1D length
			7F034B24	action 1E length
			7F034B2C	action 1F length
			7F034B34	action 20 length
			7F034B3C	action 21 length
			7F034B44	action 22 length
			7F034B4C	action 23 length
			7F034B54	action 24 length
			7F034B5C	action 25 length
			7F034B64	action 26 length
			7F034B6C	action 27 length
			7F034B74	action 28 length
			7F034B7C	action 29 length
			7F034B84	action 2A length
			7F034B8C	action 2B length
			7F034B94	action 2C length
			7F034B9C	action 2D length
			7F034BA4	action 2E length
			7F034BAC	action 2F length
			7F034BB4	action 30 length
			7F034BBC	action 31 length
			7F034BC4	action 32 length
			7F034BCC	action 33 length
			7F034BD4	action 34 length
			7F034BDC	action 35 length
			7F034BE4	action 36 length
			7F034BEC	action 37 length
			7F034BF4	action 38 length
			7F034BFC	action 39 length
			7F034C04	action 3A length
			7F034C0C	action 3B length
			7F034C14	action 3C length
			7F034C1C	action 3D length
			7F034C24	action 3E length
			7F034C2C	action 3F length
			7F034C34	action 40 length
			7F034C3C	action 41 length
			7F034C44	action 42 length
			7F034C4C	action 43 length
			7F034C54	action 44 length
			7F034C5C	action 45 length
			7F034C64	action 46 length
			7F034C6C	action 47 length
			7F034C74	action 48 length
			7F034C7C	action 49 length
			7F034C84	action 4A length
			7F034C8C	action 4B length
			7F034C94	action 4C length
			7F034C9C	action 4D length
			7F034CA4	action 4E length
			7F034CAC	action 4F length
			7F034CB4	action 50 length
			7F034CBC	action 51 length
			7F034CC4	action 52 length
			7F034CCC	action 53 length
			7F034CD4	action 54 length
			7F034CDC	action 55 length
			7F034CE4	action 56 length
			7F034CEC	action 57 length
			7F034CF4	action 58 length
			7F034CFC	action 59 length
			7F034D04	action 5A length
			7F034D0C	action 5B length
			7F034D14	action 5C length
			7F034D1C	action 5D length
			7F034D24	action 5E length
			7F034D2C	action 5F length
			7F034D34	action 60 length
			7F034D3C	action 61 length
			7F034D44	action 62 length
			7F034D4C	action 63 length
			7F034D54	action 64 length
			7F034D5C	action 65 length
			7F034D64	action 66 length
			7F034D6C	action 67 length
			7F034D74	action 68 length
			7F034D7C	action 69 length
			7F034D84	action 6A length
			7F034D8C	action 6B length
			7F034D94	action 6C length
			7F034D9C	action 6D length
			7F034DA4	action 6E length
			7F034DAC	action 6F length
			7F034DB4	action 70 length
			7F034DBC	action 71 length
			7F034DC4	action 72 length
			7F034DCC	action 73 length
			7F034DD4	action 74 length
			7F034DDC	action 75 length
			7F034DE4	action 76 length
			7F034DEC	action 77 length
			7F034DF4	action 78 length
			7F034DFC	action 79 length
			7F034E04	action 7A length
			7F034E0C	action 7B length
			7F034E14	action 7C length
			7F034E1C	action 7D length
			7F034E24	action 7E length
			7F034E2C	action 7F length
			7F034E34	action 80 length
			7F034E3C	action 81 length
			7F034E44	action 82 length
			7F034E4C	action 83 length
			7F034E54	action 84 length
			7F034E5C	action 85 length
			7F034E64	action 86 length
			7F034E6C	action 87 length
			7F034E74	action 88 length
			7F034E7C	action 89 length
			7F034E84	action 8A length
			7F034E8C	action 8B length
			7F034E94	action 8C length
			7F034E9C	action 8D length
			7F034EA4	action 8E length
			7F034EAC	action 8F length
			7F034EB4	action 90 length
			7F034EBC	action 91 length
			7F034EC4	action 92 length
			7F034ECC	action 93 length
			7F034ED4	action 94 length
			7F034EDC	action 95 length
			7F034EE4	action 96 length
			7F034EEC	action 97 length
			7F034EF4	action 98 length
			7F034EFC	action 99 length
			7F034F04	action 9A length
			7F034F0C	action 9B length
			7F034F14	action 9C length
			7F034F1C	action 9D length
			7F034F24	action 9E length
			7F034F2C	action 9F length
			7F034F34	action A0 length
			7F034F3C	action A1 length
			7F034F44	action A2 length
			7F034F4C	action A3 length
			7F034F54	action A4 length
			7F034F5C	action A5 length
			7F034F64	action A6 length
			7F034F6C	action A7 length
			7F034F74	action A8 length
			7F034F7C	action A9 length
			7F034F84	action AA length
			7F034F8C	action AB length
			7F034F94	action AC length
			7F034F9C	action AE length
			7F034FA4	action AF length
			7F034FAC	action B0 length
			7F034FB4	action B1 length
			7F034FBC	action B2 length
			7F034FC4	action B3 length
			7F034FCC	action B4 length
			7F034FD4	action B5 length
			7F034FDC	action B6 length
			7F034FE4	action B7 length
			7F034FEC	action B8 length
			7F034FF4	action B9 length
			7F034FFC	action BA length
			7F035004	action BB length
			7F03500C	action BC length
			7F035014	action BD length
			7F03501C	action BE length
			7F035024	action BF length
			7F03502C	action C0 length
			7F035034	action C1 length
			7F03503C	action C2 length
			7F035044	action C3 length
			7F03504C	action C4 length
			7F035054	action C5 length
			7F03505C	action C6 length
			7F035064	action C7 length
			7F03506C	action C8 length
			7F035074	action C9 length
			7F03507C	action CA length
			7F035084	action CB length
			7F03508C	action CC length
			7F035094	action CD length
			7F03509C	action CE length
			7F0350A4	action CF length
			7F0350AC	action D0 length
			7F0350B4	action D1 length
			7F0350BC	action D2 length
			7F0350C4	action D3 length
			7F0350CC	action D4 length
			7F0350D4	action D5 length
			7F0350DC	action D6 length
			7F0350E4	action D7 length
			7F0350EC	action D8 length
			7F0350F4	action D9 length
			7F0350FC	action DA length
			7F035104	action DB length
			7F03510C	action DC length
			7F035114	action DD length
			7F03511C	action DE length
			7F035124	action DF length
			7F03512C	action E0 length
			7F035134	action E1 length
			7F03513C	action E2 length
			7F035144	action E3 length
			7F03514C	action E4 length
			7F035154	action E5 length
			7F03515C	action E6 length
			7F035164	action E9 length
			7F03516C	action EA length
			7F035174	action EB length
			7F03517C	action EC length
			7F035184	action ED length
			7F03518C	action EE length
			7F035194	action EF length
			7F03519C	action F0 length
			7F0351A4	action F1 length
			7F0351AC	action F2 length
			7F0351B4	action F3 length
			7F0351BC	action F4 length
			7F0351C4	action F5 length
			7F0351CC	action F6 length
			7F0351D4	action F7 length
			7F0351DC	action F8 length
			7F0351E4	action F9 length
			7F0351EC	action FA length
			7F0351F4	action FB length
			7F0351FC	action FC length
			7F035204	action AD length
			7F035238	invalid types (type>FD)
	69D74	7F035244
		???
	69E20	7F0352F0	V0= TRUE if successfully performing action [?]
		accepts: A0=???, A1=???, A2=???
		7F035398
		
	69F64	7F035434	V0= p->path #A0; fries V1,A1,T6,T7,T8,T9
	69FB4	7F035484	parses and handles action blocks, command by command
			7F0355B4	action 00 Return Value Loop [2]
			7F0355D0	action 01 Go To Beginning, Then Return Value Loop [2]
			7F0355EC	action 02 Resume If Return Value Loop Met [2]
			7F0355F8	action 03 Sleep For One Tick [1]
			7F03563C	action 05 Jump To Function [4]
			7F0356B0	action 06 Set Return Subroutine (for 0007 Command) [3]
			7F03570C	action 07 Jump to Return Subroutine [1]
			7F035768	action 08 Reset Animation [1]
			7F03577C	action 09 Guard Kneels [1]
			7F035790	action 0A Play Animation [9]
			7F03589C	action 0B If Guard Wasting Time (Swatting Flies), Return Value Loop [2]
			7F0358D0	action 0C Guard Points [1]
			7F0358E4	action 0D Guard Looks Around When Shot At [1]
			7F0358F8	action 2F If Guard Stopped Moving, Return Value Loop [2]
			7F03592C	action 30 If Guard Killed, Return Value Loop [3]
			7F035974	action 31 If Guard ID Finished Death Animation, Return Value Loop [3]
			7F0359B4	action 32 If Guard Has Spotted Bond, Return Value Loop [2]
			7F0359E8	action 0E Guard Steps Sideways, Return Value Loop [2]
			7F035A1C	action 0F Guard Hops Sideways, Return Value Loop [2]
			7F035A50	action 10 Guard Runs Sideways, Return Value Loop [2]
			7F035A84	action 11 Guard Walks Firing, Return Value Loop [2]
			7F035AB8	action 12 Guard Runs Firing, Return Value Loop [2]
			7F035AEC	action 13 Guard Rolls On Ground Then Fires Crouched, Return Value Loop [2]
			7F035B20	action 14 Guard Aims, Shoots at Bond/Guard/Pad, Return Value Loop [6]
			7F035B74	action 15 Guard Kneels/Aims, Shoots at Bond/Guard/Pad, Return Value Loop [6]
			7F035BC8	action E7 If Guard Moving And Shooting, Return Value Loop [2]
			7F035C1C	action E8 If Guard Is Shooting, Return Value Loop [2]
			7F035C50	action 16 Guard Shoots Guards (Without Animation Change), Return Value Loop [6]
			7F035CA4	action 17 Guard Constantly Angles To Face, Return Value Loop [6]
			7F035CF8	action 18 Shoot Guard ID In Style With Weapon Type # [4]
			7F035D5C	action 19 Guard ID1 Shoots Guard ID2 In Style [4]
		6A9A8	7F035E78	action 1A Guard Throws Grenade, Return Value Loop [2]
			7F035EAC	action 1B Drop Weapon Inventory #, Return Value Loop [5]
			7F035EF8	action 21 Guard Surrenders, Drops All Attached Objects [1]
			7F035F0C	action 22 Guard Set To Move Fades And Disappear [1]
			7F035F20	action 23 Remove Guard ID [2]
			7F035F54	action 24 Activate Object At Preset, Return Value Loop If Successful [4]
			7F035F9C	action 25 Activate Alarm [1]
			7F035FB0	action 26 Deactivate Alarm [1]
			7F035FC4	action 27 Invalid Type (Return False) [2]
			7F035FF8	action 28 Jog To Bond, Return Value Loop When Reached Bond [2]
 6AB30:	7F036000
			7F036030	action 29 Walk To Bond, Return Value Loop When Reached Bond [2]
			7F036068	action 2A Run To Bond, Return Value Loop When Reached Bond [2]
			7F0360A0	action 2B Invalid Type (Return False) [2]
			7F0360D4	action 2C Jog To Character Position, Return Value Loop On Arrival [3]
			7F036110	action 2D Walk To Character Position, Return Value Loop On Arrival [3]
			7F03614C	action 2E Run To Character Position, Return Value Loop On Arrival [3]
			7F036188	action 33 Seed Random Byte [1]
			7F0361A0	action 34 If Random Byte < Value, Return Value Loop [3]
			7F0361DC	action 35 If Random Byte > Value, Return Value Loop [3]
			7F036218	action 1C Guard Jogs To Preset [3]
			7F036244	action 1D Guard Jogs To Predefined Preset (2328) [1]
			7F036260	action 1E Guard Walks To Preset [3]
			7F03628C	action 1F Guard Runs  To Preset [3]
			7F0362B8	action 20 Activate Patrol Path [2]
			7F0362D8	action 36 If Alarm Activated, Return Value Loop (Plus Stack) [2]
			7F03630C	action 37 If Alarm Activated, Return Value Loop [2]
			7F036340	action 38 If Toxic Gas Released, Return Value Loop [2]
			7F036374	action 39 If Guard Heard Gunfire, Return Value Loop [2]
			7F0363A8	action 3A If Another Guard Shot Within Sight Of Guard, Return Value Loop [2]
			7F0363DC	action 3B If Another Guard Killed Within Sight Of Guard, Return Value Loop [2]
			7F036410	action 3C If Guard And Bond Are Within Line Of Sight, Return Value Loop [2]
			7F036444	action 3D If Guard And Bond Are Within Partial Line Of Sight, Return Value Loop [2]
			7F036478	action 3E If Guard Has Been Shot Recently, Return Value Loop [2]
			7F0364AC	action 3F If Guard Heard Bond, Return Value Loop [2]
			7F0364E0	action 40 If Guard In Same Room As Guard ID, Return Value Loop [3]
			7F036540	action 41 If Guard Has Not Been On Screen Yet, Return Value Loop [2]
			7F036578	action 42 If Guard On Screen, Return Value Loop [2]
			7F0365B4	action 43 If Room Containing Guard On Screen, Return Value Loop [2]
			7F0365F4	action 44 If Room Containing Preset On Screen, Return Value Loop [4]
			7F03663C	action 45 If Bond Is Aiming At Guard, Return Value Loop [2]
			7F036670	action 46 If Bond Fired A Shot Near Guard, Return Value Loop [2]
			7F0366A4	action 47 If Guard's Counter-Clockwise Direction To Bond < X Degrees, Return Value Loop [3]
			7F036718	action 48 If Guard's Counter-Clockwise Direction To Bond > X Degrees, Return Value Loop [3]
			7F03678C	action 49 If Bond's Counter-Clockwise Direction To Guard < X Degrees, Return Value Loop [3]
			7F036800	action 4A If Bond's Counter-Clockwise Direction To Guard > X Degrees, Return Value Loop [3]
			7F036874	action 4B If Guard's Distance To Bond < X, Return Value Loop [4]
			7F0368DC	action 4C If Guard's Distance To Bond > X, Return Value Loop [4]
			7F036944	action 4D If Guard ID's Distance To Preset < X, Return Value Loop [7]
			7F0369D4	action 4E If Guard ID's Distance To Preset > X, Return Value Loop [7]
			7F036A64	action 4F If Guard's Distance To Guard ID < X, Return Value Loop [5]
			7F036AD0	action 50 If Guard's Distance To Guard ID > X, Return Value Loop [5]
			7F036B3C	action 51 If Guard's Distance To Another Guard < X, Set Guard's ID To FC And Return Value Loop [4]
			7F036B98	action 52 If Bond's Distance To Preset < X, Return Value Loop [6]
			7F036C10	action 53 If Bond's Distance To Preset > X, Return Value Loop [6]
			7F036C88	action 54 If Guard Is At Preset, Return Value Loop [5]
			7F036CD4	action 55 If Bond Entered Room with Preset, Return Value Loop [4]
			7F036D1C	action 56 If 16 Object # Collected, Return Value Loop [3]
			7F036D6C	action 57 If Weapon/Item Was Thrown, Return Value Loop [3]
			7F036DA0	action 58 If Weapon/Item Was Thrown Onto 16-Object, Return Value Loop [4]
			7F036E2C	action 59 If Bond Has Weapon/Item Equipped, Return Value Loop [3]
			7F036E78	action 5A If 16 Object # Loaded, Return Value Loop [3]
			7F036EBC	action 5B If 16 Object # Not Destroyed, Return Value Loop [3]
			7F036F0C	action 5C If 16 Object # Activated, Return Value Loop [3]
			7F036F70	action 5D If Gadget Used On 16 Object #, Return Value Loop [3]
			7F036FD0	action 5E Activate 16 Object [2]
			7F037038	action 5F Explode/Destroy 16 Object [2]
			7F0370B4	action 60 Guard Drops 16 Object # [2]
			7F037118	action 61 Kill Guard # [2]
			7F03714C	action 62 Guard # Drops Held Weapon/Item [2]
			7F0371BC	action 63 Guard Gives Bond 16 Object # [2]
			7F0371FC	action 64 Guard # Equips 16 Object [3]
			7F0372A0	action 65 Move 16 Object To Preset [4]
			7F0373BC	action 66 Open Door [2]
			7F037400	action 67 Close Door [2]
			7F037444	action 68 Check Door Status, Return Value Loop If Met [4]
			7F037518	action 69 If Door Has Been Opened Before, Return Value Loop [3]
			7F03757C	action 6A Set Door's Lock Bits [3]
			7F0375C0	action 6B Unset Door's Lock Bits [3]
			7F037608	action 6C If Door's Lock Bits Are Set, Return Value Loop [4]
			7F037678	action 6D If Objective # Complete, Return Value Loop [3]
			7F0376C8	action 6E If Guard 2328 Preset, Return Value Loop [3]
			7F037700	action 6F If Guard 2328 Preset Set, Return Value Loop [3]
			7F037738	action 78 If Guard Shot < Amount, Return Value Loop [3]
			7F037778	action 79 If Guard Shot > Amount, Return Value Loop [3]
			7F0377B8	action 7A If Number Near-Miss Gunshots < Value, Return Value Loop [3]
			7F0377F8	action 7B If Number Near-Miss Gunshots > Value, Return Value Loop [3]
			7F037838	action 7C If Guard Health < Value, Return Value Loop [4]
			7F0378C4	action 7D If Guard Health > Value, Return Value Loop [4]
			7F037950	action 7E If Guard #'s Bitflag 01000000 Set, Return Value Loop [3]
			7F0379AC	action 7F If Bond's Health < Value, Return Value Loop [3]
			7F037A20	action 80 If Bond's Health > Value, Return Value Loop [3]
			7F037A94	action 70 If Difficulty < Value, Return Value Loop [3]
			7F037AD4	action 71 If Difficulty > Value, Return Value Loop [3]
			7F037B14	action 72 If Time < Value, Return Value Loop [4]
			7F037B74	action 73 If Time > Value, Return Value Loop [4]
			7F037BD4	action 74 If Power On Time < Value, Return Value Loop [4]
			7F037C38	action 75 If Power On Time > Value, Return Value Loop [4]
			7F037C9C	action 76 If Stage Number < Value, Return Value Loop [3]
			7F037CDC	action 77 If Stage Number > Value, Return Value Loop [3]
			7F037D1C	action 81 Set User Byte #1 [2]
			7F037D30	action 82 Add Value To User Byte #1 (Max To FF) [2]
			7F037D70	action 83 Subtract Value To User Byte #1 (Min To 0) [2]
			7F037DA4	action 84 If User Byte #1 < Value, Return Value Loop [3]
			7F037DE0	action 85 If User Byte #1 < Random Value, Return Value Loop [2]
			7F037E1C	action 86 Set User Byte #2 [2]
			7F037E30	action 87 Add Value To User Byte #2 (Max To FF) [2]
			7F037E70	action 88 Subtract Value To User Byte #2 (Min To 0) [2]
			7F037EA4	action 89 If User Byte #2 < Value, Return Value Loop [3]
			7F037EE0	action 8A If User Byte #2 < Random Value, Return Value Loop [2]
			7F037F1C	action 8B Set Guard's Hearing Distance [3]
			7F037F50	action 8C Set Guard's Bond Reaction Time [2]
			7F037F80	action 8D Set Guard's Grenade Probability [2]
			7F037F94	action 8E Set Guard's ID [2]
			7F037FA8	action 8F Set Guard's Health [3]
			7F037FE8	action 90 Set Guard's Armor Amount [3]
 6CB30:	7F038000
			7F038028	action 91 Set Character Reaction Speed [2]
			7F03803C	action 92 Set Character Injury Recovery Speed [2]
			7F038050	action 93 Set Character Accuracy [2]
			7F038064	action 94 Mask Guard Type With Value [2]
			7F03807C	action 95 Unmask Guard Type With Value [2]
			7F038094	action 96 If Guard Type Value Is Set, Return Value Loop [3]
			7F0380CC	action 97 Mask Guard Type Flags With Value [3]
			7F0380E8	action 98 Unmask Guard Type Flags With Value [3]
			7F038104	action 99 If Guard Type Flags Set, Return Value Loop [4]
			7F038140	action 9A Set Objective Bits [5]
			7F03817C	action 9B Unset Objective Bits [5]
			7F0381B8	action 9C Check If Objective Bits Are Set, Return Loop If So [6]
			7F038214	action 9D Set Guard's Bits [5]
			7F038254	action 9E Unset Guard's Bits [5]
			7F038298	action 9F Check Guard's Bits, If Same Return Value Loop [6]
			7F0382F4	action A0 Set Guard ID's Bits [6]
			7F038344	action A1 Unset Guard ID's Bits [6]
			7F038398	action A2 Check Guard ID's Bits, If Same Return Value Loop [7]
			7F03840C	action A3 Set 16 Object's Bits [6]
			7F038464	action A4 Unset 16 Object's Bits [6]
			7F0384C0	action A5 If 16 Object's Bits Set, Return Value Loop [7]
			7F03853C	action A6 Set 16 Object's Bits More [6]
			7F038594	action A7 Unset 16 Object's Bits More [6]
			7F0385F0	action A8 If 16 Object's Bits More Set, Return Value Loop [7]
			7F03866C	action A9 Set Guard's FC To Guard ID [2]
			7F038684	action AA Set Guard ID's FC To Guard ID [3]
			7F0386A0	action AB Set Guard's 2328 Value To Preset [3]
			7F0386EC	action AC Set Guard ID #'S 2328 Value To Preset [4]
			7F038718	action AD Debug Comment [20]
			7F038730	action AE Reset And Start Cycle Counter [1]
			7F038744	action AF Reset Cycle Counter [1]
			7F038754	action B0 Stop Cycle Counter [1]
		6D29C	7F03876C	action B1 Start Cycle Counter  [1]
		6D2B4	7F038784	action B2 If Cycle Counter Stopped, Return Value Loop [2]
		6D2EC	7F0387BC	action B3 If Cycle Counter < Value, Return Value Loop [5]
			7F038840	action B4 If Cycle Counter > Value, Return Value Loop [5]
			7F0388C4	action B5 Show Timer [1]
			7F0388DC	action B6 Hide Timer [1]
			7F0388F4	action B7 Set Timer X Seconds [3]
			7F038928	action B8 Stop Timer [1]
			7F03893C	action B9 Start Timer [1]
			7F038950	action BA If Timer Stopped, Return Value Loop [2]
			7F038984	action BB If Timer < Value, Return Value Loop [4]
			7F0389E8	action BC If Timer > Value, Return Value Loop [4]
		6D57C	7F038A4C	action BD Spawn Guard [C]
		6D624	7F038AF4	action BE Respawn Guard with ID [B]
		6D6AC	7F038B7C	action BF Spawn Weapon [9]
		6D7B0	7F038C80	action C0 Spawn Hat [8]
			7F038D10	action C1 Guard ID Does Action Value If Heard A Lot Of Gunfire, Return Value Loop When Complete [5]
			7F038EC8	action C2 Display Text Preset Bottom Screen [3]
			7F038EF0	action C3 Display Text Preset Top Screen [3]
			7F038F18	action C4 Play Sound Effect # In Slot # (0-7) [4]
			7F038F44	action C9 Shut Off Sound In Slot Number [2]
			7F038F58	action C7 Sound In Slot # Crescendos To Volume Over Milliseconds [6]
			7F039008	action C8 Sound In Slot # Fades To Volume Over Milliseconds [6]
			7F0390C4	action C5 Emanate Sound In Slot # From 16 Object, With Audible Range Value [5]
			7F039160	action C6 Emanate Sound In Slot # From Preset, With Audible Range Value [6]
		6DD90	7F039260	action CA If Value > Volume (7FFF Max), Return Value Loop [5]
			7F0392D4	action CB Set Object Path (27 Type Object) [2]
			7F0392FC	action CC Set Speed Moving Vehicle (27 Type Object) [5]
			7F039360	action CD Set Speed Aircraft Rotor [5]
			7F0393BC	action CE If Currently In Intro Camera, Return Value Loop [2]
			7F039408	action CF If Currently In Intro Swirl, Return Value Loop [2]
			7F039440	action D0 Change Animation Type Of Tagged 16 Monitor [4]
		6DFFC	7F0394CC	action D1 If Bond Driving Tank, Return Value Loop [2]
		6E034	7F039504	action D2 Exit Level [1]
		6E080	7F039550	action D3 Return From Camera Scene [1]
		6E094	7F039564	action D4 Camera Looks At Bond From Preset [3]
		6E120	7F0395F0	action D5 Go To Camera Position [6]
			7F039670	action D6 If Bond Elevation < Value, Return Value Loop [4]
		6E20C	7F0396DC	action D7 Toggles Text and Controls (Variable) [2]
			7F039750	action D8 Enable All On-Screen Displays [1]
		6E2CC	7F03979C	action D9 Move Guard ID To Preset, Return Value Loop If Successful [5]
			7F039964	action DA Fade Out To Black [1]
			7F0399A4	action DB Fade In From Black (Reset DA) [1]
			7F0399E0	action DC When Fade Completes, Return Value Loop [2]
			7F039A24	action DD Hide All Guards [1]
			7F039A80	action DE Restore Hidden Guards [1]
			7F039AD4	action DF Open Door Instantly (Used Cut-Scenes) [2]
			7F039B30	action E0 Guard ID Draws Weapon # [3]
			7F039B58	action E1 If Number Of Players < Value, Return Value Loop [3]
			7F039B98	action E2 If Ammo Value In Type < Value, Return Value Loop [4]
		6E708	7F039BD8	action E3 Force Bond To Draw Weapon/Item (1st person) [2]
		6E72C	7F039BFC	action E4 Force Bond To Draw Weapon/Item (3rd person) [2]
		6E750	7F039C20	action E5 Set Bond's Speed [3]
		6E78C	7F039C5C	action E6 If 16-Object And Preset Are In Same Room, Return Value Loop [5]
		6E85C	7F039D2C	action E9 Instantly Switch Sky To Sky 2 [1]
		6E878	7F039D48	action EA Stop Game Time [1]
		6E89C	7F039D6C	action EB If Bond Has Been Killed, Return Value Loop [2]
		6E8D8	7F039DA8	action EC Disable Bond Damage/Pickups [1]
		6E8F0	7F039DC0	action ED Hide First Person Display [1]
		6E90C	7F039DDC	action EE Cuba Circular Camera Aim [D]
		6EA18	7F039EE8	action EF Trigger Credits [1]
		6EA30	7F039F00	action F0 If Credits Completed, Return Value Loop [2]
		6EA68	7F039F38	action F1 If All Objectives Complete, Return Value Loop [2]
		6EA9C	7F039F6C	action F2 Check Current Folder Bond, Return Value Loop [3]
		6EAD8	7F039FA8	action F3 If Bond Damage/Pickups Disabled, Return Value Loop [2]
		6EB10	7F039FE0	action F4 Plays Value #1-Theme Slot (0-3) For Value #2 Seconds [4]
 6EB30:	7F03A000
		6EB34	7F03A004	action F5 Turn Off Music In Slot # (0-3) [2]
		6EB50	7F03A020	action F6 Trigger Explosions Around Bond [1]
		6EB64	7F03A034	action F7 If Number Of Hostages/Scientists Killed > Value, Return Value Loop [3]
		6EBA4	7F03A074	action F8 If Guard ID 00200000 Flag Set, Unset And Return [3]
		6EC04	7F03A0D4	action F9 Set Killed In Action, Automatic Mission Failure [1]
		6EC1C	7F03A0EC	action FA Guard Raises Arms For Half A Second [1]
		6EC30	7F03A100	action FB Switch To Sky Value # And Activate Gas Containers If Exist [1]
		6EC64	7F03A134	action FC Launch Shuttle [2]
		6ED30	7F03A200	action 04 Terminate Block [1]
	6ED70	7F03A240
		???
	6EF34	7F03A404	set 0x4 state flag for position data at A0 [A0+1|=4]; fries T6,T7
	6EF44	7F03A414	untoggle 0x4 state flag for position data at A0 [A0+1|=4]; fries T6,T7
	6EF54	7F03A424	V0= current entry in obj.pos.data (8006 table) [80030AA0]
	6EF60	7F03A430	remove last obj.pos.data entry; fries V1,A1,T6,T7
		V0=p->new last entry (previous entry in table) or NULL
	6EFB4	7F03A484	set A0 as p->last obj.pos.data (8006 table); fries V0,T6
	6EFD4	7F03A4A4	A0->current obj.pos.data+0x28 (8006 table); fries V0,V1,T6
	6F020	7F03A4F0	A0->last obj.pos.data entry--first obj.pos.data+0x24; fries AT,V0,V1,T6
		7F03A538
		
	702E8	7F03B7B8	image hit call - second nibble
	704F0	7F03B9C0
	7091C	7F03BDEC
 70B30:	7F03C000
	70C20	7F03C0F0
		
	70DEC	7F03C2BC
		???
		accepts: A0=p->obj.position data (8006), A1=???
	70F2C	7F03C3FC
		
	71178	7F03C648
		???	handles respawn, as well as other things
	71560	7F03CA30
		??? - determines type of object, then determines target or player detection?
		7F03CA6C	3: guard
		7F03CA94	1,2,4: normal object, door, collectable
		7F03CAB0	7: 
		7F03CACC	8: 
		7F03CAE8	6: player
		???
		7F03CB00	5: 
		7F03CB10	3: 
		7F03CB30	default
	716BC	7F03CB8C
		
		7F03DA50
		7F03DB70
		7F03DBCC
		7F03DD9C
		7F03DE94
		accepts: A0=p->BONDdata.pos.data, A1=BONDdata+2A04
 72B30:	7F03E000
		7F03E134	???
		accepts: A0=p->obj.posdata
		7F03E18C	???
		accepts: A0=p->obj.posdata
		7F03E210
		7F03E27C
		7F03E3FC
		7F03E4F0
	731C8	7F03E698	unconditional return	debug "room blocks" feature
	731D0	7F03E6A0
		
	74574	7F03FA44	V0=p->object at preset A1 or NULL
		scans position data table for a normal object (01) at given preset
		accepts: A0=p->GUARDdata, A1=preset
		7F03FAB0
		
	747B0	7F03FC80
		
	748D8	7F03FDA8
		
	74AF0	7F03FFC0
		V0= (obj.data+0x70)/4+1 if the object is destroyed.  accepts A0=p->obj.data
		7F03FFF8
 74B30:	7F040000
		7F040074
		calls: 7F03FFF8: A0=(@(@A0+14)+8)
		7F0400C4
		7F0402B4
		accepts: A0=p->obj. position entry, A1=[p->obj+7C]
		7F040310
		7F040384
		7F040484
	7507C	7F04054C	initialize standard object A0
		accepts: A0=p->object, A1=p->object header, A2=p->positiona data or NULL, A3=p->instance controller or NULL
		If A2 or A3 are not present the data is generated.
	75228	7F0406F8	redirect to 7F04054C: A2=0, A3=0
		7F04071C	???; V0=p->new position entry
		7F040754
		7F0407F4
		7F04088C
		7F040BA0
		7F040CF0
		7F040D98
		7F041024	redirect to 7F040D98: A2=0
		7F041044
		if (A0+3)=4, F0=10.0 [41200000]; else, F0=20.0 [41A00000]; fries AT,T6
		7F041074
		7F041160
		7F041400
		7F0417DC
		7F0419E4
		7F041BB8
		7F041E0C
 76B30:	7F042000
 
		7F04224C
		??? - handles projectile motion
		7F042A0C
 
	786AC	7F043B7C	generates explosion of type A1 at object A0's position
		accepts: A0=p->std.obj pos.data, A1=type of explosion
	788A0	7F043D70	handles thrown explosive detonation
 78B30:	7F044000
		7F044200
 
	79E04	7F0452D4
		??? - object activation, or player interaction...
 7AB30:	7F046000
			7F04665C	obj 01: Doors
			7F0467A8	obj 06: Camera
			7F046C6C	obj 0D: Autoguns
			7F04756C	obj 27: Wheeled Vehicles
			7F047EC8	obj 28: Aircraft
 7CB30:	7F048000
			7F048244	obj 2F: Tinted Glass
			7F0482C8	obj 01: Doors
			7F0483B4	obj 2D: Tank
		7F049B58
		??? - 
	7E7BC	7F049C8C	save pointer to monitor ani code to obj ani slot; A1->A0, 0000->A0+4
	7E7C8	7F049C98	set pointer for A1 monitor img to obj ani slot at A0
		followed by subroutines that set pointers
	7EA70	7F049F40	save img index to obj animation slot; A1->A0+8
	7EA78	7F049F48	Process monitor animation microcode
 7EB30:	7F04A000
		7EB54	7F04A024	command 00: reset scroll/shift
		7EB68	7F04A038	command 01: horizontal scroll
		7EBC4	7F04A094	command 02: vertical scroll
		7EC20	7F04A0F0	command 03: set horizontal pos
		7EC78	7F04A148	command 04: set vertical pos
		7ECD0	7F04A1A0	command 05: Zoom X
		7ED28	7F04A1F8	command 06: Zoom Y
		7ED80	7F04A250	command 07: use img from global monitor image table
		7EDA4	7F04A274	command 08: halt processing for time
		7EDF4	7F04A2C4	command 09: jump
		7EE10	7F04A2E0	command 0A: jump conditional
		7EE68	7F04A338	command 0B: restart
		7EE70	7F04A340	command 0C: break
		7EE78	7F04A348	command 0D: colour transition
		7EEFC	7F04A3CC	command 0E: set rotation
		7EF24	7F04A3F4	command 0F: rotate
	7F750	7F04AC20
	
	80B00	7F04BFD0
 80B30:	7F04C000
		7F04C044
	
	8193C	7F04CE0C
		??? - object explosion related
	81C9C	7F04D16C
	
	82B00	7F04DFD0	V0= TRUE if A0 a destroyable object type (non-collectable standard object type); fries AT,T6,T7
		uses TLB pointers at 80052DF0
		accepts: A0=p->obj.data
 82B30:	7F04E000
	82B3C	7F04E00C	V0= TRUE if A0 a collectable object; fries AT,T6,T7
		uses TLB pointers at 80052EAC
		accepts: A0=p->obj.data
		7F04E048	V0=TRUE if A0 a destroyable object and not invincible
		accepts: A0=p->obj.data
		7F04E0CC
		
	82C38	7F04E108
		detonate object A0?
		removes ownership
		accepts: A0=p->obj.data, A1=(float) ???, A2=p->xyz positions, A3=item type (as base for explosive)
		7F04E720
		7F04E9BC
		7F04EA68
	83A64	7F04EF34	V0= TRUE if object has not been destroyed; fries T6
		accepts: A0=p->std.object
		calls: 7F03FFC0
		7F04EF58
		
	83CA0	7F04F170
		7F04F218
		
	83DE4	7F04F2B4	append text A400: "Picked up "
	83E1C	7F04F2EC	append article "some", "a", "an", or "the" on ammo collection
		accepts A0= p->text buffer, A1= ammo type, A2= amount
		uses TLB pointers at 80052F10
		7F04F31C	display "some"
		7F04F338	display "a" or "some" if plural
		7F04F37C	display "an" or "some" if plural
		7F04F3C0	display "the" or "some" if plural
		7F04F3FC	display nothing; return
	83F3C	7F04F40C	append name of ammo type A1 upon collection
		accepts A0= p->text buffer, A1- ammo type, A2= amount
			7F04F43C	display "ammo" (types 1-3)
			7F04F464	display "throwing" + "knife":"knives"
			7F04F4CC	display "stick":"sticks" + "of dynamite"
			[7F045F24]	jump to handler for non-special case types
			7F04F544	display "shotgun cartridge"
			7F04F560	display "magnum bullet"
			7F04F57C	display "golden bullet"
			7F04F598	display "hand grenade"
			7F04F5B4	display "grenade round"
			7F04F5D0	display "rocket"
			7F04F5EC	display "remote mine"
			7F04F608	display "proximity mine"
			7F04F624	display "timed mine"
			7F04F640	display "dart"
			7F04F65C	display "explosive pen"
			7F04F678	display "explosive case"
			7F04F694	display "flare"
			7F04F6B0	display "piton"
			7F04F6CC	display "bug"
			7F04F6E8	display "micro camera"
			7F04F704	display "GoldenEye key"
			7F04F720	display "token"
			7F04F73C	display "plastique"
			7F04F750	pluralize if multiples
			[7F04F774]	return
	842B8	7F04F788	sets sound effects on ammo type A0 collection
			7F04F7B4	SE 0EA: firearm
			7F04F7D0	SE 0EB: mine
			7F04F7EC	SE 0E9: knife
			7F04F800	no sound; return
	84340	7F04F810	sets sound effects on weapon type A0 collection
	84450	7F04F920	Display ammo type collection text.  Region-specific ordering
		accepts: A0=p->final text, A1=ammo type, A2=quantity
			[7F04F950]	japanese text
			[7F04F990]	english text
	84528	7F04F9F8	Display text when ammo collected; reroutes to 7F04F920 and 7F08A3C8
		accepts ammo type A0, amount A1
	84598	7F04FA68	adds A1 ammo of type A0 to inventory; also unlocks weapons linked to ammo
		A2=play sound		(0-n:1-y)
		A3=display text	(0-n:1-y)
			[7F04FB04]	05 ammo unlocks grenades
			[7F04FB14]	07 ammo unlocks remote mines and detonator
			[7F04FB38]	08 ammo unlocks proximity mines
			[7F04FB54]	09 ammo unlocks timed mines
			[7F04FB70]	0A ammo unlocks throwing knives
			[7F04FB8C]	10 ammo unlocks explosive case
			[7F04FBA8]	14 ammo unlocks bug
			[7F04FBC4]	15 ammo unlocks micro camera
			[7F04FBE0]	16 ammo unlocks goldeneye key
			[7F04FBFC]	1D ammo unlocks token
			[7F04FC18]	17 ammo unlocks plastique
			[7F04FC2C]	return
	8476C	7F04FC3C	V0= ammo collected from 07 ammo clip; first 0xE ammo types only
		accepts: A0= p->obj.data
			7F04FC70	10	type 1
			7F04FC78	10	type 2
			7F04FC80	10	type 3
			7F04FC88	5	type 4
			7F04FC90	5	type C
			7F04FC98	3	type D
			7F04FCA0	4	type E
			7F04FCA4	1	types 5, 6, 7, 8, 9, A, B
	84828	7F04FCF8	V0= ammo collected from 08 weapon; first 0xE ammo types only
		accepts: A0= p->obj.data
			7F04FD50	10	type 1
			7F04FD58	10	type 2
			7F04FD60	10	type 3
			7F04FD68	5	type 4
			7F04FD70	5	type C
			7F04FD78	3	type D
			7F04FD80	4	type E
			7F04FD88	3	type B
			7F04FD8C	1	types 5, 6, 7, 8, 9, A
	84910	7F04FDE0	Generates language-specific text upon collecting weapon A1: "Picked up " + "article" + "weapon name"
		accepts: A0=p->final string, A1=item type
			[7F04FE04]	japanese
			[7F04FE2C]	english
 84B30:	7F050000
	84D54	7F050224	display text for collecting weapon A0 in lower-left corner
	84D80	7F050250	collect or interact with object
			7F0502C4	4	04 key object collection; play SE 0E5
			7F050310	7	07 ammo clip object collection
			7F050338	14	14 ammo box object collection
			7F0503DC	8	08 weapon object collection
			[7F050410]	test if flag just collected, and if so place in hand
			7F0505B4	15	15 body armor object collection
			7F05062C	default object
	8520C	7F0506DC	object collectability subroutines
		these do not use direct links but branches, but annotating for cataloging purposes
			[7F05093C]	07 object collectability: ammo clip
			[7F050980]	14 object collectability: ammo box 
			[7F050A38]	15 object collectability: body armor
			[7F050AF0]	sets collectability for object
			[7F050D20]	finish object collectability routine
		7F050D30
		
		7F050DE8
		
	86548	7F051A18	trigger remote mine detonation
	86598	7F051A68	V0= TRUE if an entry A1 is a collectable item of type A0
		scans entire obj.pos.data table from A1 onward
		accepts: A0=item type, A1=p->obj.pos.data
	8661C	7F051AEC	V0= TRUE if item A0 depositted
	8668C	7F051B5C	add A0 to temp proximity mine table
		accepts: A0=p->obj.data
	866C4	7F051B94	remove temp proximity mine table entry A0; fries V0,V1,T6
		searches table at 80071E00 for matching obj.data pointer
		accepts: A0=p->obj.data
	866FC	7F051BCC	detonate any temp proximity mines within range of position A0
		accepts: A0=p->(float) xyz positions
		7F051CC8
	868A4	7F051D74	link items A0 and A1; fries T6,T7
		accepts: A0=p->obj.data, A1=p->obj.data
	868C0	7F051D90	V0=p->item's established position entry, after completing object data block
		calls: 7F04054C, 7F052574
		accepts: A0=p->obj.data, A1=p->model header, A2=p->target pos.data entry, A3=???
		7F051DD8
		
 86B30:	7F052000
 
	86B9C	7F05206C	V0=p->new item A1 instance using model A0
	86D18	7F0521E8	Sets 0x4 in runtime flags for item held by guard in hand A1; fries V0,V1,T6,T7,T8,T9
		accepts: A0=p->GUARDdata, A1=hand (0-R,1-L)
	86D44	7F052214	V0=obj.position (8006); A1=model#, A2=type
	86F04	7F0523D4	actor @A0 draws weapon A2, model A1 if possible
		accepts: A0=p->GUARDdata, A1=model, A2=item type
		returns: V0= p->weapon pos.data (8006)
		calls 7F052214: SP+10=0, SP+14=0
		7F0523F8
	87084	7F052554	redirect to 7F0506DC
		7F052574
		7F052604
	871B4	7F052684	returns V0 for specific hat models 0D4-0DF or -1 otherwise
		accepts: A0=p->position data for hat.object
		uses TLB pointers at 800532F4
			7F0526B4	V0=4	fur hats: 0D4, 0D5, 0D6
			7F0526BC	V0=1	green caps: 0D7, 0D8
			7F0526C4	V0=3	helmets: 0D9, 0DA
			7F0526CC	V0=5	moonraker: 0DB
			7F0526D4	V0=0	berets: 0DC, 0DD, 0DE
			7F0526DC	V0=2	officer cap: 0DF
			7F0526E4	V0=-1	default
	8721C	7F0526EC
		7F052B00
		accepts: A0=p->object
		7F052D8C
		accepts: A0=p->object
	880C8	7F053598
		if GUARDdata+F0 not -1, calls 7F0B9DBC: A0=GUARDdata+F0, A1=1
	880F4	7F0535C4
		if GUARDdata+F0 not -1, calls 7F0B9DBC: A0=GUARDdata+F0, A1=0
	88120	7F0535F0	initialize door A0
		accepts: A0=p->std.object, A1=p->xyz position (posdata), A2=matrix?, A3=p->tile, SP+10=, SP+14=p->xyz position (obj.runtime)
	882E8	7F0537B8
		7F053894
	8849C	7F05396C
		???, sets sound effect source to positions
		accepts: A0=p->SE entry, A1=p->(float) xyz positions, A2=(float), A3=(float)
	884E8	7F0539B8
		???
		calls 7F0537B8: A2=5000.0, F14= [80053348]
	88514	7F0539E4
		???
		calls 7F053894: A2=5000.0, A3=6000.0
	88540	7F053A10	set position as source of sound effect
		accepts: A0=p->SE entry, A1=p->(float) xyz positions
		calls 7F05396C: A2=5000.0, A3=6000.0
		7F053A3C
 
	886A8	7F053B78	plays door opening sound effects; JR using 8005334C
	88A94	7F053F64	plays door opening sound effects; JR using 80053390
 88B30:	7F054000
	88DF4	7F0542C4	plays door closing sound effects; JR using 800533D4
	88FE8	7F0544B8	plays door closing sound effects; JR using 80053418
	8927C	7F05474C
		
	893D4	7F0548A4
		???
		accepts: A0=p->obj.data, A1=state
	894B8	7F054988	set door A0's state to A1
		accepts: A0=p->obj.data, A1=state (1-open, 2-closed)
		
		7F054A64
		
		7F05599C
		
	8A8F8	7F055DC8	start alarm [1->80030AC0]; fries V0,T6,T7
	8A91C	7F055DEC	deactivates alarm sound effect [80030AC4]; fries A0
	8A95C	7F055E2C	stop alarm [0->80030AC0]; fries AT,
		calls: 7F055DEC
	8A980	7F055E50	V0= TRUE if alarm on
	8A994	7F055E64	initializes and triggers toxic gas effect
		if stage 0x20 (egypt) does not trigger gas
		accepts: A0=p->3 floating point values
		7F055EF8
		
	8AA68	7F055F38	V0= TRUE if toxic gas has been activated; fries AT,F4,F6
		tests if gas timer [80030AC8] is greater than zero
	8AA94	7F055F64
		
		
 8AB30:	7F056000
 
	8AC90	7F056160	set or unset (A1=0,1) clock lock bits A0; fries: V0,T0,T6,T7,T8,T9
		zero as a clock lock value displays it on screen
		known lock values by usage:
			01	show timer command
			02	plastique detonating
			10	disable interface command
	8ACCC	7F05619C	V0= 1 if clock on screen; fry T6
	8ACE0	7F0561B0	F12->clock time; fry AT
	8ACEC	7F0561BC	F0= clock time; fry AT
	8ACF8	7F0561C8	set clock on[1]/off[0] [A0]; fry AT
	8AD04	7F0561D4	V0= clock on[1]/off[0]
		
	8B2AC	7F05677C	current player drops inventory
		7F056850
	8B424	7F0568F4	V0= size in words of setup object types; fries AT,T6,T7
		accepts: A0=p->object
		uses 0x2F TLB pointers at 80053490
			7F05691C	V0=7	type 9
			7F056924	V0=40	type 1
			7F05692C	V0=2	type 2
			7F056934	V0=20	type 3
			7F05693C	V0=20	type 2A
			7F056944	V0=25	type 2F
			7F05694C	V0=20	type 2B
			7F056954	V0=20	type 24
			7F05695C	V0=21	type 4
			7F056964	V0=20	type 5
			7F05696C	V0=3B	type 6
			7F056974	V0=21	type 7
			7F05697C	V0=22	type 8
			7F056984	V0=40	type A
			7F05698C	V0=95	type B
			7F056994	V0=20	type C
			7F05699C	V0=36	type D
			7F0569A4	V0=3	type E
			7F0569AC	V0=20	type 11
			7F0569B4	V0=3	type 12
			7F0569BC	V0=4	type 13
			7F0569C4	V0=5	type 2C
			7F0569CC	V0=2D	type 14
			7F0569D4	V0=22	type 15
			7F0569DC	V0=4	type 16
			7F0569E4	V0=A	type 25
			7F0569EC	V0=4	type 17
			7F0569F4	V0=1	type 18
			7F0569FC	V0=2	type 19
			7F056A04	V0=2	type 1A
			7F056A0C	V0=2	type 1B
			7F056A14	V0=2	type 1C
			7F056A1C	V0=2	type 1D
			7F056A24	V0=4	type 1E
			7F056A2C	V0=1	type 1F
			7F056A34	V0=4	type 20
			7F056A3C	V0=5	type 21
			7F056A44	V0=1	type 22
			7F056A4C	V0=4	type 23
			7F056A54	V0=4	type 26
			7F056A5C	V0=2C	type 27
			7F056A64	V0=2D	type 28
			7F056A6C	V0=38	type 2D
			7F056A74	V0=7	type 2E
			7F056A7C	V0=1	default; types F,10,29
	8B5B8	7F056A88
		7F056B1C
		7F056BA8
		???
		accepts: A0=p->obj.posdata
	8B768	7F056C38	loads model A0
		7F056CA0
		
	8BBF0	7F0570C0	V0= handle to tagged object# A0
	8BC34	7F057104	V0=p->text for watch briefing page A0 (0-5)
		accepts: A0=page# (0-title, 1-Overview, 2-M briefing, 3-Q briefing, 4-Moneypenny)
	8BCD8	7F0571A8	V0=#objectives+1 [800322F0]
	8BCE8	7F0571B8	V0=p->text for objective# A0
	8BD34	7F057204	V0= difficulty for objective# A0; fries AT,V1,T6
	8BD68	7F057238	V0= status of objective A0
		returns 2 if failed, 1 if complete, 0 if incomplete
		Objectives Microcode Handler
			7F0572C4	type19	destroy object
			7F0572F8	type1A	complete if TRUE
			7F057314	type1B	failed if TRUE
			7F057330	type1C	collect object
			7F05737C	type1D	deposit object
			7F0573B0	type1E	photograph object
			7F0573FC	type20	enter room
			7F057410	type21	deposit object in room
			7F057424	type22	use key analyzer on object
			7F057438	default: type17	create mission objective	type18	end objective	type1F	NULL
	8BFE8	7F0574B8	V0= TRUE if objectives completed
	8C070	7F057540	display "objective x: status" in lower-left corner when status of objective changes
		7F057744
		
	8C9D0	7F057EA0	calls 7F057EAC: F12+=Pi/2
	8C9DC	7F057EAC
		???
		accepts: F12=degree measure
	8CB00	7F057FD0	initialize 0x40 of data at A0; fries: AT,F0,F2
		copies 0 to first 0x38 words, 1.0 to 0x3C
 8CB30:	7F058000
		7F058020
		7F058068
		7F058098
		7F0580C8
		
		7F058474

	8D494	7F058964	initializes A1 and copies position data from A0 to A1+30; fries: AT,F0,F2,F4,F6,F8
	8D4C8	7F058998	copies first 3 floats at A0 to A1+0x30; fries: F4,F6,F8
		7F0589B4
 
	8D5AC	7F058A7C	multiply matrix A1 by F12?; fries: F4,F6,F8,F10,F12,F16,F18
		7F058B10
		
		7F058C4C
		7F058C9C
 
		7F059424
	8E1C4	7F059694
		??? - calls 7F059424
		accepts: A0=p->display list, A1=(float) x pos?, A2=(float) y pos?,A3=(float) z pos?,
			SP+10=x pos?, SP+14=y pos?, SP+18=?, SP+1C=?, SP+20=?, SP+24=
		7F059708
		
		7F059908
		
 8EB30:	7F05A000
		7F05A250
		7F05A310
		7F05A774
		7F05A928
		7F05A9B8
		7F05A9E0
		
	8F560	7F05AA30	computes angle using inverse sine or cosine, as necessary
		returns F0=angle between vectors F12 and F14
		accepts: F12=vector 1, F14=vector 2
		7F05AB70
		???
		uses tables of shorts at 8003241C, 8003239C, and 80032320
		7F05ABF0
		7F05AC44
		7F05ACB0
		7F05AD5C
		7F05AE00
		7F05AE50
		7F05AEFC
		7F05B024
		7F05B154
		7F05B1E0
		7F05B3F4
		7F05B528
		7F05B57C
		7F05B5D4
		7F05B628
		7F05B798
		7F05B9B4
		7F05BA08
		7F05BC68
		7F05BE10
		7F05BE88
		7F05BF8C
		7F05BFD4
 90B30:	7F05C000
 
	90E90	7F05C360	F0=truncf(F12); fries AT,T7,T9,F2,F4,F6,F8,F10,F16,F18
		7F05C3D8
 
	91050	7F05C520	A0->80034C9C; fry AT
	9105C	7F05C52C
		V0= [80034C9C]
		
	913E4	7F05C8B4	V0= p->item A0's statistics (80032494 table); fries V1,T6,T7,T8
	91420	7F05C8F0	copies item in hand A0's (0-R,1-L) position to A1
	91468	7F05C938	copies item in hand A0's (0-R,1-L) position from A1 to main list
	914B0	7F05C980	
		accepts: A0=hand (0-right; 1-left)
	919FC	7F05CEBC
		accepts: A0=hand (0-right; 1-left)
	91A30	7F05CF00	V0= item type in current player's hand A0 (0-R,1-L); fries T6,T7,T8
	91A48	7F05CF18	V0=p->obj.header for item in cur. player's hand A0 (0-R,1-L)
	91A8C	7F05CF5C	remove item in cur. player's hand A0 (0-R,1-L)
	91AD4	7F05CFA4	places item A1 in hand A0 (0-R,1-L) if allowed; fries V1,A2,T0,T3,T6,T7,T8
		tests update registers and ensures weapon code has changed.  Swaps and makes visible
	91B48	7F05D018	V0=p->item A0's text call line
	91B78	7F05D048	V0=p->weapon A0's model header line; fries AT,A0,V0,T6,T7
	91BA8	7F05D078
		V0=[BONDdata+2A38]
		7F05D088
		???
		used to load 1st person model on-demand

	91F64	7F05D434	V0= next weapon in cycle for hand A0 (0-R,1-L); fries AT,V0,V1,T6,T7,T8,T9
		mode A1:
			0	
			1	previously drawn weapon
		7F05D4E0
		
	92200	7F05D6D0	advance through inventory
	92298	7F05D768	advance backward through inventory
	92330	7F05D800	auto-advance inventory when last of ammo for item spent
	92444	7F05D914	Draw item A1 in hand A0 (0-R,1-L); fries V0,V1,T0,T1,T2,T6,T7,T8,T9
	92494	7F05D964	reload item in hand A0 (0-R,1-L) if more ammo available; fries A0,V0,T0,T6,T7,T8,T9
	92500	7F05D9D0	V0= hand A0's item (0-R,1-L); fries T6,T7,T8
	92530	7F05DA00	Draw item A1 in hand A0 (0-R,1-L); fries V0,T0,T6,T7,T8,T9
	92574	7F05DA44	V0= hand A0's item (0-R,1-L) - prefers 0x874 value if found; fries V1,A1,T6,T7
		7F05DA8C
		7F05DAE4
		
	92684	7F05DB54	remove hand A0's (0-R,1-L) item.  Probably the stock method of doing so when switching weapons
		also returns its clip ammo to stock and tests if < 21
	927B8	7F05DC88	V0= hand A0's firing status (0-R,1-L); fries T6,T7,T8
		7F05DCE8
		
 92B30:	7F05E000
	92B8C	7F05E05C	V0=TRUE if you have ammo for item A0; calls 7F05E0B4 + 7F06942C + 7F069450
		fries: A0,A1,V1,T6,T7,T8,T9
	92BE4	7F05E0B4	V0=TRUE if any of mask A1 is present in item A0's special attributes [statistics+0x6C]
		7F05E0E4
		
	93194	7F05E664	if hand A0's (0-R,1-L) item is watch (1E/17), F0=80053C78
		else, F0=80053C7C
	931E4	7F05E6B4
		
	9336C	7F05E83C	
		
		7F05EC1C
		??? - for thrown objects, after loading them.  Sets path?  don't know...
		
	93E88	7F05F358
		??? - generate player-thrown model?
		select appropriate item model
		uses TLB pointers at 80053CB0	0x23
			7F05F564	1C	0C8: Proximity Mine
			7F05F56C	1B	0C9: Timed Mine
			7F05F574	21	0E2: Bombcase
			7F05F57C	2F	0F5: Bug
			7F05F584	30	0F6: Micro Camera
			7F05F58C	3D	0F8: GoldenEye Key
			7F05F594	22	111: Plastique
			7F05F598	1D,1E,1F,20,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,31,32,33,34,35,36,37,38,39,3A,3B,3C
			0C7: remote mine	(default)
		generate temporary object for item type and set timer
		uses TLB pointers at 80053D3C	0x23
			7F05F5D0	1D	Remote Mine
			7F05F5F8	1C	Proximity Mine
			7F05F620	1B	Timed Mine
			7F05F648	21	Bombcase
			7F05F670	22,2F,30,3D	static thrown items
			7F05F67C	1E,1F,20,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,31,32,33,34,35,36,37,38,39,3A,3B,3C	default
			7F05F684	end of switch
		7F05F73C
		
	94AF8	7F05FFC8
		??? - handles firing or throwing weapon in hand A0 or something
		accepts: A0=hand (0-right: 1-left)
 94B30:	7F060000
		uses TLB pointer table at 80053E38	0x14
			7F0617B4	4,5,6,7,8,9,A,B,C,D,E,11,12,13,14,15
			7F0617CC	16,17
			7F0617D4	F,10	default
	96450	7F061920
		calls 7F05FFC8 for left and right hand
		7F061948
		
	96948	7F061E18
		??? - uses allocated turret data
		accepts: A0=???, A1=p->allocated turret data, A2=???
 96B30:	7F062000
	8C9D0	7F062B00
		??? - increments autoturret timer + ???
		accepts: A0=p->allocated data for turret
		7F062BE4
		
		7F063004	???; sets enviroment fog for items in solo watch menu
		accepts: A0=p->display list, A1=, A2=p->buffer, A3=, SP+10=RGBA color
		7F0634D8
		
		7F06359C		
 98B30:	7F064000
 		7F064364
		7F0643A0
	98F4C	7F06441C
		???	recalls joy2 hits edit flag, joy2 detail edit flag
		7F064720
	992A4	7F064774
		???	recalls joy2 hits edit flag
		7F064934
		7F0649AC
		7F0649D8
	99658	7F064B28
		??? - handles weapon ID values, possibly 1st person animation
		uses TLB pointers at 80053F24 [7F064DAC]
			7F064DD0	11,17
			7F064DF4	26,
			7F064E54	3-10,12-16,18,1C,1E,21,22,3A
			7F064E68	19,1A,1B,1F,20,2D,2E,3B
			7F064E7C	2
			7F064EEC	1
			7F064F1C	3
			7F064F30	1D
			7F064F7C	23-25,27,28,2A-2C,2F-39,47,55-57
			7F064F90	default: 29,3C-46,48-54,58-5C
		uses TLB pointers at 80054084 [7F064FC8]
			7F064FE8	27,3B
			7F065034	3-5,E-18,1D,1F,22,23
			7F0650C4	6-D
			7F0651D0	1
			7F06520C	1E
			7F06528C	default: 2,19-1C,20,21,24-26,28-3A
		Plays sound when drawing/reloading weapon
		uses TLB pointers at 80054194 [7F065E34]
			7F065E54	SE 0F2	16
			7F065E70	SE 0E9	2,3
			7F065E8C	SE 0EB	1B-1D
			7F065EA8	SE 0E8	default: 4-15,18,19,23-27,29-2E,31-3B
			7F065EBC	no SE	0,1,17,1A,1E-22,28,2F,30,3C,3D
 9AB30:	7F066000
		uses TLB pointers at 8005429C [7F06618C]
			7F0661AC	default	4-16,19,1A,24-28,2A-2E,31-3B
			7F0661C0	skips jump	0-3,17,18,1B-23,29,2F,30,3C,3D
	9B990	7F066E60
	9BA28	7F066EF8	V0= key analyzer flag [BONDdata+1060]; fries T6 (p->BONDdata)
		7F066F08
	9BAD4	7F066FA4	F0= vertical position on solo watch menu main page for item A0 [watch+0x14]; fries AT,T6
	9BAF0	7F066FC0	F0= lateral position on solo watch menu main page for item A0 [watch+0x18]; fries AT,T6
	9BB0C	7F066FDC	F0= depth on solo watch menu main page for item A0 [watch+0x1C]; fries AT,T6
	9BB28	7F066FF8	F0= z rotation on solo watch menu for item A0 [watch+0x20]; fries AT,T6
	9BB44	7F067014	F0= x rotation on solo watch menu for item A0 [watch+0x24]; fries AT,T6
	9BB60	7F067030	F0= 45.0 [42340000], A0->SP+0; fries AT
	9BB70	7F067040	V0= p->first title line for item A0 [watch+0x10]; fries A0,V1,T0,T6,T7,T8,T9
	9BBA4	7F067074	V0= p->second title line for item A0 [watch+0x12]; fries A0,V1,T0,T6,T7,T8,T9
	9BBD8	7F0670A8	V0= p->short watch text for item A0 [watch+0x2A]; fries A0,V1,T0,T6,T7,T8,T9
	9BC0C	7F0670DC	V0= p->long watch text for item A0 [watch+0x28]; fries A0,V1,T0,T6,T7,T8,T9
	9BC40	7F067110	F0=45.0, A0->SP+0; fries AT
	9BC50	7F067120	F0= horizontal offset on solo watch menu inventory page for item A0 [watch+0x2C]; fries AT,T6
	9BC6C	7F06713C	F0= vertical offset on solo watch menu inventory page for item A0 [watch+0x30]; fries AT,T6
	9BC88	7F067158	F0= depth offset on solo watch menu inventory page for item A0 [watch+0x34]; fries AT,T6
		7F067174
		??? - probably returns float F0
		accepts: A0=hand
		
 
	9BCD4	7F0671A4
		??? - looks at left hand and right hand item
	
	9BEE4	7F0673B4
		??? - looks at hand A0 (0-R,1-L)
	9BF50	7F067420
	9C6C4	7F067B94	calculate crosshair position/gun rotation
	
 9CB30:	7F068000
 
	9DC24	7F0690F4	sets (A1=0) or unsets (A1!=0) flags A0 in [BONDdata+1064]; fries V0,T0,T6,T7,T8,T9
		accepts: A0=setting, A1=ammo on-screen setting
	9DC60	7F069130	add ammo type A0, amount A1 to cur. player
	9DD70	7F069240	V0= ammo of type A0 in cur. player's inventory; fries T6,T7,T8
	9DD88	7F069258	V0= total ammo of type A0, including in weapon clips; fries A0,V0,V1,T6,T7,T8
	9DE04	7F0692D4	V0= max ammo for type A0; fries T6
	9DE20	7F0692F0	set max ammo for cur. player; fries  V0,V1,A0,A1,T6,T7,T8,T9
	9DE74	7F069344	V0= hand A0's (0-R,1-L) ammo on clip (+89C); fries T6,T7,T8
	9DEA4	7F069374	V0= ammo for hand A0's weapon, used to handle shotguns to display shells
	9DF24	7F0693F4	REVISED ROMS ONLY
		RESERVED FOR FUTURE USE
	9DF5C	7F06942C	V0= ammo type for weapon A0; fries V1,T6,T7,T8
	9DF80	7F069450	V0= ammo for weapon A0 in cur. player's inventory; fries V1,T6,T7,T8,T9
	9DFB4	7F069484	add A1 of ammo for weapon A0 to cur. player; calls 7F05C8B4 + 7F069130
	9DFE0	7F0694B0	V0= max ammo for weapon A0; fries  V1,T6,T7,T8,T9
	9E018	7F0694E8	microcode generation for image display
		accepts: A0=p->microcode buffer, A1=p->image declaration,
			A2=(float)horizontal position, A3=(float)-1?, 
			SP+10=(float)vertical position, SP+14=?, 
			SP+18=(float)vertical offset, SP+1C=?
			SP+20=red, SP+24=green, SP+28=blue, SP+2C=alpha
	9E514	7F0699E4	sets RGBA values and redirects to display ammo type image
		accepts: A0=p->microcode buffer, A1=p->image declaration, A2=(float), A3=(float), SP+10=(float)hor. offset, SP+14=, SP+18=(float)vert. offset, SP+1C=
		calls: 7F0694E8
	9E580	7F069A50
		??? - display routine
		accepts: A0=p->display list, A1=p->string, A2=???, A3=???, SP+10=???, SP+14=???
		
	9E7BC	7F069C8C	displays ammo total A1
		accepts: A0=p->microcode buffer, A1=ammo total, A2=???, A3=???, SP+10=???, SP+14=???
		uses string "%d" from 80053BF4
	9E824	7F069CF4
		??? - generates microcode
 9EB30:	7F06A000
		7F06A334
	9F0D8	7F06A5A8	set or unset (A1= 0-1) bitflags A0 at BONDdata+0x1128; fries V0,T6,T0,T7,T8,T9
		accepts: A0=bitflags, A1=un/set register
		7F06A5E4
	9F228	7F06A6F8	Increment hit count A1 for weapon A0 in cur.player's stats
		Only count if 00010000 set in item A0's special function bitflags
		increments word A1 in stats; refer to player statistics for details
	9F270	7F06A740	V0= cur.player's shot register A0 [stats+0]; fries T6,T7,T8
		technically loads word #A0 from stats.  0-6 valid shot registers.
	9F288	7F06A758	increment cur.civilian casualties [stats+0x6C]; fries: V0,T6,T7
	9F2A0	7F06A770	V0= cur.player's civilian casualties [stats+0x6C]; fries: T6
	9F2B0	7F06A780	increment cur.kill count [stats+0x1C], display text if multiplayer
	9F454	7F06A924	V0=cur.player's total kill count (stats+0x1C); fry T6
	9F464	7F06A934	increment cur.#killed MwtGX special weapon owner (stats+0x20); fry V0,T6,T7
	9F47C	7F06A94C	V0=cur.player's #killed MwtGX special weapon owner (stats+0x20); fry T6
	9F48C	7F06A95C	increment cur.#deaths [BONDdata+29D8], display text if multiplayer
	9F538	7F06AA08	V0= cur.#deaths [BONDdata+29D8]; fries T6
	9F548	7F06AA18	increment cur.#suicides [BONDdata+29DC], display text if multiplayer
	9F6D0	7F06ABA0	V0= cur.#suicides [BONDdata+29DC]; fries T6
		7F06ABB0
	9FB18	7F06AFE8	display image at on-screen coordinates
		A0=p->display list, A1=p->(float) x/y positions, A2=(float) image width/height, A3=width, SP+10=height,
		SP+14=rotate left 90deg. (1-yes; 0-no), SP+18=flip horizontally (1-yes; 0-no), SP+1C=flip vertically (1-yes; 0-no),
		SP+20=red, SP+24=green, SP+28=blue, SP+2C=alpha
		SP+30=!format, SP+34=???
	9FC50	7F06B120
		??? - uses TLB pointers at 80054490, per obj.table types
			7F06B174	types 1,2,3,B,C,D,E,F,10,15
			7F06B188	default
	9FD78	7F06B248
	9FDCC	7F06B29C
		??? - uses TLB pointers at 800544E4, per obj.table types
			7F06B2FC	type 01
			7F06B360	type 02
			7F06B3C4	type 03
			7F06B428	type 15
			7F06B448	type 0E
			7F06B49C	type 0F
			7F06B530	type 10
			7F06B588	type 0B
			7F06B5DC	type 0C
			7F06B630	type 0D
			7F06B6A4	default
	A0658	7F06BB28
	A073C	7F06BC0C
		??? - uses TLB pointers at 80054538, per obj.table types
			7F06BD44	types 1,2,3,B,C,D,E,F,10,15
			7F06BD68	default
	A0930	7F06BE00
		??? - uses TLB pointers at 80054598, per obj.table types
		probably has to do with damage detail or 'blood' effect
			7F06BEF4	types 01,02,03,15
			7F06BEFC	types 0B,0C,0D,0E,0F,10 (identical routine)
			7F06BF04	type 0A	[+JAL 7F074C68]
			7F06BF4C	type 11	[+JAL 7F074CAC]
			7F06BF94	type 08	[-JAL 7F06E970]
			7F06BFA8	type 12	[-JAL 7F06E9BC]
			7F06BFBC	type 17	[-JAL 7F06EA08]
			7F06BFC8	default
 A0B30:	7F06C000
		7F06C010
		7F06C060
	A0BC4	7F06C094	V0=obj.instance controller generated from nonaircraft object header A0
		accepts: A0=p->obj.header
	A0D64	7F06C234	set scale to 0.0 in nonaircraft object instance A0
		0->A0+8: 
	A0D6C	7F06C23C	V0=obj.instance controller generated from aircraft object header A0
	A0EE4	7F06C3B4
	A0F28	7F06C3F8	set scale to 0.0 in aircraft object instance A0
		0->A0+8: 
	A0F30	7F06C400
		A0-> [80036084]; fry AT
	A0F3C	7F06C40C
		F12-> [80036088]; fry AT
	A0F48	7F06C418
	A0F90	7F06C460	A0-> [8003608C]
		accepts: A0=p->function
	A0F9C	7F06C46C	unconditional return
	A0FA4	7F06C474
	A1080	7F06C550	redirect to 7F06C474
	A10A0	7F06C570
		accepts: A0=, A1=
	A1190	7F06C660
		accepts: A0=, A1=, A2=
		7F06C6A0
		7F06C710
		7F06C768
	A12CC	7F06C79C	extracts ID values from object structure microcode
			7F06C7D8	xx01	A2= halfword @ 0xC
			7F06C7E4	xx18	A2= halfword @ 0x1A
			7F06C7F0	xx07	A2= halfword @ 0x1AA
			7F06C7FC	xx08	A2= halfword @ 0xC
			7F06C808	xx12	A2= halfword @ 0x4
			7F06C814	xx09	A2= halfword @ 0x22
			7F06C820	xx0B	A2= halfword @ 0x44
			7F06C82C	xx0C	A2= halfword @ 0x20
			7F06C838	xx17	A2= halfword @ 0x0
			7F06C840	default
	A13C8	7F06C898
		7F06C9D0
		7F06CB98
		7F06CC0C
	A17B0	7F06CC80
		7F06CD3C
	A19A8	7F06CE78	set scale A1 to object instance controller A0 + 14
		[float] A1->A0+14; fries F12
	A19B4	7F06CE84
		[float] A1->A0+B8; fries F12
	A19C4	7F06CE90	getjointsize - uses TLB pointers at 80054B60, per obj.table types
		used for character impact animations
			7F06CEF8	type 01	float @ +0x8
			7F06CF10	type 02	float @ +0x18
			7F06CF28	type 03	float @ +0x18
			7F06CF40	type 15	float @ +0x10
			7F06CF58	type 0B	float @ +0x40
			7F06CF70	type 0C	float @ +0x1C
			7F06CF88	type 0D	float @ +0x18
			7F06CFA0	type 0E	float @ +0xC
			7F06CFB8	type 0F	float @ +0x18
			7F06CFD0	type 10	float @ +0x14
			7F06CFE8	default
	A1B3C	7F06D00C
		7F06D07C
		7F06D0CC
		7F06D160
		
		7F06D6B0

 A2B30:	7F06E000
		7F06E0A0
		7F06E2B8
		7F06E540
		7F06E64C
		7F06E7A8
	A3388	7F06E858	???; called by 7F06EEA4 for type 08 distance triggers
		accepts: A0=, A1=p->obj.table entry
		7F06E970
		7F06E9BC
	A3538	7F06EA08	???; called by 7F06EEA4 for type 17 pointer to head
		accepts: A0=, A1=p->obj.table entry
		7F06EA54
		7F06EB10
	A366C	7F06EB3C	???; called by 7F06EEA4 for type 09 head/hat placement interlink
		accepts: A0=, A1=p->obj.table entry
	A3828	7F06ECF8	???; called by 7F06EEA4 for type 07
		accepts: A0=, A1=p->obj.table entry
	A39D4	7F06EEA4
		accepts: A0=, A1=p->obj.header
		??? - uses object table entries and TLB entries at 80054C20
			7F06EEFC	types 01,02,03,0B,0C,0D,0E,0F,10,15
			7F06EF04	type 08	distance trigger
			7F06EF18	type 09	head/hat placement interlink
			7F06EF2C	type 07	unknown
			7F06EF40	type 17	pointer to head
			7F06EF4C	default
	A3AF4	7F06EFC4
		??? - uses object table entries and TLB entries at 80054C80
		accepts: A0=p->object instance
			7F06F014	type 08	distance trigger
			7F06F028	type 09	head/hat placement interlink
			7F06F03C	type 07	unknown
			7F06F050	type 12	handle/switch
			7F06F064	type 17	pointer to head
			7F06F078	default
	A3C00	7F06F0D0
		??? - uses object table entries and TLB entries at 80054CE0
			7F06F128	type 01	group heading
			7F06F140	type 02	position
			7F06F158	type 03	unknown
			7F06F170	type 15	subposition
			7F06F188	type 08	distance trigger
			7F06F19C	type 09	head/hat placement interlink
			7F06F1B0	type 07	unknown
			7F06F1C4	type 12	handle/switch
			7F06F1D8	type 17	pointer to head
			7F06F1EC	default
	A3D78	7F06F248
		7F06F2F8
	A40DC	7F06F5AC
		V0= word at A0+20: 
	A40E4	7F06F5B4
		V0= byte at A0+24: 
	A40EC	7F06F5BC
		F0= float at A0+28: 
		7F06F5C4
		
 A4B30:	7F070000
 		
	A4D04	7F0701D4
		A0-> [80036250]; fry AT
	A4D10	7F0701E0
		V0= [80036250]
		7F0701EC

		7F070AEC

		
 A6B30:	7F072000
		
		7F072644
		7F0726F8
		7F072784
		7F072984
	A7740	7F072C10
		A0->SP+0, A1->SP+4, A2->SP+8
		7F072C20
		7F073038
	A7B9C	7F07306C
		A0->SP+0, A1->SP+4, A2->SP+8
		7F07307C
	A831C	7F0737EC
		A0->SP+0, A1->SP+4, A2->SP+8
	A832C	7F0737FC
		A0->SP+0, A1->SP+4, A2->SP+8
		7F07380C
	A8AF8	7F073FC8
		A0-> [800363F0]; fry AT
		7F073FD4
 A8B30:	7F074000
	A9044	7F074514
		A0->SP+0, A1->SP+4, A2->SP+8
	A9054	7F074524
		A0->SP+0, A1->SP+4, A2->SP+8
	A9064	7F074534
		??? - uses object table entries and TLB entries at 80054D54
			7F07456C	type 08	JAL 7F06E970, A0=A3, A1=A2
			7F074580	type 12	JAL 7F06E9BC, A0=A3, A1=A2
			7F074594	type 17	JAL 7F06EA08, A0=A3, A1=A2
			7F0745A8	type 09	JAL 7F06EB10, A0=A3, A1=A2
			7F0745BC	type 0B	JAL 7F0737FC, A1=A3
			7F0745CC	type 0C	JAL 7F07380C, A1=A3
			7F0745DC	type 0D	JAL 7F073FD4, A1=A3
			7F0745EC	type 0A	JAL 7F074514, A1=A3
			7F0745FC	type 11	JAL 7F074524, A1=A3
			7F07460C	type 04	JAL 7F072784, A1=A2
			7F07461C	type 18	JAL 7F072984, A1=A3
			7F07462C	type 14	JAL 7F072C10, A1=A3
			7F07463C	type 16	JAL 7F072C20, A1=A2
			7F07464C	type 05	JAL 7F07306C, A1=A3
			7F07465C	type 07	JAL 7F07307C, A1=A3
			7F07466C	type 06	JAL 7F0737EC, A1=A3
			7F074674	default
	A91B4	7F074684
		7F074790
		
	A9E2C	7F0752FC
		??? - uses object table entries and TLB entries at 80054D54
			7F0753CC	type 0A
			7F075404	type 11
			7F07543C	type 08
			7F075450	type 12
			7F075464	type 17
			7F075470	default
	A9FCC	7F07549C
		
	AA10C	7F0755DC	Converts object microcode offsets into rdram addresses
			7F075678	xx01
			7F075698	xx02
			7F0756B8	xx03
			7F0756D8	xx04
			7F0756FC	xx18
			7F07578C	xx14
			7F0757AC	xx05
			7F07583C	xx07
			7F0758F4	xx06
			7F075904	xx08
			7F07592C	xx12
			7F07594C	xx09
			7F075980	xx11
			7F0759A0	xx0B
			7F0759C4	xx0C
			7F0759E8	xx0D
			7F075A20	xx16
			7F075A44	default: 0A, 0E, 0F, 10, 13, 15, 17
	AA5C0	7F075A90
	AA638	7F075B08
		A0->SP+0, A1->SP+4, A2->SP+8, A3->SP+C
	AA64C	7F075B1C	Set object microcode entry numbers; A0=p->obj.table, A1=p->obj.header
			7F075B68	xx01	
			7F075B84	xx07	
			7F075BA0	xx08	
			7F075BC0	xx12	
			7F075BE0	xx17	
			7F075C00	xx09	
			7F075C30	xx0B	
			7F075C4C	xx0C	
			7F075C68	xx18	
			7F075C84	default: 02, 03, 04, 05, 06, 0A, 0D, 0E, 0F, 10, 11, 13, 14, 15, 16
			7F075CDC	kill routine
	AA824	7F075CF4	set obj. use flag, compute group #s, set obj loaded byte; A0=p->obj.header
		redirect to 7F075B1C, setting A0=p->obj.table, A1=p->obj.header
		returns V0=TRUE if object loaded byte is set
	AA85C	7F075D2C	object microcode handler (use unknown)
			7F075D88	xx01
			7F075E00	xx07
			7F075E18	xx08
			7F075E78	xx09
			7F075E9C	xx0B
			7F075EB4	xx0C
			7F075E38	xx12
			7F075E5C	xx17
			7F075ECC	xx18
			7F075EF4	default: 02, 03, 04, 05, 06, 0A, 0D, 0E, 0F, 10, 11, 13, 14, 15, 16
	AAA98	7F075F68
		accepts: A0=p->obj instance controller, A1=p->object header, A2=p->object table index
		
 AAB30:	7F076000
	AAFD4	7F0764A4	loads obj and fills header
		accepts: A0=p->header, A1=p->recall string, A2=target loc, A3=size left, SP+10= ?
	AB07C	7F07654C	loads object into memory
		accepts: A0=p->header, A1=p->recall string
		redirects to 7F0764A4, setting A2, A3, & SP+10 = 0
	AB0A4	7F076574	loads object into memory
		accepts: A0=p->header, A1=p->recall string, A2=target loc, A3=size left
		redirects to 7F0764A4, setting SP+10 = 0
	AB0C4	7F076594
			next three words blank
	AB0D0	7F0765A0	determines if A0 is less than a certain power of 2; fries AT
		A0<2		V0=0
		A0=2		V0=1
		A0=3-4		V0=2
		A0=5-8		V0=3
		A0=9-10	V0=4
		A0=11-20	V0=5
		A0=21-40	V0=6
		A0=41-80	V0=7
		A0>80		V0=8
	AB178	7F076648	V0=ceil(0x8000 /width A0); fries: AT,V1,T1,T6,T7,T8,F0,F4,F6,F8,F10,F16,F18
	AB1DC	7F0766AC	V0=ceil(0x4000 /width A0); fries: AT,V1,T1,T6,T7,T8,F0,F4,F6,F8,F10,F16,F18
	AB240	7F076710	V0=ceil(0x2000 /width A0); fries: AT,V1,T1,T6,T7,T8,F0,F4,F6,F8,F10,F16,F18
	AB2A4	7F076774	V0=ceil(0x1000 /width A0); fries: AT,V1,T1,T6,T7,T8,F0,F4,F6,F8,F10,F16,F18
		7F0767D8
		accepts: A0=width, A1=height, A2=???, 
		7F076848
		7F0768B8
		7F076928
		7F076998
		??? - generates microcode - othermode settings
		accepts: A0=p->DL, A1=???, A2=???, A3=bowtie
	AB898	7F076D68
		???	image processor of some type; likely generates DL for image declaration
		accepts: A0=p->display list target, A1=p->imgcall, A2=?, A3=?, SP+10=?
	AC6E8	7F077BB8
		???	copies A0->SP+0, A1->SP+4, A2->SP+8, A3->SP+C
	AC6FC	7F077BCC	unconditional return
	AC708	7F077BD8
		???	F12->BONDdata+1090, F14->BONDdata+1094, F12/2->BONDdata+10AC, F14/2->BONDdata+10B0
		accepts: F12=?, F14=?
		fries: AT,V0,T6,T7,T8,T9,F0,F4,F6
	AC744	7F077C14
		???	F12->BONDdata+1098 & F14->BONDdata+109C; fries V0,T6,T7
	AC760	7F077C30
		???	F12->BONDdata+10A0, F14->BONDdata+10A4, A2[float]->BONDdata+10A8; fries V0,T6,T7,T8,F4,SP+8
	AC78C	7F077C5C
		???
	ACA1C	
		
 ACB30:	7F078000
		
	ACE54	7F078324
		A0->BONDdata+10C4; fries T6
	ACE64	7F078334
		V0= BONDdata+10C4; fries T6
	ACE74	7F078344
		A0->BONDdata+10C8; fries T6
	ACE84	7F078354
		V0= BONDdata+10C8; fries T6
	ACE94	7F078364
		A0->BONDdata+10D8; fries T6
	ACEA4	7F078374
		V0= BONDdata+10D8; fries T6
	ACEB4	7F078384
		A0->BONDdata+10E0; fries T6
	ACEC4	7F078394
		V0= BONDdata+10E0; fries T6
	ACED4	7F0783A4
		A0->BONDdata+10CC; copies original value to BONDdata+10CC; fries V0,V1,T6,T7
	ACEF4	7F0783C4
		V0= BONDdata+10CC; fries T6
	ACF04	7F0783D4
		A0->BONDdata+10DC; fries T6
	ACF14	7F0783E4
		V0= BONDdata+10DC; fries T6
	ACF24	7F0783F4
		V0= BONDdata+10E8; fries T6
	ACF34	7F078404
		A0->BONDdata+10D0; fries T6
	ACF44	7F078414
		V0= BONDdata+10D0; fries T6
	ACF54	7F078424
		A0->BONDdata+10D4; copies original value to BONDdata+10EC; fries V0,V1,T6,T7
	ACF74	7F078444
		V0= BONDdata+10D4; fries T6
	ACF84	7F078454
		V0= BONDdata+10EC; fries T6
	ACF94	7F078464
		A0->BONDdata+10E4; fries T6
	ACFA4	7F078474
		V0= BONDdata+10E4; fries T6
	ACFB4	7F078484
		F0= BONDdata+10F8; fries T6
	ACFC4	7F078494
		V0= BONDdata+10FC; fries T6
	ACFD4	7F0784A4
		F0= BONDdata+1090; fries T6
	ACFE4	7F0784B4
		F0= BONDdata+1094; fries T6
	ACFF4	7F0784C4
		F0= BONDdata+1098; fries T6
	AD004	7F0784D4
		F0= BONDdata+109C; fries T6
	AD014	7F0784E4
		F0= BONDdata+10A4; fries T6
	AD024	7F0784F4
		F0= BONDdata+10A8; fries T6
		7F078504

	ADC20	7F0790F0	V0=selected spawn#
	ADF1C	7F0793EC
		???	initialize player data?
		7F0798B8
		7F079988
		7F0799AC	change crouch position (used for aiming)
		7F0799F0
		7F079A1C
	AE580	7F079A50
		A0->BONDdata+0; fry T6
		7F079A60
	AE820	7F079CF0	load player and set up their character's obj.instance
			7F079E00	body=16: cuff 3 - Boiler
			7F079E0C	body=18: cuff 2 - Jungle
			7F079E18	body=19: cuff 4 - Snowsuit
			7F079E24	body=05: cuff 1 - Brosnan Tux
			7F079E30	body=05: cuff 5 - Connery
			7F079E3C	body=05: cuff 6 - Moore
			7F079E48	body=05: cuff 7 - Dalton
			7F079E54	body=##: cuff 8 - Selected Bond Body
			7F079EF4	head=4A: cuff 3 - Boiler
			7F079F00	head=4C: cuff 2 - Jungle
			7F079F0C	head=4E: cuff 1 - Brosnan Tux
			7F079F18	head=4E: cuff 5 - Connery
			7F079F24	head=4E: cuff 6 - Moore
			7F079F30	head=4E: cuff 7 - Dalton
			7F079F3C	head=##: cuff 8 - Selected Bond Head
			7F079F60	multiplayer bodies and heads
 AEB30:	7F07A000
	AEFD0	7F07A4A0	???; solo intro camera handler?
	AF058	7F07A528	V0= current camera mode [80036494]
		7F07A534	
	AF4E8	7F07A9B8	use intro camera mode A0 (0-9)
			[7F07A9E8]	1-solo static intro camera
			[7F07AA88]	2-fade to swirl
			[7F07AAC4]	9-MP rotating intro camera
			[7F07AB1C]	3-solo rotating intro camera
			[7F07AC88]	4-1st person mode
			[7F07AD74]	5-(used during death+respawn)
			[7F07B0AC]	6-
			[7F07B0E8]	7-
			[7F07B110]	8-return to 1st person mode from camera
			[7F07B130]	A-
			[7F07B194]	default - return
	AFCD4	7F07B1A4
	AFDD0	7F07B2A0
	AFEF4	7F07B3C4	V0= current camera state
 B0B30:	7F07C000
 
	B1070	7F07C540
		A0->[BONDdata+42C]; fries T6
	B1080	7F07C550	A0->cur.player's look-ahead setting [BONDdata+118]; fries T6
	B1090	7F07C560	V0= cur.player's look-ahead setting [BONDdata+118]; fries T6
	B10A0	7F07C570	A0->cur.player's auto-aim [BONDdata+128]; fries T6
	B10B0	7F07C580	V0= cur.player's auto-aim setting; fries AT,V0,V1,T6,T7,T8,T9
		solo draws from BONDdata+128, multi from stats+6A
	B10F0	7F07C5C0	redirect to 7F07C580
	B1110	7F07C5E0	V0= cur.player's auto-aim y setting [BONDdata+128]; fries T6
		7F07C5F0
	B1188	7F07C658	A0->cur.player's auto-aim x setting [BONDdata+138]; fries T6
	B1198	7F07C668	V0= cur.player's auto-aim x setting; fries AT,V0,V1,T6,T7,T8,T9
		solo draws from BONDdata+138, multi from stats+6A
	B11D8	7F07C6A8
		redirect to 7F07C668
		7F07C6C8
		7F07C730	change player position using given source
		accepts: A0=p->target pos.block, A1=p->source pos, A2=p->tile
		A0=BONDdata position block pointer
		A1=x,y,z position
		7F07C7B4
		7F07C888
		7F07CA2C
		7F07CAC8
	B18D8	7F07CDA8
		calls: 7F07CAC8: A3=0
		7F07CDD4
	B19A8	7F07CE78	V0= 1 if player in tank [80036448]
	B19B4	7F07CE84	V0= p->8006 for object if player in tank; fry AT,T6
		7F07CEB0
		7F07CF80	F0= [8003646C]
		7F07CF8C	calculate player collision?
		7F07D234
		7F07D2B4
		7F07D4C0
		7F07D61C
		7F07D960
		7F07DE64
		accepts: A0=p->BONDdata
		calls 7F03DE94: A0=p->BONDdata.pos.data, A1=BONDdata+2A04
		7F07DE9C
		accepts: A0=p->BONDdata
		7F07DEFC
		7F07DF28
 B2B30:	7F07E000
	B2B40	7F07E010
	B2B6C	7F07E03C
	B2B98	7F07E068
	B2BC0	7F07E090
		7F07E388
	B2F30	7F07E400	trigger watch zoom: F12=final, F14=time; fries: V0,V1,T6,T7,T8,F4,F6
	B2F50	7F07E420	copy watch zoom final size to zoom factor register [8005507C]
		7F07E438

	B305C	7F07E52C	zoom to watch menu on open
	B30C4	7F07E594	zoom from watch menu on exit
	B312C	7F07E5FC	V0= TRUE if watch page transition running; fries V1,F4,F6
		7F07E62C
		
	B3600	7F07EAD0	A0-> show minute ticks around watch menu [cur.BONDdata+1CC]; fries T6
	B3610	7F07EAE0	V0= TRUE if minute ticks displayed around watch menu [cur.BONDdata+1CC]; fries T6
	B3620	7F07EAF0
		
		7F07F860
	B43A4	7F07F874	1->trigger solo watch menu [BONDdata+1D0]; fries T6,T7
 B4B30:	7F080000
		
	B52E0	7F0807B0
		???	fries: V0,T6,T7,T8,T9,F12
		A0->BONDdata+3D0, A1->BONDdata+3D4, A2->BONDdata+3D8, (float) A3->BONDdata+3DC
	B5310	7F0807E0
		fries: V0,V1,T0,T1,T2,T3,T4,T6,T7,T8,T9,F4,F6,F8,F12
	B5388	7F080858	fade to F14 over F12 seconds
		redirect to 7F0807E0; fries: V0,V1,A1,A2,A3,T0,T1,T2,T3,T4,T6,T7,T8,T9,F4,F6,F8,F12
		sets V0=BONDdata, A1=BONDdata+3D0, A2=BONDdata+3D4, A3=BONDdata+3D8,SP+10=F14
	B53BC	7F08088C	V0= TRUE if fade to black complete [BONDdata+3E4 < 0]; fries T6,F4,F6
		7F0808BC
		
	B5540	7F080A10	set cur. player fade; F12=timer (ms), F14=final level (1.00=100%)
		7F080A80	update cur. player fade until invisible; F16=player invisible (120.00=100%)
	
	B64A4	7F081974	player motion and view interface
 B6B30:	7F082000
	B8AF8	7F083FC8
 B8B30:	7F084000
	B8E90	7F084360
	B9178	7F084648
		??? - player related
 BAB30:	7F086000
		7F086990
		
		7F086BF8
		7F086C1C
	BB770	7F086C40	V0= viewport width for current player
	BB7F4	7F086CC4	V0= viewport ulx for current player
	BB854	7F086D24	V0= viewport height for current player
	BB968	7F086E38	V0= viewport uly for current player
	BBACC	7F086F9C
		???
		resets player's options, I think...
	BC114	7F0875E4
		
 BCB30:	7F088000
 
	BD418	7F0888E8	multiplayer respawn handler
		uses TLB pointer table at 80055290
			7F088BE8	intro type 0: spawn
			7F088BF0	intro type 1: weapon
			7F088C30	intro type 2: ammo
			7F088C58	intro type 3: intro swirly
			7F088C60	intro type 4: intro animation
			7F088C68	intro type 5: hand/cuff
			7F088C70	intro type 6: intro camera
	BD808	7F088CD8
	BDD38	7F089208
		??? - multiplayer interface?
		7F0892B0-7F089328 handles darkening the viewport
		die and respawn in multiplayer, at least in part (the later part)
	BE1F0	7F0896C0	writes stan tiles from 80079DA0/A4 in yellow to A0
		uses 7F0B3024 for output
	BE248	7F089718
	BE29C	7F08976C
		F12->??? [800364CC]; fries: AT
	BE2A8	7F089778
		F0=A0+74: ???
	BE2B0	7F089780
		F0=???; fries F4,F6,F8,F10
		accepts: A0=p->BONDdata
	BE2C8	7F089798	V0= p->cur. player's 8006 position data; fries T6 (T6=p->BONDdata)
	BE2D8	7F0897A8	kills current player [debug: bond die]
		7F0898E8
	BE44C	7F08991C
		??? - used in allocating damage and kill ownership (co-op patch)
		7F089E4C
	BE9D4	7F089EA4
		V0= TRUE if [BONDdata+F4]>=0; fries T6,T7
	BE9EC	7F089EBC
		V0= TRUE if [BONDdata+F8]>0; fries T6,T7
	BEA04	7F089ED4
		F0= [BONDdata+19C]; fries T6
	BEA14	7F089EE4	F0= cur.player's horizontal rotation in degrees; fries AT,T6,F4,F6,F8,F10
		uses 800552B4: 2Pi	[40C90FDB]
	BEA40	7F089F10	F0= cur. player's vertical rotation in degrees; fries AT,T6,F4,F6,F8,F10
		uses 800552B8: 2Pi	[40C90FDB]
	BEA68	7F089F38
		V0= [BONDdata + 0xD0]; fry T6 (cur. player data)
	BEA78	7F089F48	A0->invincibility flag [BONDdata + 0x12B6]; fry T6
	BEA88	7F089F58	V0= invincibility flag [BONDdata + 0x12B6]; fry T6
	BEA98	7F089F68	A0->invisible to guards flag [800364C4]
	BEAA4	7F089F74	V0= invisible to guards flag [800364C4]
	BEAB0	7F089F80	A0->player object collisions (Bond Phase) [800364C8]
	BEABC	7F089F8C	V0= player object collisions [800364C8]
	BEAC8	7F089F98	V0= cur. player's room; fry AT,A0,V1,T6,T7 (cur. tile)
	BEB04	7F089FD4	V0= p->cur.player's position; fries V1,T6
		uses value at BONDdata+4 if BONDdata+0 is 1
		otherwise, uses BONDdata+0x4B4
 BEB30:	7F08A000
	BEB30	7F08A000
	BEB5C	7F08A02C

	BEE1C	7F08A2EC	F0= cur.player's displayable health total [BONDdata+EC]
	BEE2C	7F08A2FC	F0= cur.player's displayable body armour total [BONDdata+E0]
	BEE3C	7F08A30C	add F12 amount of body armour to cur.player
			accepts: F12= total BA
	BEE60	7F08A330	resets intro camera and message dialogs for cur.player
	BEEB0	7F08A380	unset flags A0 in BONDdata+11D8
			accepts: A0=flags
	BEECC	7F08A39C	set flags A0 in BONDdata+11D8
			accepts: A0=flags
	BEEE4	7F08A3B4
		A0->800368A4, A1->800368A0; fries AT
	BEEF8	7F08A3C8	display string A0 in lower-left corner; A0=p->text
		7F08A4E4
		7F08A5FC
		7F08A900
		7F08A928
		7F08A944
	BF48C	7F08A95C	display string A0 at top of screen; A0=p->text
		7F08A9F8
		7F08AAE8
		7F08B0F0
	
	C0AE8	7F08BFB8
		V0= 80079A20
	C0AF4	7F08BFC4	trigger explosions around players; A0=delay (sec)
		fry AT,A0,T6,T7,T8
	C0B20	7F08BFF0	reinitialize player inventory
 C0B30:	7F08C000
		7F08C054
	C0CC4	7F08C194	add an additional weapon slot to player inventory?  guessing, honestly
	C0D2C	7F08C1FC	re-order inventory pointers based on ID code?
	C0D74	7F08C244	V0=p->next available weapon?
	C0DCC	7F08C29C	A0->all guns flag [cur. player data + 0x11EC]; fry T6
	C0DDC	7F08C2AC	V0= all guns flag [cur. player data + 0x11EC]; fry T6
	C0DEC	7F08C2BC	V0=p->inventory item A0 or NULL if not found; fries V1,A0,A1,T6,T7,T8
	C0E44	7F08C314	V0=TRUE if item A0 is in inventory; fries V1,A0,A1,T6,T7,T8
	C0E68	7F08C338	V0=p->inventory item A0 for hand A1 or NULL if not found
	C0ECC	7F08C39C	V0=TRUE if item A0 for hand A1 is in inventory
	C0EF0	7F08C3C0	V0=TRUE if item A0 (1-20) is available; fries AT,V1,A0,A1,T6,T7,T8
		returns TRUE when all guns in effect
	C0F3C	7F08C40C	V0=TRUE if item A0 for hand A1 is available
		solo:  V0=TRUE if if weapon A0's 00100000 flag set at stats+0x6C
		multi: V0=TRUE if item A0 for hand A1 is in inventory
	C0FB8	7F08C488	add item A0 to inventory
		I think this returns V0=1 if added item is selectable (<21)
	C113C	7F08C50C	Add doubles A0 (right) and A1 (left) to inventory
	C10A0	7F08C570
		???	tests doubles, I think...  remove a right-handed weapon?
	C114C	7F08C61C
		???	remove item A0 from inventory?
		7F08C724
		7F08C764
	C139C	7F08C86C	load next weapon(s) from inventory
	C1640	7F08CB10	load previous weapon(s) from inventory
		7F08CE70
		
	C1AB0	7F08CF80	V0=TRUE if possess Flag (item 58)
	C1AF0	7F08CFC0	V0=TRUE if Golden Gun (item 13) is in inventory
	C1B10	7F08CFE0	V0= TRUE if specific item in cur.player inventory; fries V1,A1,T6,T7,T8
		searches cur.player inventory for a pointer entry matching the obj.pos.data given
		accepts: A0=p->obj.pos.data
	C1B68	7F08D038
	C1C38	7F08D108	V0=p->inventory slot #A0 (not item #, but physical slot #)
	C1D4C	7F08D21C	V0=p->right or left weapon data if A0 matches either's item type; fries V1,T6,T7
	C1D8C	7F08D25C	p->special text for item A0 or NULL
	C1DD8	7F08D2A8	V0=item# for inventory slot #A0 (?)
	C1E70	7F08D340	V0=p->short watch text for inventory slot A0, handling special text overrides
		7F08D434
		
		7F08D5C8
		
		7F08D6BC
		
		7F08D7B0
		7F08D7D8
		7F08D800
		7F08D828
		7F08D850
		7F08D878
		
		7F08D8C0
		7F08D8D0
		7F08D8E0
		
	C248C	7F08D95C
		7F08D9A4
		
	C2638	7F08DB08	retrieves item codes of most used item for current player; fries: AT,V0,V1,A2,A3,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		accepts: A0=@right item, A1=@left item
		7F08DBB0
		
 C2B30:	7F08E000
 
	C46C0	7F08FB90	V0= pointer to path preset following path preset A0
		accepts: A0=p->path preset
		7F08FD1C
 
	C4930	7F08FE00	unconditional return
	C4938	7F08FE08
		A0-> [80036B88]; fries AT
	C4944	7F08FE14	initialize debug menu values
		accepts: A0=p->text, A1=p->positions, A2=p->groupings
	C49A4	7F08FE74	print debug menu to stdout; returns V0=A0
		accepts: A0=(unused)
 C4B30:	7F090000
	C4B3C	7F09000C
	C4CE0	7F0901B0	V0= debug menu: control mode [80036B70]
	C4CEC	7F0901BC	A0->debug menu: control mode [80036B70]; fry AT
	C4CF8	7F0901C8	up on debug menu
	C4D78	7F090248	down on debug menu
	C4DF0	7F0902C0	right on debug menu
	C4ECC	7F09039C	left on debug menu
		7F090414
		
	C4FC0	7F090490	display debug menu text on screen
		redirects to 7F08FE14: A0=80036E30 [p->text], A1=80036BC8 [p->pos], A2=80036BA4 [p->grouping]
	C4FF4	7F0904C4	debug "move view" option: triggers external camera
	C5038	7F090508	debug "stan view" option: 
	C507C	7F09054C	debug "bond view" option: triggers 1st person camera
	C50C0	7F090590	unconditional return	called when profile switched on
	C50C8	7F090598	unconditional return	called when profile switched off
	C50D0	7F0905A0	processor for debug menu; executables for debug menu follow
		accepts: A0=???, A1=???, A2=controller1 input, A3=???
		also handles image capture catches.
		uses TLB pointer table at 800556FC
	C52A8	7F090778	Debug Menu: move view
		redirects to 7F0904C4
	C52B8	7F090788	Debug Menu: stan view
		redirects to 7F090508
	C52C8	7F090798	Debug Menu: bond view
		redirects to 7F09054C
	C52D8	7F0907A8	Debug Menu: level		generic copy 80036B70->80036F70
	C52EC	7F0907BC	Debug Menu: region		generic copy 80036B70->80036F70
	C5300	7F0907D0	Debug Menu: scale		generic copy 80036B70->80036F70
	C5314	7F0907E4	Debug Menu: select anim	generic copy 80036B70->80036F70
	C5328	7F0907F8	Debug Menu: gun pos		generic copy 80036B70->80036F70
	C533C	7F09080C	Debug Menu: flash colour	generic copy 80036B70->80036F70
	C5350	7F090820	Debug Menu: hit colour	generic copy 80036B70->80036F70
	C5364	7F090834	Debug Menu: screen size	generic copy 80036B70->80036F70
	C5378	7F090848	Debug Menu: screen position	generic copy 80036B70->80036F70
	C538C	7F09085C	Debug Menu: music		generic copy 80036B70->80036F70
	C53A0	7F090870	Debug Menu: port close, port inf, port approx
		toggle 80036FD4
	C53B8	7F090888	Debug Menu: sfx		generic copy 80036B70->80036F70
	C53CC	7F09089C	Debug Menu: invincible
		calls 7F089F48: A0=(!7F089F58)
	C53E4	7F0908B4	Debug Menu: visible (to guards)
		calls 7F089F68: A0=(!7F089F74)
	C53FC	7F0908CC	Debug Menu: collisions
		calls 7F089F80: A0=(!7F089F8C)
	C5414	7F0908E4	Debug Menu: all guns
	C5464	7F090934	Debug Menu: max ammo
	C54C0	7F090990	Debug Menu: display speed
		toggle 80036F74, call 7000AF00 if not set
	C54E8	7F0909B8	Debug Menu: background
		toggle 80036F78
	C5500	7F0909D0	Debug Menu: props
		toggle 80036F7C
	C5518	7F0909E8	Debug Menu: stan hit
		toggle 80036F84
	C5530	7F090A00	Debug Menu: stan region
		toggle 80036F88
	C5548	7F090A18	Debug Menu: stan problems
		toggle 80036F8C
	C5560	7F090A30	Debug Menu: print man pos
		toggle 80036F90
	C5578	7F090A48	Debug Menu: test man pos
		toggle 80036FC8
	C5590	7F090A60	Debug Menu: play title
		calls 70006950: A0=stage 0x5A
	C55A0	7F090A70	Debug Menu: bond die
		redirects to 7F0897A8
	C55B0	7F090A80	Debug Menu: pr room loads
		toggle 80036F94
	C55C8	7F090A98	Debug Menu: show mem use
		redirect to 70005FF4
	C55D8	7F090AA8	Debug Menu: show mem bars
		redirect to 70006004
	C55E8	7F090AB8	Debug Menu: grab rgb
		sets a rgb image grab in 32bit mode
		1->80036FFC; calls 7000E2D0: A0=1; 70003C10
	C560C	7F090ADC	Debug Menu: grab jpeg
		sets a jpeg image grab in 32bit mode
		1->80037000; calls 7000E2D0: A0=1; 70003C10
	C5630	7F090B00	Debug Menu: grab task
		toggle 80036FC4
	C5648	7F090B18	Debug Menu: record ramrom
		redirects to 7F0C07BC: A0=0
	C5658	7F090B28	Debug Menu: record 1
		redirects to 7F0C07BC: A0=1
	C5668	7F090B38	Debug Menu: record 2
		redirects to 7F0C07BC: A0=2
	C5678	7F090B48	Debug Menu: record 3
		redirects to 7F0C07BC: A0=3
	C5688	7F090B58	Debug Menu: replay ramrom
		redirects to 7F0C08A8
	C5698	7F090B68	Debug Menu: save ramrom
		redirects to 7F0BFD60
	C56A8	7F090B78	Debug Menu: load ramrom
		redirects to 7F0BFE00
	C56B8	7F090B88	Debug Menu: auto y aim
		calls 7F07C570: A0=(!7F07C580)
	C56D0	7F090BA0	Debug Menu: auto x aim
		calls 7F07C658: A0=(!7F07C668)
	C56E8	7F090BB8	Debug Menu: 007
		toggle 80036FAC
	C5700	7F090BD0	Debug Menu: agent
		toggle 80036FB0
	C5718	7F090BE8	Debug Menu: all
		toggle 80036FB4
	C5730	7F090C00	Debug Menu: fast
		toggle 80036FCC
	C5748	7F090C18	Debug Menu: objectives
		toggle 80036FD0
	C5760	7F090C30	Debug Menu: show patrols
		calls 7F01F55C: A0=(!7F01F568)
	C5778	7F090C48	Debug Menu: intro
		redirects to 7F07A9B8: A0=3 (use intro camera mode 3 - solo rotating intro)
	C5788	7F090C58	Debug Menu: intro pos
		if 80036F64 not set, call 7F091618
	C57A8	7F090C78	Debug Menu: world pos
		if 80036F64 not set, call 7F09166C; else, if 7F089798 TRUE, uses pos at 80037004
	C5848	7F090D18	Debug Menu: gun key pos	generic copy 80036B70->80036F70
	C585C	7F090D2C	Debug Menu: chr num
		toggle 80036FB8
	C5874	7F090D44	Debug Menu: vis cvg (line mode)
		toggle 80036FA8
	C588C	7F090D5C	Debug Menu: joy2 sky edit
		toggle 80036F98
	C58A4	7F090D74	Debug Menu: joy2 hits edit
		toggle 80036F9C
	C58BC	7F090D8C	Debug Menu: joy2 detail edit
		toggle 80036FA0
	C58D4	7F090DA4	Debug Menu: explosion info
		toggle 80036FA4
	C58EC	7F090DBC	Debug Menu: magic fog	generic copy 80036B70->80036F70
	C5900	7F090DD0	Debug Menu: fog		generic copy 80036B70->80036F70
	C5914	7F090DE4	Debug Menu: gun watch pos
		toggle 80036FBC
	C592C	7F090DFC	Debug Menu: room blocks
		redirects to 7F03E698
	C593C	7F090E0C	Debug Menu: profile
		toggle 80036FC0
	C5974	7F090E44	Debug Menu: obj load
		redirects to 7F001258
	C5984	7F090E54	Debug Menu: weapon load
		redirects to 7F00140C
	C5994	7F090E64	Debug Menu: intro edit	generic copy 80036B70->80036F70
	C59A4	7F090E74	Debug Menu: return; used for NULL options
		uses TLB pointer table at 80055830; all point to 7F090EB0
	C5A2C	7F090EFC	V0= render flag (0=raster only) [80036F64]
	C5A38	7F090F08	V0= control mode type [80036F68]
	C5A44	7F090F14	V0= control mode [80036F6C]; subcatagory for control mode type
	C5A50	7F090F20	copy [80036F70] -> 80036F6C; fry AT,T6 ([80036F70])
	C5A64	7F090F34	V0= display speed flag [80036F74]
	C5A70	7F090F40	V0= draw background flag [80036F78]
	C5A7C	7F090F4C	V0= draw objects flag [80036F7C]
	C5A88	7F090F58	V0= stan hit debugger flag [80036F84]
	C5A94	7F090F64	V0= stan region debugger flag [80036F88]
	C5AA0	7F090F70	V0= stan problems debugger flag [80036F8C]
	C5AAC	7F090F7C	V0= print man pos debugger flag [80036F90]
	C5AB8	7F090F88	V0= test man pos debugger flag [80036FC8]
	C5AC4	7F090F94	A0->test man pos debugger flag [80036FC8]; fry AT
	C5AD0	7F090FA0	V0= joy2 sky edit flag [80036F98]
	C5ADC	7F090FAC	V0= joy2 hits edit flag [80036F9C]
	C5AE8	7F090FB8	V0= joy2 detail edit flag [80036FA0]
	C5AF4	7F090FC4	V0= explosion info flag [80036FA4]
	C5B00	7F090FD0	V0= print room loads flag [80036F94]
	C5B0C	7F090FDC	V0= line mode flag [80036FA8]
	C5B18	7F090FE8	A0->line mode flag [80036FA8]; fry AT
	C5B24	7F090FF4	V0= 007 debugger flag [80036FAC]
	C5B30	7F091000	V0= agent debugger flag [80036FB0]
	C5B3C	7F09100C	V0= all debugger flag [80036FB4]
	C5B48	7F091018	V0= turbo mode flag [80036FCC]
	C5B54	7F091024	A0->turbo mode flag [80036FCC]; fry AT
	C5B60	7F091030	V0= objectives debugger flag [80036FD0]
		forces all objectives complete
	C5B6C	7F09103C	V0= port close, inf, approx debugger flag [80036FD4]
	C5B78	7F091048	V0= character number debugger flag [80036FB8]
	C5B84	7F091054	V0= gun watch pos flag (movable models in watch) [80036FBC]
	C5B90	7F091060	V0= profile debugger flag [80036FC0]
	C5B9C	7F09106C	V0= grab task debugger flag [80036FC4]
		7F091080
		
		7F0915BC
		
	C6148	7F091618	debug "intro pos" handler; appears to do nothing...
		calls 7F089FD4, 7F089EE4 for x pos and rot., converts measure
	C619C	7F09166C
	C6224	7F0916F4	initialize floating camera position (80037014) to cur.player's location
	C6270	7F091740
	C62AC	7F09177C	tests if button code entered and activates cheat
		7F09193C
		
	C658C	7F091A5C	V0=1 if A0=0x1C - last applicable gameplay cheat#; fry AT
	C65A8	7F091A78	V0=1 if cheat# A0 usable MP; fry AT,T6,T7,T8
	C65DC	7F091AAC	tests and reroutes cheat# A0 to activation routine
	C6694	7F091B64	activated cheat processor; all below are linked
		C6740	7F091C10	activate cheat1: all characters MP
		C6750	7F091C20	activate cheat2: Invincibility
		C6780	7F091C50	activate cheat3: All Guns
		C67B0	7F091C80	activate cheat4: Max Ammo
		C67D0	7F091CA0	activate cheat6: Deactivate Invincibility (Multi)
		C6858	7F091D28	activate cheat7: Line Mode
		C6868	7F091D38	activate cheat8: Super 2x Health
		C68E8	7F091DB8	activate cheat9: Super 2x Body Armor
		C695C	7F091E2C	activate cheat10: Invisibility
		C698C	7F091E5C	activate cheat11: Infinite Ammo
		C69A4	7F091E74	activate cheat12: DK Mode
		C69C4	7F091E94	activate cheat13: Extra Weapons
		C6A8C	7F091F5C	activate cheat14: Tiny Bond
		C6B0C	7F091FDC	activate cheat15: Paintball Mode
		C6B24	7F091FF4	activate cheat16: Super x10 Health
 C6B30:	7F092000
		C6B98	7F092068	activate cheat17: Magnum
		C6BC8	7F092098	activate cheat18: Laser
		C6BE4	7F0920B4	activate cheat19: Golden Gun
		C6C14	7F0920E4	activate cheat20: Silver PP7
		C6C44	7F092114	activate cheat21: Gold PP7
		C6C74	7F092144	activate cheat22: Invisibility (Multi)
		C6C90	7F092160	activate cheat24: Turbo Mode
		C6CC0	7F092190	activate cheat25: ManPos position debugger
		C6CE0	7F0921B0	activate cheat26: Fast Animation
		C6D2C	7F0921FC	activate cheat27: Slow Animation
		C6D78	7F092248	activate cheat29: x2 R. Launcher
		C6DA8	7F092278	activate cheat30: x2 G. Launcher
		C6DD8	7F0922A8	activate cheat31: x2 RC-P90
		C6E08	7F0922D8	activate cheat32: x2 Throwing Knives
		C6E38	7F092308	activate cheat33: x2 Hunting Knives
		C6E54	7F092324	activate cheat34: x2 Laser
		C6E70	7F092340	activate cheat35-54: Unlock Cheat #
		C6EB0	7F092380	activate cheat55-74: Unlock Stage #
			7F092428	default
	C6F68	7F092438	Handles cheat deactivation
		C7008	7F0924D8	deactivate cheat2: Invincibility
		C7038	7F092508	deactivate cheat3: All Guns
		C7068	7F092538	deactivate cheat6: Line Mode
		C7078	7F092548	deactivate cheat9: Invisibility
		C70A8	7F092578	deactivate cheat10: Infinite Ammo
		C70C0	7F092590	deactivate cheat11: DK Mode
		C70E0	7F0925B0	deactivate cheat13: Tiny Bond
		C7160	7F092630	deactivate cheat14: Paintball Mode
		C7178	7F092648	deactivate cheat21: Invisibility (Multi)
		C7198	7F092668	deactivate cheat22: Turbo Mode
		C71C8	7F092698	deactivate cheat23: ManPos position debugger
			7F0926B0	quit for deactivation routines and target for untogglable ones
	C71F0	7F0926C0	deactivate all active cheats
	C72A4	7F092774	V0= p->text for cheat A0 or "NO NAME" otherwise; fries A0,V1,T0,T6,T7,T8,T9
		redirects to 7F0C1DD8
	C72EC	7F0927BC	V0= TRUE if cheat A0 activated for current player
	C7324	7F0927F4	set DK mode; A0=[0]off, [1]on
		7F092890

	C7F6C	7F09343C	called if texture 5E4 is applied to a surface: if mode 1, add DL branch (06) to 8003FCC0 to A0; else write equivalent to A0
		accepts: A0=p->DL, A1=mode (0-copy; 1-DL branch)
	C818C	7F09365C	called if texture 5E7 is applied to a surface: if mode 1, add DL branch (06) to 8003FD28 to A0; else write equivalent to A0
		accepts: A0=p->DL, A1=mode (0-copy; 1-DL branch)
		7F093880

 C8B30:	7F094000
		
		7F094298
		???
		accepts: F12=???
		7F094390
		
 CAB30:	7F096000
 
		7F0977B4	V0= TRUE if distance between [A0+28,2C] and [A1+28,2C] < 1.0
		accepts: A0=p->???, A1=p->???
		7F097818
 
 CCB30:	7F098000
		
	CD55C	7F098A2C	generates RDP display list for sky and water
 CEB30:	7F09A000
	CEE10	7F09A2E0	resets all player handicaps and perspectives to default (1.0); fries: AT,F0
		1.0->80079F4C, 1.0->80079F54, 1.0->80079FBC, 1.0->80079FC4, 1.0->8007A02C,  1.0->8007A034,  1.0->8007A09C,  1.0->8007A0A4
	CEE5C	7F09A32C	reset player data pointers; fries: AT,V0,V1,T6,T7,T8
		0->80079EE0-C, 0->8007A0B0-C, 0-3->8007A0C0-C
	CEEBC	7F09A38C	initializes player data pointers and constructs viewports
		accepts: A0=#players
	CEF94	7F09A464	V0= # players; fries V0,V1,T6,T7,T8,T9
	CEFEC	7F09A4BC	initialize player A0's BONDdata
		accepts: A0=player #
	CFC3C	7F09B10C	sets current player to player A0=0-3; sets data at 8007A0B0-B8
		accepts: A0=player #
	CFC80	7F09B150	V0= cur player #
	CFC8C	7F09B15C	V0= cur.player#
	CFD0C	7F09B1DC	set current player screen width (A0) and height (A1) [BONDdata+7F0/2]; fries V0,T6,T7
		accepts: A0=screen width, A1=screen height
	CFD28	7F09B1F8	set current player viewport width A0 & height A1 [BONDdata+7F4/6]; fries V0,T6,T7
	CFD44	7F09B214	F12-> watch menu current size [BONDdata+11D0]; fries T6
	CFD54	7F09B224	F12-> [BONDdata+11D4]; fries T6
	CFD64	7F09B234	F0= watch menu current size [BONDdata+11D0]; fries T6
	CFD74	7F09B244	V0= object model corresponding to item A0 (0-20); fries AT,V1,T6
		Tests if flag (0x58) used, and manually sets model
		Otherwise, redirects into 7F09B264
	CFD94	7F09B264	V0= object model corresponding to item A0 (0-20); fries AT,V1,T6
		uses TLB pointer table at 8005762C
		7F09B284	02: 0BA
		7F09B28C	04: 0BF
		7F09B294	07: 0C1
		7F09B29C	08: 0B8
		7F09B2A4	09: 0C3
		7F09B2AC	0A: 0BD
		7F09B2B4	0C: 0C2
		7F09B2BC	0D: 0BC
		7F09B2C4	0E: 0C5
		7F09B2CC	0F: 0C0
		7F09B2D4	18: 0B9
		7F09B2DC	1A: 0C4
		7F09B2E4	1D: 0C7
		7F09B2EC	1C: 0C8
		7F09B2F4	1B: 0C9
		7F09B2FC	12: 0BE
		7F09B304	16: 0BB
		7F09B30C	11: 0D2
		7F09B314	0B: 0CE
		7F09B31C	06: 0CD
		7F09B324	05: 0CC
		7F09B32C	03: 0D1
		7F09B334	10: 0CF
		7F09B33C	19: 0D3
		7F09B344	13: 0D0
		7F09B34C	14: 0BF
		7F09B354	15: 0BF
		7F09B35C	unused: 14D
		7F09B360	default: V0=V1
	CFE98	7F09B368
		??? - accepts hand A0 (0-R:1-L); redirects to 7F0521E8 w/ A0=p->player's GUARDdata, A1=hand
		7F09B398
		
	D0130	7F09B600
		[7F09B6C4]	loop to calculate the file checksums
	D0270	7F09B740
	D02B8	7F09B788
	D02D0	7F09B7A0	unconditional return
	D02D8	7F09B7A8
	D0314	7F09B7E4
	D0350	7F09B820
	D05F4	7F09BAC4
	
 D0B30:	7F09C000
 
	D0D80	7F09C250	generates explosions and smoke at location
		accepts: A0=p->source object or NULL, A1=p->positions, A2=p->tile, A3=explosion type, SP+10=force to ground, SP+14=owner's player#, SP+18=p->room# list, SP+1C=(sets object loaded flag)
	D12DC	7F09C7AC
		6->80040170, 6->80040174; fries AT,V0
		7F09C7C4
		
		7F09C9D8
		??? - sets up subsequent explosion
		7F09CEE8
		
		7F09D5A0
		??? - display explosion animation A0
		7F09D82C
		7F09DDA4
		??? - displays or propagates smoke
 D2B30:	7F09E000
	D3230	7F09E700	generates smoke of type A2 in room A3, tile A1 at given cartegian point A0
		accepts: A0=p->xyz floats, A1=p->tile, A2=smoke type, A3=room#
		7F09E8AC
		7F09EF9C
		7F09F03C
	D3D84	7F09F254	generate bit of shrapnel
		accepts: A0=p->(float)xyz pos., A1=(float) distance, A2=(float) horz.velocity, A3=(float) vert.velocity, SP+10=(float) size
	D486C	7F09FD3C
 D4B30:	7F0A0000
	D4B64	7F0A0034	display shrapnel
	D4DAC	7F0A027C	generate scorch marks
	D55E4	7F0A0AB4	display scorch marks
		7F0A0C74
		7F0A0CCC
		7F0A0D90
		7F0A0E98
	D5BBC	7F0A108C	generate bullet impact
	D65C4	7F0A1A94	display bullet impacts
		7F0A1D78
 
 D6B30:	7F0A2000
 
		7F0A2C44
 
	D7A60	7F0A2F30
			accepts: A0=, A1=, A2=placement (-1:health,0,1:armour), A3=(float) armour
		7F0A3330
 
	D7F28	7F0A33F8	generates A1 vertices in buffer A0 with gradient A2
		accepts: A0=p->vertex buffer, A1=#vertices, A2=(float) gradation, A3=mode
		mode nonzero initializes vertices to 0001.0000.0000.0000.0000.0000.00.2C.00.B0
	D84A8	7F0A3978	extends quad or pent (A3) w/ vertices at A1 into display list A0; V0=new DL
		accepts: A0=p->display list, A1=p->vertices, A2=(unused), A3=mode (0:quad, 1:pentagon)
	D85E8	7F0A3AB8	set vertices in A0 for quad (SP+14 + A1,SP+18 + A2),(SP+14 + A1 + A3,SP+18 + A2 + SP+10), RGBA 207020F0
		accepts: A0=p->vertex buffer, A1=xoff, A2=yoff, A3=dx, SP+10=dy, SP+14=ulx, SP+18=uly
	D8670	7F0A3B40	extends quad w/ vertices at A1 into display list A0; V0=new DL
		accepts: A0=p->display list, A1=p->vertices
		vertices should follow the pattern (0,1,2), (1,2,3)
		7F0A3B70
 
 D8B30:	7F0A4000
 
		7F0A4824
	D9398	[7F0A4868]	initialize watch menu at start of stage; part of larger routine
		[7F0A4918]	initialize difficulty multipliers
		7F0A4A98
		7F0A4B40
		7F0A4D74
	D98F0	7F0A4DC0	V0= cur.player's control type [BONDdata+2A58]; fries T6
	D9900	7F0A4DD0	set cur.player's control style to A0 [BONDdata+2A58]; fries V0,V1,T0,T1,T2,T3,T4,T6,T7,T8,T9,F4,F6
	D9968	7F0A4E38	V0= cur.player's look up/down setting [80040A84]
	D9974	7F0A4E44	A0->cur.player's look up/down setting; fry AT
	D9980	7F0A4E50	V0= cur.player's auto-aim control setting [80040A90]
	D998C	7F0A4E5C	A0->cur.player's auto-aim control setting; fry AT
	D9998	7F0A4E68	V0= cur.player's look-ahead setting [80040AB4]
	D99A4	7F0A4E74	A0->cur.player's look-ahead setting; fry AT
	D99B0	7F0A4E80	V0= cur.player's aim control setting [80040A9C]
	D99BC	7F0A4E8C	A0->cur.player's aim control setting; fry AT
	D99C8	7F0A4E98	V0= cur.player's sight on-screen setting [80040AA8]
	D99D4	7F0A4EA4	A0->cur.player's sight on-screen setting; fry AT
	D99E0	7F0A4EB0	V0= cur.player's ammo on-screen setting [80040AC0]
	D99EC	7F0A4EBC	A0->cur.player's ammo on-screen setting; fry AT
	D99F8	7F0A4EC8	V0= cur.player's screen setting [80040ACC]
	D9A04	7F0A4ED4	A0->cur.player's screen setting; fry AT
	D9A10	7F0A4EE0	V0=screen ratio [80040AD8]
	D9A1C	7F0A4EEC	A0->screen ratio; fry AT
		7F0A4EF8
	D9A74	7F0A4F44	0->highlighted setting selected register [800409A8]; fry AT
	D9A80	7F0A4F50	V0= TRUE if holding at least 0x2E left on control stick
		calls 7000C0EC
	D9AA4	7F0A4F74	V0= TRUE if holding at least 0x2E right on control stick
		calls 7000C0EC
	D9AC8	7F0A4F98	V0= TRUE if left/right on control stick enabled [80040ADC]
	D9AD4	7F0A4FA4	disable control stick input [0->80040ADC]; fry AT
	D9AE0	7F0A4FB0	V0= TRUE if pressed left on control stick (0x2E)
		uses 80040ADC to detect if stick pressed
	D9B1C	7F0A4FEC	V0= TRUE if pressed right on control stick (0x2E)
		uses 80040ADC to detect if stick pressed
	D9B58	7F0A5028	V0= TRUE if holding at least 0x2E up on control stick
		fries: V1,A0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
	D9B7C	7F0A504C	V0= TRUE if holding at least 0x2E down on control stick
		fries: V1,A0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
	D9BA0	7F0A5070	V0= TRUE if up/down on control stick enabled [80040AE0]
	D9BAC	7F0A507C	disable control stick input [0->80040AE0]
	D9BB8	7F0A5088	V0= TRUE if pressed up on control stick (0x2E)
		uses 80040AE0 to detect if stick pressed
	D9BF4	7F0A50C4	V0= TRUE if pressed down on control stick (0x2E)
		uses 80040AE0 to detect if stick pressed
	D9C30	7F0A5100	V0= TRUE if holding at least 0x10 up on control stick
	D9C54	7F0A5124	V0= TRUE if holding at least 0x10 down on control stick
	D9C78	7F0A5148	V0= TRUE if control stick input enabled [80040AE4]
	D9C84	7F0A5154	disable control stick input [0->80040AE4]; fry AT
	D9C90	7F0A5160	V0= TRUE if pressed up on control stick (0x10)
	D9CCC	7F0A519C	V0= TRUE if pressed down on control stick (0x10)
	D9D08	7F0A51D8	sets watch static effect
		activates line draw effect [0x80->80040B04]
		play sound effect 0EC: watch static
	D9D40	7F0A5210	switch solo watch page
	D9D9C	7F0A526C	page advance f/ main page of watch menu
	D9F08	7F0A53D8	page advance f/ inventory page of watch menu
	DA034	7F0A5504	page advance f/ beta objectives page of watch menu (removed)
	DA0F4	7F0A55C4	page advance f/ control page of watch menu
	DA1D4	7F0A56A4	page advance f/ options page of watch menu
	DA2B4	7F0A5784	page advance f/ objectives/briefing page of watch menu
	DA390	7F0A5860	advance up/down on "controls::control style" submenu of watch menu - tests +/c-up, then +/c-down
	DA430	7F0A5900	advance up/down on "controls::controller" submenu of watch menu - tests +/c-up, then +/c-down
	DA4C8	7F0A5998	advance up/down on selected "options" submenu of watch menu - tests +/c-up, then +/c-down
	DA594	7F0A5A64	advance up/down on "options::music" submenu of watch menu - tests +/c-up, then +/c-down
	DA624	7F0A5AF4	advance up/down on "options::effects" submenu of watch menu - tests +/c-up, then +/c-down
	DA6B0	7F0A5B80	advance up/down on "inventory" submenu of watch menu - tests +/c-up, then +/c-down
 DAB30:	7F0A6000
	DAC4C	7F0A611C	advance up/down through "control style" submenu entries of watch menu - tests +/c-up, then +/c-down
	DB148	7F0A6618	advance up/down from "background" submenu of watch menu - tests +/c-up, then +/c-down
	DB1D0	7F0A66A0	advance up/down from "M briefing" submenu of watch menu - tests +/c-up, then +/c-down
	DB25C	7F0A672C	advance up/down from "Q branch" submenu of watch menu - tests +/c-up, then +/c-down
	DB2EC	7F0A67BC	advance up/down from "Moneypenny" submenu of watch menu - tests +/c-up, then +/c-down
	DB37C	7F0A684C	advance up/down from "objectives" submenu of watch menu - tests +/c-up, then +/c-down
	DB408	7F0A68D8	moves bars drawn during solo watch static effect
	DB4D8	7F0A69A8	initialize watch menu when entering menu from play
	DB55C	7F0A6A2C	used in motion and position of controller in watch menu
		F0= value-2Pi if Pi < value
		F0= value+2Pi if value < -Pi
		F0= F12 otherwise
		accepts: F12=value
	DB5B0	7F0A6A80	solo watch menu interface and behaviour
		[7F0A6DE4]
		uses TLB pointer table at 800584CC
			7F0A6E04	page advance f/ main page of watch menu; redirects to 7F0A526C
			7F0A6E14	page advance f/ controls page of watch menu; redirects to 7F0A55C4
				calls 7F0A5860 if control style selected
				calls 7F0A5900 if controller selected
			7F0A6E60	page advance f/ options page of watch menu; 
				selects options page selection routines using TLB table at 800584E0
				7F0A6E88	option 0: 7F0A5A64	music bar
				7F0A6E98	option 1: 7F0A5AF4	effects bar
				7F0A6EA8	options 2,3,4,5,6,7,8,9: 7F0A5998
				7F0A6EB0	default
			7F0A6EC0	page advance f/ objectives/briefing page of watch menu; redirects to 7F0A5784
			7F0A6ED0	page advance f/ inventory page of watch menu; redirects to 7F0A53D8
			7F0A6ED8	default: return
	DBA18	7F0A6EE8	sets scissor for 1pl viewport (ie: solo watch menu)
		accepts: A0=p->display list
			B7000000 00002000
			BA001402 00000000
			BA001701 00800000
			ED000000 ~video2.txtClipH | ~video2.txtClipW
			BA001001 00000000
			BA000E02 00000000
			BA001102 00000000
			BA001301 00080000
			BA000C02 00002000
			BA000903 00000C00
			FCFFFFFF FFFE793C
			BA000801 00000000
			B9000002 00000000
			B900031D 0F0A4000
			BA000602 00000000
	DBBDC	7F0A70AC	sets box colors for solo watch page A0 in vertex buffer A1
		accepts: A0=selected page, A1=p->vertices [BONDdata+1878]
	DBC7C	7F0A714C	displays watch and HUD on solo watch menu
		accepts: A0=p->display list, A1=p->matrix, A2=cur.player source (TRUE/FALSE)
	DC2D8	7F0A77A8	redirects to 7F0A714C: A2=1
		accepts: A0=p->display list, A1=p->matrix
	DC2F8	7F0A77C8	sets abort: confirm/cancel to DL A0 for solo watch menu page 0
		accepts: A0=p->display list
	DC748	7F0A7C18	sets mission status to DL A0 for solo watch menu page 0
		accepts: A0=p->display list
	DC8EC	7F0A7DBC	V0=A0; removed solo watch page 0 print routine
		accepts: A0=p->display list
	DC8F4	7F0A7DC4	set watch name text to DL A0 for solo watch menu page 0
		accepts: A0=p->display list
	DC9D8	7F0A7EA8	solo watch page 0 constructor
		accepts: A0=p->display list
 DCB30:	7F0A8000
	DCE3C	7F0A830C	display solo watch page 0: Main Page; V0=p->new DL
		accepts: A0=p->display list, A1=p->matrix
		calls: 7F0A714C: A0, A1, A2=0; if transition not running, 7F0A7DC4: A0=p->DL; 7F0A7C18: A0=p->DL; 7F0A7DBC: A0=p->DL; 7F0A7EA8: A0=p->DL
	DCEA8	7F0A8378	interface for solo watch page 1: Inventory
	DCF54	7F0A8424	display solo watch page 1: Inventory
		accepts: A0=p->display list, A1=p->matrix
		7F0A8B10
		7F0A8D40
		7F0A8ED0
		7F0A8FEC
	DDCB0	7F0A9180
		redirect to 700091C8
		7F0A91A0
		7F0A91C8
	DDE88	7F0A9358	V0= [80040B58]
		7F0A9364
	DDEC8	7F0A9398	display text on solo watch menus
		accepts: A0=p->display list, A1=x position, A2=y position, A3=p->text,
			SP+10=text colour, SP+14=[0], SP+18=[-1], SP+1C=[1], SP+20=[0],
			SP+24=background colour, SP+28=[0]
		7F0A95C4
		7F0A95E8
		7F0A9610
		7F0A9684
		7F0A97D0
	DE5E8	7F0A9AB8	displays controller layout for selected setting
 DEB30:	7F0AA000
		7F0AA7C8
		7F0AADC0
	DFFBC	7F0AB48C	0-> solo watch controls page selection [80040998]; fry AT
	DFFC8	7F0AB498	0-> solo watch options page selection [8004099C]; fry AT
	DFFD4	7F0AB4A4	0-> solo watch main page selection [800409A4]; fry AT
	DFFE0	7F0AB4B0	V0=A0
	DFFE8	7F0AB4B8	display text for solo watch page 2: Controls
	E02D4	7F0AB7A4	change setting to A1 for option A0 on solo watch menu options page
	E0308	7F0AB7D8	switch left/right option A0 (0-7) on solo watch options page
	E0438	7F0AB908	solo watch menu options page - options list and interface
		accepts: A0=p->display list target, A1=ypos, A2=setting#, A3=highlight mode (0-2)
	E074C	7F0ABC1C	solo watch menu options page - option list constructor and interface
		calls 7F0AB908, 7F0ACD98
	E092C	7F0ABDFC	display text for solo watch page 3: Options - slidebar constructor and interface
 E0B30:	7F0AC000
	E0C18	7F0AC0E8	V0= #newlines in string A0; fries V1,A0,A1
	E0C50	7F0AC120	V0= p->string following last newline; fries V1,A0,A1,T6
	E0C98	7F0AC168	display text for solo watch page 4: Briefing
		uses TLB pointer table at 80058570
		7F0AC3B8	solo watch briefing page 0: Background
		7F0AC400	solo watch briefing page 1: M Briefing
		7F0AC448	solo watch briefing page 2: Q Briefing
		7F0AC490	solo watch briefing page 3: Monneypenny
		7F0AC4D8	solo watch briefing page 4: objectives
		7F0AC9F4	default: return
	E1558	7F0ACA28	display current solo watch page text
		accepts: A0=p->DL, A1=???, A2=interface mode (0-off; 1-on)
	E16A0	7F0ACB70	unconditional return
	E16A8	7F0ACB78	-A0-> text spacing [80040E84]; fries AT,T6
	E16B8	7F0ACB88	A0-> orientation (nonzero=vertical) [80040E88]; fry AT
	E16C4	7F0ACB94	A0-> #spaces following wordwrap [80040E8C]; fry AT
	E16D0	7F0ACBA0	A0-> overlap correction [80040E90]; fry AT
	E16DC	7F0ACBAC	allocate and initialize font tables
	E18C8	7F0ACD98
		??? - microcode constructor used in watch menu; fries V1,A0,A1,A2,A3,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9
		accepts: A0=p->display list target
		returns: V0=p->final DL position
	E1A20	7F0ACEF0	set combiner: bayer, lod, perspective; fries A1,A2,A3,T0,T1,T6,T7,T8,T9
		accepts: A0=p->display list target
		returns: V0=p->final DL position
	E1A7C	7F0ACF4C	inserts black box DL to A0; draws to physical screen coordinates
		accepts: A0=p->display list, A1=ul x, A2=ul y, A3=lr x, SP+10=lr y
	E1B44	7F0AD014	inserts coloured box DL to A0; draws to physical screen coordinates
		accepts: A0=p->display list, A1=ul x, A2=ul y, A3=lr x, SP+10=lr y, SP+14=RGBA value for square
	E1C28	7F0AD0F8
		??? - microcode constructor used with fonts
	E25EC	7F0ADABC	display text; used by MP watch menu
		accepts: A0=p->display list target, A1=p->x position, A2=p->y position, A3=p->text,
			SP+10=p->2nd font table, SP+14=p->1st font table, 
			SP+18=font colour,
			SP+1C=clip width, SP+20=clip height, 
			SP+24=y offset, SP+28=x offset
		7F0ADDAC
 
 E2B30:	7F0AE000
 
	E321C	7F0AE6EC	display 2-tone text; used by MP watch menu
		accepts: A0=p->display list target, A1=p->x position, A2=p->y position, A3=p->text,
			SP+10=p->2nd font table, SP+14=p->1st font table, 
			SP+18=font foreground colour, SP+1C=font background colour, 
			SP+20=clip height, SP+24=clip width, 
			SP+28=y offset, SP+2C=x offset 
	E34BC	7F0AE98C	computes width and height of string A2 for cur. font set
		returns A0=height, A1=width of string
		accepts: A0=p->ret.height, A1=p->ret.width, A2=p->text, A3=p->2nd font table, SP+10=p->1st font table, SP+14=x offset?
	E3694	7F0AEB64	A2=text A1 fit to width A0
		accepts: A0=max width, A1=p->text, A2=@final text, A3=p->2nd font table, SP+10=p->1st font table
		7F0AEF0C
		7F0AEF20
# 
		7F0AEF30
		7F0AEF3C
	E3B10	7F0AEFE0
	E3B30	7F0AF000	V0= FALSE; removed actor animation routine
	E3B3C	7F0AF00C	generate debug.notice.list entry for stan_c_debug using data at 80040F40
	E3B68	7F0AF038	
	
	E40E8	7F0AF5B8
		???
		A0->8007B120, 1->80040FB0
		if "-stanlinelog", 1->80040FB4
	E4160	7F0AF630
		A0->SP+0	deleted routine
	E4168	7F0AF638
	
 E4B30:	7F0B0000
		
	E5444	7F0B0914
		???
		accepts: A0=p->???, A1=(float) xpos1, A2=(float) zpos1, A3=(float) xpos2, SP+10=(float) zpos2, SP+14=p->[function], SP+18=p->buffer
		
	E5714	7F0B0BE4
		???
		accepts: A0=p->???, A1=xpos1, A2=zpos1, A3=xpos2, SP+10=zpos2
		redirects to 7F0B0914: SP+10=[SP+10], SP+14=0, SP+18=0 (no jump or buffer)
	E5754	7F0B0C24
		???
		redirects to 7F0B0914: SP+10=[SP+10], SP+14=7F0B0C98, SP+18=SP+30
			buffer: B+0=[SP+14], B+4=0, B+8=[SP+1C], B+C=-1
		7F0B0C98
	E581C	7F0B0CEC
		redirect to 7F0B0C98
		7F0B0D0C
		7F0B0E24
		7F0B1410
		7F0B16C4
		7F0B1794
		7F0B17E4
		7F0B18B8
	E67F4	7F0B1CC4
		reset ???; fries AT
		0-> [8007B9E4], 0-> [8007B9E8], 0-> [800413BC]
	E6810	7F0B1CE0
		V0= [8007B9E4]
	E681C	7F0B1CEC
		V0= [8007B9E8]
	E6828	7F0B1CF8
	E690C	7F0B1DDC
		???
		accepts: A0=???,A1=(float) ???,A2=(float) ???,A3=???,SP+10=???,SP+14=???,SP+18=???,SP+1C=???
 E6B30:	7F0B2000
	E6C00	7F0B20D0
		???
		redirect to 7F0B1DDC: SP+10=0, SP+14=0, SP+18=0, SP+1C=0
		7F0B2110
		7F0B2194
 
 		7F0B2718
	E73E0	7F0B28B0
		???
	E7480	7F0B2950
		F12-> [80040F44], 1/F12-> [80040F48]; fries: AT,F4,F6
		7F0B2970
		F0=???, y elevation of position (A1,A2) on tile A0?
		accepts: A0=p->tile, A1=(float)xpos, A2=(float)zpos
	E775C	7F0B2C2C	copy tile A0's color as 24bit RGB to A3; fries V0,V1,A1,T3,T4,T5,T6,T7,T8,T9
		accepts: A0=p->tile, A1=xpos (unused), A2=zpos (unused), A3=p->target
		used by "print man pos"; likely nerfed
		7F0B2C78
	E7844	7F0B2D14
		F0=[SP+18]
		redirect to 7F0B2C78: A1=SP+18
	E7868	7F0B2D38	A0->SP+0, A1->SP+4, A2->SP+8
	E7878	7F0B2D48	V0=A0
	E7880	7F0B2D50	converts stan tile name string to integer values
		accepts: A0=p->tile name string, A1=@short integer value target, A2=@letter code target
		returns: V0=short integer part, values to targets; note A1 and A2 are overwritten, so ensure you can recover their values!
	E7988	7F0B2E58	V0= match for stan tile name at pointer A0
		accepts: A0=p->tile name string, SP+22=name numeral, SP+21=name letter code
	E7A30	7F0B2F00	redirect to 7F0B2E58: sends A0=A0, returns A0=p->hit
	E7A5C	7F0B2F2C	determines end of clipping file A0
		accepts: A0=p->stan tile list
	E7B08	7F0B2FD8	V0=room# at p->tile A0
	E7B10	7F0B2FE0	redirects to 7F0B4F9C: A0=room# from tile A0
		accepts: A0=p->tile
	E7B34	7F0B3004	redirect to 7F0B2D14
	E7B54	7F0B3024	removed: V0=A0, SP+4=A1, SP+8=A2
		accepts: A0=p->display list, A1=p->tile, A2=RGBA colour
	E7B64	7F0B3034	removed: V0=A0
		accepts: A0=p->display list
	E7B6C	7F0B303C	removed: V0=A0
		accepts: A0=p->display list
		7F0B3044
		
	E7C5C	7F0B312C	removed: V0=A0, A1->SP+4
		accepts: A0=p->display list, A1=??? (colour?)
	E7C68	7F0B3138
		
# 
	E82F0	7F0B37C0	generate debug.notice.list entry for bg_c_debug using data at 800413F0
	E831C	7F0B37EC
	E83E4	7F0B38B4
	E84EC	7F0B39BC
		accepts: A0=room#, A1=, A2=p->???, A3=
	E8634	7F0B3B04	0->room A0 + 3
		accepts: A0=room#
	E8650	7F0B3B20
		accepts: A0=room#
	E86F4	7F0B3BC4
	E873C	7F0B3C0C
	E87BC	7F0B3C8C
 E8B30:	7F0B4000
	E8B64	7F0B4034
	E8BB4	7F0B4084
	E8C04	7F0B40D4
	E8C54	7F0B4124
	E9310	7F0B47E0
	E9340	7F0B4810
	E9360	7F0B4830
	E936C	7F0B483C	F0= [800413F4]
	E9378	7F0B4848
	E93A8	7F0B4878	F0= [800413FC]
	E93B4	7F0B4884	camera modes 1-9 timers, among other things
		uses TLB at 80058C58
		7F0B4914	1,2,3,7,9
		7F0B491C	4,5,6,8,default
	E9580	7F0B4A50
		
	E9AE4	7F0B4FB4	write setscissor microcode command for current player viewport	;fries AT,V0,V1,A0,A1,A2,A3,T0,T2,T3,T4,T5,T6,T7,T8,T9,F0,F4,F6,F8,F10,F16,F18
		V0=p->display list
		redirects to 7F0B5058, using current player's viewport settings
		accepts: A0=p->display list target
		7F0B4FF4
		
	E9B88	7F0B5058	write setscissor microcode command for player viewport; fries AT,V0,V1,A0,A1,A2,A3,T0,T2,T3,T4,T5,T6,T7,T8,T9,F0,F4,F6,F8,F10,F16,F18
		V0=p->display list
		accepts: A0=p->display list, A1=viewport ulx, A2=viewport uly, A3=viewport lrx, SP+10=viewport lry
	E9C98	7F0B5168
		
	E9D38	7F0B5208
		accepts: A0=room#, A1=p->???
	E9FB8	7F0B5488
	EA058	7F0B5528
		accepts: A0=portal#, A1=(float)???, A2=p->buffer
	EA394	7F0B5864
		accepts: A0=portal#, A1=p->buffer
	EA644	7F0B5B14
	EA690	7F0B5B60
	EA70C	7F0B5BDC	V0=TRUE if A0 in line-of-sight with A1
		accepts: A0=p->floats, A1=p->floats
	EA7F0	7F0B5CC0
		accepts: A0=p->floats, A1=p->floats
	EA888	7F0B5D58	copies four floats from A1 to A0
		accepts: A0=p->target, A1=p->source
	EA8AC	7F0B5D7C
	EA910	7F0B5DE0
	EA974	7F0B5E44	V0=max #rooms [800442F4]
	EA980	7F0B5E50	V0=TRUE if room A0 loaded; fries T6
		uses 80041414 table + 0
	EA99C	7F0B5E6C
		V0=??? for room A0; fries T6
		uses 80041414 table + 1
		7F0B5E88
	EAA08	7F0B5ED8	generate loaded room string when set
	EAABC	7F0B5F8C
		redirect to 7F0CE7F0: A2=SP+18
		7F0B5FAC
 EAB30:	7F0B6000
		7F0B609C
 
	EAE44	7F0B6314
		accepts: A0=room#
	EAE98	7F0B6368
		???	uses joy2 detail edit flag
	EB0F4	7F0B65C4
 
 ECB30:	7F0B8000
 
	ECEA4	7F0B8374	???; push A0 onto 800448A8 table; V0=value written
		accepts: A0=value
	ECEE0	7F0B83B0	???; V0= value pulled from 800448A8 table
	ECF14	7F0B83E4	???; V0= value pulled from entry A0 in 800448A8 table
		accepts: A0=entry index
	ECF44	7F0B8414	global visibility parsing routine
		accepts: A0=p->command, A1=mode (0:ignore, 1:process)
		ED000	7F0B84D0	type 00	normal termination
		ED008	7F0B84D8	type 01	???
		ED028	7F0B84F8	type 02	???
		ED048	7F0B8518	type 03	???
		ED078	7F0B8548	type 04	???
		ED0A8	7F0B8578	type 05	???
		ED0D0	7F0B85A0	type 06	???
		ED100	7F0B85D0	type 14	add range of rooms capable of sight
		ED144	7F0B8614	type 1E	force globally visible
		ED184	7F0B8654	type 1F	add portal that views room
		ED1D8	7F0B86A8	type 22	append portal that views room
		ED2B8	7F0B8788	type 20	add visible room
		ED444	7F0B8914	type 21	begin new block
		ED244	7F0B8714	type 23	
		ED324	7F0B87F4	type 24	
		ED358	7F0B8828	type 25	
		ED3B4	7F0B8884	type 26	
		ED3E8	7F0B88B8	type 27	
		ED460	7F0B8930	type 50	
		ED49C	7F0B896C	type 51	
		ED484	7F0B8954	type 52	return and reset flag
		ED4C0	7F0B8990	type 5A	
		ED4F8	7F0B89C8	type 5B	change mode
		ED510	7F0B89E0	type 5C	return p->next command
		ED520	7F0B89F0	default	terminate (invalid types)
	ED554	7F0B8A24
		accepts: A0=, A1=
	ED59C	7F0B8A6C
	ED8A8	7F0B8D78
	ED924	7F0B8DF4
		accepts: A0=room#, A1=, A2=
	ED9C8	7F0B8E98
		accepts: A0=, A1=
	EDA2C	7F0B8EFC
		accepts: A0=room#, A1=, A2=
	EDB00	7F0B8FD0	V0= TRUE if room A1 is directly visible from room A0; fries V1,A0,A2,T6,T7
		accepts: A0=room#, A1=room#
	EDB70	7F0B9040
		accepts: A0=room#
	EDBBC	7F0B908C
	EDDE4	7F0B92B4
		accepts: A0=room#
	EDE68	7F0B9338
		accepts: A0=room#
	EE108	7F0B95D8	???; searches for room A0 in portal list, then does soemthing with matching room entry
		accepts: A0=room#
	EE1FC	7F0B96CC
		accepts: A0=portal index, A1=@buffer
	EE46C	7F0B993C
		accepts: A0=portal index
	EE4C0	7F0B9990	F0= portal A0's 7th byte converted to some wonky scale value
		accepts: A0=portal index
	EE544	7F0B9A14	V0= portal A0's 7th byte
		accepts: A0=portal index
	EE55C	7F0B9A2C	increment counter in portal A0's 7th byte
		accepts: A0=portal index
	EE5AC	7F0B9A7C	decrement counter in portal A0's 7th byte
		accepts: A0=portal index
	EE614	7F0B9AE4	V0= 0x1 flag in portal A0's 6th byte
		accepts: A0=portal index
	EE634	7F0B9B04	V0= 0x2 flag in portal A0's 6th byte
		accepts: A0=portal index
	EE654	7F0B9B24	set 0x2 flag in portal A0's 6th byte
		accepts: A0=portal index
	EE674	7F0B9B44	V0= ~0x2 flag in portal A0's 6th byte
		accepts: A0=portal index
	EE694	7F0B9B64	switch parent/child room numbers for portal A0
		accepts: A0=portal index
	EE6C4	7F0B9B94
		
	EE8EC	7F0B9DBC	set or unset (A1=0,1) 0x1 flag in portal A0's 6th byte; fries V0,T0,T1,T6,T7,T8,T9
		accepts: A0=portal index
	EE914	7F0B9DE4	removed: print current state of debug port; V0=A0, A1->SP+4, A2->SP+8
		accepts: A0=p->display list, A1=port#, A2=???
	EE924	7F0B9DF4	removed: tied to debug port; A0->SP+0
		accepts: A0=port# [800483CC]
	EE92C	7F0B9DFC	removed; A0->SP+0
	EE934	7F0B9E04
		accepts: A0=, A1=
	EEA44	7F0B9F14
		accepts: A0=, A1=, A2=
 EEB30:	7F0BA000
	EED9C	7F0BA26C
		accepts: A0=, A1=, A2=, A3=
	EEE04	7F0BA2D4
	EF0F0	7F0BA5C0
	EF170	7F0BA640
	EF250	7F0BA720	removed; A0->SP+0, A1->SP+4
	EF25C	7F0BA72C	V0= [80044DCC]
	EF268	7F0BA738	F0= [80044DC4]
	EF274	7F0BA744	F0= square of [80044DC4]
	EF288	7F0BA758	sets long enviroment data (A0) as current
		accepts: A0=p->enviroment data
	EF500	7F0BA9D0	sets short enviroment data (A0) as current
		accepts: A0=p->enviroment data
	EF58C	7F0BAA5C	A0->SP+0; deleted function, used at 7F0B479C
		accepts: A0=p->start of portal list
	EF594	7F0BAA64	locates and copies matching enviroment values for stage
	EF7D8	7F0BACA8	switch to secondary sky for stage using F12 for blend multiplier
		sets long enviroment entry before return
		accepts: F12=multplier for blend value
	EFBA0	7F0BB070	sets sky color and material in display list A0; returns V0=p->DL
		accepts: A0=p->DL
	EFDC8	7F0BB298	clears geometry fog flag if clouds enabled; returns V0=p->DL
		accepts: A0=p->DL
	EFDF8	7F0BB2C8
	EFEC8	7F0BB398	V0= p->near fog enviroment values [800825C4]
		7F0BB3A4	if sky present converts fog values; returns V0=0-2 for whatever reason
		accepts: A0=p->???(+18=float), A1=p->fog color target
# light fixtures
	F0000	7F0BB4D0	initialize light fixture tables
	F0054	7F0BB524	V0=index of current entry in light fixture table [80082660]
	F00CC	7F0BB59C	adds an entry in light fixture table [80082660]
		accepts: A0=p->DL
	F0130	7F0BB600	save DL endpoint pointer A0 to cur. entry in light fixture table [80082660]
		accepts: A0=p->DL
	F0160	7F0BB630	V0=TRUE if light fixture; V0=1 if image ID A0 matches 0C9, 0CB, 0CD, 0FC, 0FE, 0FF, 100, 1AC, 3D6, or 567
		accepts: A0=image ID#
	F01C4	7F0BB694	V0=p->vertex in room A1 denoted by entry A0
		accepts: A0=p->???, A1=room#
	F0224	7F0BB6F4
		??? - A1 is index in pointer table (0-4)
		uses TLB pointer table at 80058D80

 F0B30:	7F0BC000
 
		7F0BC530
 
		7F0BCA14	V0= p->entry A0 in table @8007FF8C + C
		7F0BCA34
# resource table management
	F15D0	7F0BCAA0	load resource table/data entry (A2,A3) to buffer A0 of size A1
		accepts: A0=p->rdram target, A1=size, A2=p->resource table entry, p->resource data entry
		uses 70005C1C to load from ROM; pipes through 7F0CE7F0 to decompress.
	F1664	7F0BCB34	load resource table/data entry (A2,A3) from Indy into allocated buffer A0 of size A1
		accepts: A0=p->allocated data, A1=remaining size of mem bank, A2=p->resource table entry, A3=p->resource data entry
	F1758	7F0BCC28	ob_c_debug: generate resource data filesize entries
	F17EC	7F0BCCBC	load resource index A0 into memory bank A3; redirect to 7F0BCE0C: A3&0xFF
		accepts: A0=index#, A1=mode, A2=do not update bank index (FALSE,TRUE), A3=bank
	F1814	7F0BCCE4	redirect to 7F0BCFE0
		accepts: A0=index#, A1=mode, A2=p->target, A3=size of buffer
	F1834	7F0BCD04	load resource named A0 to bank A3; redirects to 7F0BCE0C
		accepts: A0=p->string, A1=mode, A2=do not update bank index (FALSE,TRUE), A3=bank
	F1870	7F0BCD40	load resource named A0 to buffer A2 of size A3; redirects to 7F0BCFE0
		accepts: A0=p->string, A1=mode, A2=p->target, A3=size of buffer
	F18AC	7F0BCD7C	loads A3 bytes of BG file named A0 starting at A2 to rdram A1
		accepts: A0=p->string, A1=p->target, A2=offset, A3=size
	F193C	7F0BCE0C	load resource index A0 into memory bank A3
		accepts: A0=index#, A1=mode, A2=do not update bank index (FALSE,TRUE), A3=bank
	F1B10	7F0BCFE0	load resource index A0 to buffer A2 of size A3
		accepts: A0=index#, A1=mode, A2=p->target, A3=size of buffer
	F1C30	7F0BD100	V0= temp. remaining buffer for resource index A0
		accepts: A0=index
	F1C4C	7F0BD11C	V0= remaining buffer for resource index A0
		accepts: A0=index
	F1C68	7F0BD138	set remaining buffer size for resource entry A0, and if A3 TRUE update bank 4 for buffer A1 of size A2
		accepts: A0=index, A1=p->buffer, A2=remaining buffer size, A3=update TRUE/FALSE
	F1CB8	7F0BD188	V0=temporary buffer remaining value for resource named A0; same as res.data[index]+4
		accepts: A0=p->string
	F1CEC	7F0BD1BC	remove resource bank values matching or above bank A0; also eliminates bank 4 temp remaining values
		accepts: A0=bank
	F1D64	7F0BD234	remove resource bank values for banks 5 and 6; redirect to 7F0BD1BC: A0=5
	F1D84	7F0BD254	V0=index# in ROM table for string A0
		accepts: A0=p->name
		Iterates names in resource table for a match.  On a miss, searches Indy for file and appends a resource entry if found.
	F1DB4	7F0BD384	removed: A0->SP+0
		accepts: A0=resource index
	F1DBC	7F0BD38C	removed: calls 7F0BD384 for each resource entry index
	F1E14	7F0BD3E4	V0=# resource entries; possibly gutted routine
	F1E40	7F0BD410	V0= p->res.data.final; possibly gutted routine
# geometry memory management
	F1E90	7F0BD460	generate debug.notice.list entry for dyn_c_debug using current mgfx allocations
	F1FBC	7F0BD48C	set mgfx and mvtx allocations
		uses strings starting at 8005B68C
	F21A4	7F0BD674	???
		1->8008C254, V0=8008C230 + (@8008C250 -> offset)
	F21CC	7F0BD69C	V0=#microcode ops left in geometry buffer, starting at A0; fries T6,T7,T8,T9
		looks at bank @8008C250 in table 8008C234, subtracts p->DL A0, divides by 8
	F21F4	7F0BD6C4	allocates +A0 vertices in geometry memory [@8008C24C]; fries V0,A2,T6,T7
		geometry memory += (A0*0x10)
	F2210	7F0BD6E0	geometry memory += 0x40 [@8008C24C]; fries V0,A1,T6
	F2228	7F0BD6F8	allocates +A0 vertices in geometry memory [@8008C24C]; fries V0,A2,T6,T7
		geometry memory += (A0*0x10)
	F2244	7F0BD714	p->allocated space; fries V0,A2,T6,T7,T8
		allocates A0 space in geometry memory [8008C24C]
		7F0BD738
	F22A4	7F0BD774	removed "show mem use" debug routine: A0->SP+0
	F22AC	7F0BD77C	V0= #microcode commands that can span from A0 to end of chunk
		accepts: A0=p->display list target
		7F0BD7A4
	F22FC	7F0BD7CC	V0=strlen of A0, F12=ratio of remaining/used DL ops; fries V1,T6,T7,F0,F4
		note: probably incomplete.  Debug should have displayed F12 percentage of ASCII strings as bars...
		accepts: A0=p->string, A1=(float)#remaining DLops, A2=(float)#previous DL ops
	F2340	7F0BD810	"show mem bars": F12=percentage of used geometry memory
		accepts: A0=p->display list, acting as cur.pos. within geometry memory
# 
	F2420	7F0BD8F0	V0= pause [800483C0]
	F242C	7F0BD8FC	A0->pause [800483C0]; fries AT
	F2438	7F0BD908	lv_c_debug: load japanese font DLs to bank 6
	F24B4	7F0BD984	play random music track 2-3E
	F24F4	7F0BD9C4	play music track A0
		accepts: A0=track
	F251C	7F0BD9EC	play next music track (1-3E)
	F2568	7F0BDA38	play previous music track (3E-1)
	F25B4	7F0BDA84	play primary music track for stage A0
		accepts: A0=stage#
	F25E0	7F0BDAB0
		??? - involves selected cheat options
		calls necessary stuff for stage loading!
	F2A34	7F0BDF04	V0=cur.stage# [80048364]
	F2A40	7F0BDF10	???, V0=p->DL; used when port close, inf, approx flag set
		accepts: A0=p->display list
 F2B30:	7F0BE000
	F2E3C	7F0BE30C	???; generates display lists; tests stan hit flag
	F3400	7F0BE8D0	set settings based on difficulty - called constantly
	F36B8	7F0BEB88	run MP game, its scoring and time - involves selected cheat options
		recalls joy2 detail edit flag
	F4330	7F0BF800
	F4650	7F0BFB20	unload stage text and data
	F4728	7F0BFBF8	A0->player control lock [80048370]; fry AT
	F4734	7F0BFC04	V0=player control lock [80048370]
	F4740	7F0BFC10	V0= difficulty [80048384]
	F474C	7F0BFC1C	A0->difficulty; fry AT
	F4758	7F0BFC28	A0->MP time setting; fry AT
	F4764	7F0BFC34	A0->MP point setting; fry AT
	F4770	7F0BFC40	F0= current MP time (sec); fry AT
	F477C	7F0BFC4C	F0= current MP time (min); fry AT
	F4788	7F0BFC58	F0= stage time (sec); fry AT
	F4794	7F0BFC64	F0= power-on time (sec); fry AT
	F47A0	7F0BFC70	clear ramrom block, buffer, and heading addy; fry AT
	F47BC	7F0BFC8C	V0= TRUE if ramrom starting or loaded [80048474]
	F47C8	7F0BFC98	V0= currently recording ramrom [80048480]
	F47D4	7F0BFCA4	menu 0B interface: -active gameplay-
		V0= [8004847C]
	F47E0	7F0BFCB0	finalize ramrom on hardware
	F4890	7F0BFD60	save ramrom to devtool
	F4930	7F0BFE00	load ramrom from devtool
	F498C	7F0BFE5C	record player input as packet
		accepts: A0=p->controller input index, A1=index+1E4, A2=index+1E0
 F4B30:	7F0C0000
	F4BB0	7F0C0080	ramrom replay handler
	F4D98	7F0C0268	iterate ramrom entry, handling camera at end
	F4ED8	7F0C03A8	copy current in-game registers before playing ramrom
	F5024	7F0C04F4	copy recorded ramrom values to appropriate in-game registers
		accepts: A0=p->ramrom data
	F5170	7F0C0640	detects if recording currently loading stage - if 80048488 set, records input as a demo movie
		accepts: A0=stage#, A1=difficulty
	F52EC	7F0C07BC	record next movie to slot A0 (0-3); fries AT,T6
		slot corresponds to set#-1
		1->80048488, A0->8008C5F0
	F5304	7F0C07D4	stop recording ramrom
	F534C	7F0C081C	replay recorded ramrom demo at hardware address A0; called by intros and debug features
		accepts: A0=hardware address
	F53D8	7F0C08A8	replay ramrom loaded from devtool; redirect to 7F0C081C: A0=0xF00000
		inoperable: 0xF00000 is the development tool root address
	F53F8	7F0C08C8	set to camera mode A if not already set
	F542C	7F0C08FC	stop demos
	F54A0	7F0C0970	selects demo ramrom to replay; redirects to 7F0C081C
	F5550	7F0C0A20	V0=set #
	F55A0	7F0C0A70	set COP0 Count to 800484AC, 800484B0
	F55D0	7F0C0AA0
	F567C	7F0C0B4C
	F5714	7F0C0BE4
		A0-> [800484B4]; fries AT
	F5720	7F0C0BF0	redirect to 7F0A9358
	F5740	7F0C0C10	redirect to 7F0A9180
	F5760	7F0C0C30
		V0= [800484C0]
	F576C	7F0C0C3C
		???, A0->800484C0, uses original for first jump
		loads TLB pointer#(0-6) [800484C0] from table at 8005B790
		7F0C0C74	???, loads TLB pointer A0(0-6) from 8005B7AC
			7F0C11EC	0
			7F0C0C94	1
			7F0C0CC8	4
			7F0C0D28	default
		7F0C0D28	???, loads TLB pointer A0(0-6) from 8005B7C8
			7F0C0D48	0
			7F0C0D68	2
			7F0C0DAC	3
			7F0C0DE4	6
			7F0C0E18	default
		7F0C0E18	???, loads TLB pointer A0(0-6) from 8005B7E8
			7F0C0E38	0
			7F0C0E58	1
			7F0C11EC	2
			7F0C0E88	3
			7F0C0EB0	default
		7F0C0EB0	???, loads TLB pointer A0(0-6) from 8005B804
			7F0C0ED0	0
			7F0C0EF0	1
			7F0C0F20	2
			7F0C0F54	4
			7F0C0F9C	5
			7F0C0FE8	default
		7F0C0FE8	???, loads TLB pointer A0(0-6) from 8005B820
			7F0C1008	0
			7F0C1028	3
			7F0C1070	5
			7F0C10B4	default
		7F0C10B4	???, loads TLB pointer A0(0-6) from 8005B83C
			7F0C10D4	0
			7F0C10F4	3
			7F0C112C	4
			7F0C115C	default
		7F0C115C	???, loads TLB pointer A0(0-6) from 8005B83C
			7F0C117C	0
			7F0C119C	1
			7F0C11CC	6
			7F0C11E4	default
		7F0C11E4	default
	F5D2C	7F0C11FC
		7F0C1268
		7F0C1288
		7F0C12CC
		7F0C1310
		7F0C1340
		7F0C1364
	F5EF8	7F0C13C8	reset all music slots; fries AT
	F602C	7F0C14FC	set time (A1:A2) for music slot A0; fries AT,A0,V0,V1,T0,T6,T7,T8,T9
		accepts: A0=slot# (0-3), A1=minutes, A2=seconds
	F6088	7F0C1558	reset music in slot A0, or all if -1; fries AT,T6
	F6110	7F0C15E0	return text bank # for stage# A0
	F621C	7F0C16EC	initialize text bank and load the global text
	F6470	7F0C1940
		??? - japanese-specific
	F6560	7F0C1A30
	F6838	7F0C1D08	load mission text bank A0
	F6894	7F0C1D64	load briefing text from bank A0
	F68F4	7F0C1DC4	blank text bank A0; fries AT,T6
	F6908	7F0C1DD8	text ID (A0) -> text pointer (V0); fries V1,T0,T6,T7,T8,T9
	F6950	7F0C1E20	V0=1 if you can advance right on MP menu page; fries AT,V1,T6,T7,T8
			uses p->TLB table at 8005BC40
			7F0C1E50	V0=1	pages 0,1,2,4
			7F0C1E58	V0=0	pages 5,6,7
			7F0C1E60	V0=1 or 0 if game over	page 3
	F69BC	7F0C1E8C	V0=1 if you can advance left on MP menu page; fries AT,V1,T6,T7,T8
			uses p->TLB table at 8005BC60
			7F0C1EBC	V0=1	pages 2,3,4,5
			7F0C1EC4	V0=0	pages 0,6,7
			7F0C1ECC	V0=0 or 1 if game over	page 1
	F6A28	7F0C1EF8	if player A0 pressing stick-right, c right, + right, return TRUE
		uses press register at BONDdata+29D0
	F6A98	7F0C1F68	if player A0 pressing stick-left, c left, + left, return TRUE
		uses press register at BONDdata+29D0
	F6B0C	7F0C1FDC	redirect to 70008E08: play sound effect 09F--watch beep
 F6B30:	7F0C2000
	F6B38	7F0C2008	unpause (0->8008C718), set active play (0->8008C700), deactivate game over (0->8008C704); fries AT
		7F0C2024
		
	F6FEC	7F0C24BC	V0= TRUE if 1 player or play not stopped and player not in MP menu
		FALSE if screen should be darkened in a multiplayer stage
	F7050	7F0C2520	stop play	1->8008C700; fries: AT,T6
	F7060	7F0C2530
		??? - determines MP awards?
	F79B0	7F0C2E80
	F80D0	7F0C35A0	displays text for player data on MP menu
		accepts: A0=p->DL, A1=x pos., A2=y pos., A3=p->data arguments, SP+10=display type
		uses TLB pointers at 8005BC88
			7F0C3634	??? - green text normal	[00FF00B0]
			7F0C369C	??? - green text highlighted	[70FF70F0	007000A0]
			7F0C3710	??? - red text normal	[FF4040B0]
			7F0C3778	??? - red text highlighted	[FFA0A0F0	700000A0]
			7F0C37EC	??? - blue text normal	[4040FFB0]
			7F0C3854	??? - blue text highlighted	[A0A0FFF0	000070A0]
			7F0C38C0	return
	F8408	7F0C38D8	V0=# points for player A0 in MP stage; fries AT,V1,A0,A1,A2,A3,T0,T1,T2,T3,T4,T6,T7,T8,T9
			7F0C3954	# player kills (Normal, MwtGX, LtK)
			7F0C3B14	# deaths (YOLT)
			7F0C3B24	Time w/ Flag	(TLD)
			7F0C3B2C	Team # player kills (Teams)
	F87C4	7F0C3C94	determines rank of player A1 in multiplayer watch menu display and writes string to buffer A0
		accepts: A0=@text buffer, A1=player#
	F8A8C	7F0C3F5C	V0= TRUE if displaying rank in MP menu - uses scenario TLB pointers at 8005BCC0
		accepts: A0=TRUE if playing (false if stopped)
			7F0C3F8C	1 - all scenarios except YOLT
			7F0C3F94	0 - YOLT
	F8AFC	7F0C3FCC	V0= TRUE if displaying score in MP menu - uses scenario TLB pointers at 8005BCE0
		accepts: A0=TRUE if playing (false if stopped)
			7F0C3FFC	1 - all scenarios except YOLT + TLD
 F8B30:	7F0C4000
			7F0C4004	0 - YOLT, TLD
	F8B54	7F0C4024	multiplayer watch menu display
		uses scenario TLB pointers at 8005BD00 to set window text
			7F0C40C8	0,1,2,3 - play
			7F0C4118	7 - blank
			7F0C4128	4 - pause/unpause
			7F0C4170	5,6 - exit
 FAB30:	7F0C6000
 	FAB78	7F0C6048
		??? - pulls 8008C704.  if invalid, pulls BONDdata+29C4; fries V1,T6,T7,T8,T9
	FABB0	7F0C6080
		V0= [8008C718]
	FABC0	7F0C6090	Display red/blue positions on radar; uses scenario flags for TLD, MwtGX, and all the teams
	FB100	7F0C65D0	advance MP weapon set menu one option & save updated value; fries AT,V0,T6,T7,T8
	FB128	7F0C65F8	V0= p->current weapon set's text code; fries T6,T7,T8
	FB144	7F0C6614	returns V0=pointer to MP weapon set data; fries T6,T7
	FB160	7F0C6630	A0-> selected MP weapon set; fries AT
	FB16C	7F0C663C	V0= selected MP weapon set
	FB180	7F0C6650	unconditional return
	FB188	7F0C6658
		
	FC82C	7F0C7DFC	process huffman compressed images
 FCB30:	7F0C8000
		7F0C805C	huffman decompression types 0 - 1: store
		7F0C8084	huffman decompression type 2
		7F0C8120	huffman decompression type 3
		7F0C81D8	huffman decompression type 4
		7F0C8268	huffman decompression type 5
		7F0C82B8	huffman decompression type 6
		7F0C8324	huffman decompression type 7
		7F0C838C	huffman decompression type 8
		7F0C8464	huffman decompression type 9
		7F0C8534	invalid format handler
	FD284	7F0C8754	???
 
 FEB30:	7F0CA000
 	
	100624	7F0CBAF4	set start and end of block to A0; fries V0
		start (A1)->A0+0 & A0+8, end (A1+A2)->A0+4 & A0+C
		accepts: A0=p->[8004C720], A1=p->allocated memory, A2=size
	10063C	7F0CBB0C	V0=offset to matching image list slot, or NULL if no match found
		accepts: A0=image ID, A1=p->image list.  If NULL, defaults to 8008C720
	100694	7F0CBB64
		??? - V0=[A0+C]-[A0+8]; fries T6,T7
	1006A4	7F0CBB74	detects and handles rdp_settextureimage ABCD codes in display list A0
		accepts: A0=p->DL, A1=p->buffer for image or NULL
		calls: 7F0CBC18 if code ABCD in place of segment
	100748	7F0CBC18	load image to buffer A1 using declaration at A0
		accepts: A0=p->image declaration, A1=p->buffer for image.  If NULL, uses 8008C720
		7F0CBE50
		??? - model header parsing
	100A18	7F0CBEE8	load image A0; redirects to 7F0CBC18, setting a pointer to A0 in stack
		7F0CBF0C
		
	100AE0	7F0CBFB0	loads and sets up global image bank
100B30:	7F0CC000
	100FEC	7F0CC4BC	unconditional return
	100FF8	7F0CC4C8
		??? - reset table of saved setothermode.h settings(?)
	10104C	7F0CC51C	V0=#bytes copied: copy A1 bytes from A0 to A2; fries: V1,A1,T6
	101078	7F0CC548	V0=TRUE if current setothermode.h attributes [8008D140] do not match A0; fries: V1,T6
		accepts: A0=setothermode.h attributes needed
	1010A4	7F0CC574
		??? - unknown, used in C0- DL expansion...
		return TRUE if set to new values
		accepts: A0=???, A1=format, A2=bitdepth, A3=???, SP+10=???, SP+14=???, SP+18=???, SP+1C=???, SP+20=???, SP+24=???, SP+28=???
		7F0CC690
	101244	7F0CC714	if A1=0, returns V0=width (A0+8); else, V0=corresponding entry in 8008C731
		accepts: A0='facemapper' image entry, A1=???
	10132C	7F0CC7FC	if A1=0, return V0=height (A0+9); else, V0=corresponding entry in 8008C738
		accepts: A0='facemapper' image entry, A1=???
		fries V0,V1,A2,A3,T0,T1,T2,T6,T8,T9
		7F0CC87C
		
		7F0CC9D4
		7F0CCA9C
		
	101780	7F0CCC50
		accepts: A0=, A1=, A2=ST settilesize offset, A3=S shift, SP+10=T shift, SP+14=primary diffuse level (for FA op)

	101AEC	7F0CCFBC
		accepts: A0=p->C0- op, A1=p->texture(BB) op, A2=p->image, A3=???
	101BA8	7F0CD078	??? - expands C0- display list pseudocommands
		accepts: A0=p->DL, A1=p->'facemapper' image entry, A2=???
	101F60	7F0CD430
		??? - used in C0- pseudocommand display list expansion
		accepts: A0=p->DL, A1=p->'facemapper' entry, A2=S mirror(2)|clamp(1), A3=T mirror(2)|clamp(1), SP+10=ST settilesize offset, SP+14=???, SP+18=???
	1022DC	7F0CD7AC
		accepts: A0=p->DL, A1=p->'facemapper' entry, A2=S mirror/clamp, A3=T mirror/clamp
	102694	7F0CDB64
		accepts: A0=p->DL, A1=p->'facemapper' entry, A2=S mirror/clamp, A3=T mirror/clamp, SP+10=ST settilesize offset, SP+14=???
	102948	7F0CDE18	C0- expansion: apply type 2 basic image	C0.FC00.02 00000.iii
		accepts: A0=p->DL, A1=p->'facemapper' entry, A2=S mirror/clamp, A3=T mirror/clamp, SP+10=ST settilesize offset
	1029D8	7F0CDEA8	C0- expansion: apply type 1 overlay images	C0.FFFF.01 LL.ooo.iii
		accepts: A0=p->DL, A1=p->'facemapper' entry, A2=S mirror/clamp, A3=T mirror/clamp, SP+10=ST settilesize offset, SP+14=p->overlay image, SP+18=S shift, SP+1C=T shift, SP+20=primary diffuse level (for FA op)
	102AD8	7F0CDFA8	C0- expansion: apply image with LOD setting	C0.FFFF.0n LL.000.iii
		accepts: A0=p->DL, A1=p->'facemapper' entry, A2=S mirror/clamp, A3=T mirror/clamp, SP+10=ST settilesize offset, SP+14=S shift, SP+18=T shift, SP+1C=primary diffuse level (for FA op)
102B30:	7F0CE000
	102B94	7F0CE064	C0- expansion: apply type 4 image; calls 7F0CD7AC, 7F0CDB64: SP+14=0
		accepts: A0=p->DL, A1=p->'facemapper' entry, A2=S mirror/clamp, A3=T mirror/clamp, SP+10=ST settilesize offset
	102BDC	7F0CE0AC	C0- expansion: apply type 3 image; calls 7F0CD7AC, 7F0CDB64: SP+14=0, 7F0CDB64: SP+14=1
		accepts: A0=p->DL, A1=p->'facemapper' entry, A2=S mirror/clamp, A3=T mirror/clamp, SP+10=ST settilesize offset
	102C48	7F0CE118	used to parse display list microcode sorting display modes and expanding image calls as required
		uses TLB pointer table at 8005BF20
			7F0CE1D8	C0 command: expand into image ops
				uses TLB pointer table at 8005BF60
				7F0CE2BC	type 0 - C0.FFFF.00 LL.000.iii	if collecting detail data use cur.image for new entry; or load image with LOD level	7F0CDFA8
				7F0CE428	type 1 - C0.FFFF.01 LL.ooo.iii	LOD style image shifting	7F0CDEA8
				7F0CE4B8	type 2 - C0.FC00.02 00000.iii	use detail data for LOD level + shift if present; or load basic image	7F0CDFA8 / 7F0CDE18
				7F0CE584	type 3 - C0.FC00.03 00000.iii	basic image	7F0CE0AC
				7F0CE5BC	type 4 - C0.FC00.04 00000.iii	basic image	7F0CE064
				7F0CE5F0	default	tests if texture 5E4 or 5E7
			7F0CE64C	copy command from buffer back to source
			7F0CE66C	B1, BF commands: triangle commands
			7F0CE694	BB command: texture, activating and applying loaded textures to triangles
			7F0CE6B8	BA command: setothermode.h
			7F0CE720	default
# RareZip decompressor
	103320	7F0CE7F0	decompress data A0 to A1, advancing past header
		accepts: A0=p->zlib compressed data, A1=p->target, A2=p->buffer for decompression object
		actually tests header against 8005BF80+84, and on fail against 8005BF88/98 - all of which are the same!
		calls 7F0CFCD4
	1033C4	7F0CE894
		returns V0=8008D350(T6) + 8008D358(T7)
		7F0CE8B0
		7F0CEEF0
	103EBC	7F0CF38C	type 0 zlib decompressor
	104058	7F0CF528	type 1 zlib decompressor
	1041C0	7F0CF690	type 2 zlib decompressor
	1046E4	7F0CFBB4	select zlib decompression routine from type
	104804	7F0CFCD4	loops to decompress entire zlib file; calls 7F0CFBB4
		uses a zlib struct at 8008D350 (ish)
# RSP management
	1048E0	7F0CFDB0	generate debug.notice.list entry for rsp_c_debug using data at 8004E9E0
	10490C	7F0CFDDC	allocate and initialize RSP buffers
	104948	7F0CFE18	???; in part loads RSP microcode from 80020D90 - 80020E60
# Indy management
	104A60	7F0CFF30	initializes Indy if not ready; calls 7F0CFF6C
	104A94	7F0CFF64	unconditional return
	104A9C	7F0CFF6C	initializes Indy if ready; calls 7F0D0A3C
	104ACC	7F0CFF9C	load resource named A0 from Indy to A1
		accepts: A0=p->string, A1=p->target
	104B10	7F0CFFE0	send capture data A1 of size A2 named A0
		accepts: A0=p->text, A1=p->data, A2=size
104B30:	7F0D0000
	104B4C	7F0D001C	load ramrom file named A0 from Indy to buffer A1, size A2
		accepts: A0=p->string, A1=p->target, A2=@filesize
	104B8C	7F0D005C	V0=TRUE if file A0 at hardware A1 of size A2 successfully exported
		accepts: A0=p->string, A1=hardware address, A2=size
	104BC8	7F0D0098	V0=TRUE if resource named A0 found on Indy and filesize set to A1
		accepts: A0=p->string, A1=@filesize
	104C10	7F0D00E0	V0= response from command string A0 sent to host PC via Indy
		accepts: A0=p->text
	104C54	7F0D0124	removed: V0= -1
		if 8004EAC8 set, call 7000CEB0
	104C84	7F0D0154	send close port command to PC
		calls 7F0D00E0: A0=p->"sleep 5; /etc/killall ghost gload" [8005BFC0]
# Indy: resource entry management
	104CB0	7F0D0180	removed: read A1 bytes f/indy.res to A0
		accepts: A0=p->data, A1=size of data
		redirects to 7000CEC0
	104D00	7F0D01D0	removed: write A1 bytes to indy.res from A0
		accepts: A0=p->data, A1=size of data
		redirects to 7000CEB8
	104D50	7F0D0220	post Indy resource command A0 of size A1
		accepts: A0=p->data, A1=length
	104D88	7F0D0358	post two Indy resource commands A0 and A2 of sizes A1 and A3, respectively
		accepts: A0=p->indy.res 1, A1=size of indy.res 1, A2=indy.res 2, A3=size of indy.res 2
	104DBC	7F0D038C	post type 1 indy.res.cmd: PI access request
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
		calls 7F0D0220: A0=[9ABF1623,1,0x14,A0,A1]
	104E04	7F0D03D4	post type 2 indy.res.cmd: command ready
		accepts: A0=next indy.res.cmd size [0], A1=next indy.res.cmd size [0]
		calls 7F0D0220: A0=[9ABF1623,2,0x14,A0,A1]
	104E4C	7F0D041C	post type 0 indy.res.cmd: initialize
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
		calls 7F0D0220: A0=[9ABF1623,0,0x14,A0,A1]
	104E90	7F0D0460	post type 3 indy.res.cmd: data send
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string (100 bytes max)
		calls 7F0D0220: A0=[9ABF1623,3,0x114,A0,A1,string at A2(0x100 bytes)], A1=size (0x114)
	104EF4	7F0D04C4	post type 4 indy.res.cmd: data recieved
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
		calls 7F0D0220: A0=[9ABF1623,4,0x18,A0,A1,A2]
	105044	7F0D0514	post type 5 indy.res.cmd: printf send
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string
		calls 7F0D0220: A0=[9ABF1623,5,0x114,A0,A1,string at A2(0x100 bytes)], A1=size (0x114)
	1050A8	7F0D0578	post type 6 indy.res.cmd: printf recieved
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=, A3=
		calls 7F0D0220: A0=[9ABF1623,6,0x1C,A0,A1,A2]
	105100	7F0D05D0	post type 7 indy.res.cmd: log send
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string, A3=
		calls 7F0D0220: A0=[9ABF1623,7,0x118,A0,A1,string at A2(0x100 bytes),A3], A1=size (0x118)
	105174	7F0D0644	post type 8 indy.res.cmd: log recieved
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=, A3=, SP+10=size of struct 2, SP+14=p->struct 2
		calls 7F0D0358: A0=[9ABF1623,8,A3+20 to nearest word,A0,A1,A2,A3,SP+10], A1=size (0x20)
	1051F0	7F0D06C0	post type 9 indy.res.cmd: app. command ready
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string, A3=size of struct 2, SP+10=p->struct 2
		calls 7F0D0358: A0=[9ABF1623,9,0x114,string at A2(0x100 bytes),A0,A1], A1=size (0x114), A2=SP+10, A3=A3
	105270	7F0D0740	post type A indy.res.cmd: app. command received
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
		calls 7F0D0220: A0=[9ABF1623,A,0x18,A0,A1,A2], A1=size (0x18)
	1052C0	7F0D0790	post type F indy.res.cmd: request ramrom file named A2 sent to buffer A3 of SP+10 bytes
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string, A3=p->target, SP+10=@filesize
		calls 7F0D0220: A0=[9ABF1623,F,0x11C,A0,A1,string at A2(0x100 bytes),A3,SP+10], A1=size (0x11C)
	10533C	7F0D080C	post type 10 indy.res.cmd: ramrom request recieved
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=success (TRUE/FALSE), A3=p->buffer, SP+10=@size
		calls 7F0D0220: A0=[9ABF1623,10,0x20,A0,A1,A2,A3,SP+10], A1=size (0x20)
	10539C	7F0D086C	post type D indy.res.cmd: prof send - filename A0 of size A1 at hardware address A2
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string, A3=size, SP+10=hardware address
		calls 7F0D0220: A0=[9ABF1623,D,0x11C,A0,A1,string at A2(0x100 bytes),A3,SP+10], A1=size (0x11C)
	105418	7F0D08E8	post type E indy.res.cmd: prof recieved
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
		calls 7F0D0220: A0=[9ABF1623,E,0x18,A0,A1,A2], A1=size (0x18)
	105468	7F0D0938	post type B indy.res.cmd: host prof send
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=p->string
		calls 7F0D0220: A0=[9ABF1623,B,0x414,A0,A1,string at A2(0x400 bytes)], A1=size (0x414)
	1054CC	7F0D099C	post type C indy.res.cmd: host prof recieved
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
		calls 7F0D0220: A0=[9ABF1623,C,0x18,A0,A1,A2], A1=size (0x18)
	10551C	7F0D09EC	post type A indy.res.cmd: app. data recieved
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=
		calls 7F0D0220: A0=[9ABF1623,A,0x18,A0,A1,A2], A1=size (0x18)
	10556C	7F0D0A3C	post indy.res.cmd structure 1:0:2: initialize
	1055AC	7F0D0A7C	post indy.res.cmd structure 1:3:2: (game) data send
		accepts: A0=p->string
	1055F4	7F0D0AC4	post indy.res.cmd structure 1:4:2: (debug) data rec.
		accepts: A0=
	10563C	7F0D0B0C	post indy.res.cmd structure 1:5:2: (game) printf send
		accepts: A0=p->string
	105684	7F0D0B54	post indy.res.cmd structure 1:6:2: (debug) printf rec.
		accepts: A0=, A1=
	1056D4	7F0D0BA4	post indy.res.cmd structure 1:7:2: (game) request file named A0, size A1
		accepts: A0=p->string, A1=size [400000]
	105724	7F0D0BF4	post indy.res.cmd structure 1:8:2: (host) recieve file A3, size A2
		accepts: A0=, A1=, A2=data size, A3=p->data
	105798	7F0D0C68	post indy.res.cmd structure 1:9:2: send capture data A1, size A2 named A0
		accepts: A0=p->string, A1=data size, A2=p->data
	105800	7F0D0CD0	post indy.res.cmd structure 1:A:2: recieve capture data success
		accepts: A0=@success
	105848	7F0D0D18	post indy.res.cmd structure 1:F:2: 
		accepts: A0=p->string, A1=, A2=
	1058A4	7F0D0D74	post indy.res.cmd structure 1:10:2: 
		accepts: A0=, A1=, A2=
	105900	7F0D0DD0	post indy.res.cmd structure 1:D:2: (game) prof send - filename A0 of size A1 at hardware address A2
		accepts: A0=p->string, A1=size, A2=hardware address
	10595C	7F0D0E2C	post indy.res.cmd structure 1:E:2: (host) prof rec.
		accepts: A0=
	1059A4	7F0D0E74	post indy.res.cmd structure 1:B:2: 
		accepts: A0=p->string
	1059EC	7F0D0EBC	post indy.res.cmd structure 1:C:2: 
		accepts: A0=
	105A34	7F0D0F04	post indy.res.cmd structure 1:A:2: 
		accepts: A0=
	105A7C	7F0D0F4C	read Indy resource command of size A1 to A0
		accepts: A0=p->buffer, A1=size of buffer
	105BD8	7F0D10A8	read two Indy resource commands A0 and A2 of sizes A1 and A3, respectively
		accepts: A0=p->buffer 1, A1=size of buffer 1, A2=buffer 2, A3=size of buffer 2
	105C30	7F0D1100	V0= TRUE if current indy.res.cmd type 1 with expected sizes (A0,A1)
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
	105CDC	7F0D11AC	V0= TRUE if current indy.res.cmd type 2 with expected sizes (A0,A1)
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
	105D78	7F0D1248	V0= TRUE if current indy.res.cmd type 4 with expected sizes (A0,A1); A2= response (struct+14) if TRUE
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response
	105E24	7F0D12F4	V0= TRUE if current indy.res.cmd type 6 with expected sizes (A0,A1); A2,A3= responses (struct+14,+18) if TRUE
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response1, A3=@response2
	105EE0	7F0D13B0	V0= TRUE if current indy.res.cmd type 8 with expected sizes (A0,A1); A2,A3= responses (struct+14,+18) if TRUE, SP+14= child indy.res.cmd of size A3
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response1, A3=@response2, SP+10=@size of child indy.res.cmd, SP+14=@target for child indy.res.cmd
	105FC8	7F0D1498	V0= TRUE if current indy.res.cmd type A with expected sizes (A0,A1); A2= response (struct+14) if TRUE
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response
	106074	7F0D1544	V0= TRUE if current indy.res.cmd type 10 with expected sizes (A0,A1); A2,A3,SP+10= responses (struct+14,+18,+1C) if TRUE
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response1, A3=@response2, SP+10=@response3
	10613C	7F0D160C	V0= TRUE if current indy.res.cmd type E with expected sizes (A0,A1); A2= response (struct+14) if TRUE
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response
	1061E8	7F0D16B8	V0= TRUE if current indy.res.cmd type C with expected sizes (A0,A1); A2= response (struct+14) if TRUE
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size, A2=@response
	106294	7F0D1764	A0= response from indy.res.cmd structure 1:4:2
		accepts: A0=@response
	1062DC	7F0D17AC	(A0,A1)= printf.recieved: response from indy.res.cmd structure 1:6:2; A0=TRUE and A1=filesize if file requested by 1:5:2 indy.res.cmd found
		accepts: A0=@discovered (TRUE/FALSE), A1=@filesize
	10632C	7F0D17FC	(A0,A1)= response, A3= p->data of size A2 from indy.res.cmd structure 1:8:2: recieve file A3, size A2
		accepts: A0=@response1, A1=@response2, A2=@data size, A3=@data
	106394	7F0D1864	A0= response from indy.res.cmd structure 1:A:2
		accepts: A0=@response
	1063DC	7F0D18AC	(A0,A1,A2)= response from indy.res.cmd structure 1:10:2
		accepts: A0=@response1, A1=@response2, A2=@response3
	106438	7F0D1908	A0= response from indy.res.cmd structure 1:E:2; V0=TRUE if file generated via 1:D:2 indy.res.cmd
		accepts: A0=@response
	106480	7F0D1950	A0= response from indy.res.cmd structure 1:C:2
		accepts: A0=@response
	1064C8	7F0D1998	V0= TRUE if next indy.res.cmd matches expected sizes (A0,A1)
		accepts: A0=next indy.res.cmd size, A1=next indy.res.cmd size
# memory management
	106550	7F0D1A20	generate debug.notice.list entry for game_c_debug using data at 8004EAE0
		redirect to 70004E60: A0=8004EAE0, A1=8005BFF0
	10657C	7F0D1A4C
		??? - ?, reset memory bank 5, ??? bank 5
		calls: 7F0BD234; 7000999C: A0=5; 7F0BD1BC: A0=5
	1065AC	7F0D1A7C
		???
		calls: 700099C4: A0=5; 7F0BD1BC: A0=5
	1065E0	7F0D1AB0
		V0=8005C000	(address, not value)
	1065F0	7F0D1AC0	???; generates DL
		accepts: A0=p->DL
	1066C8	7F0D1B98
		accepts: A0=p->DL, A1=(float), A2=red, A3=green, SP+10=blue
		calls 7F0D1BD0: A0, A1, A2, A3, SP+10, SP+14=2, SP+18=1
	106700	7F0D1BD0
		accepts: A0=p->DL, A1=(float), A2=red, A3=green, SP+10=blue, SP+14=, SP+18=
		7F0D1DCC
		
		7F0D1E98
		
106B30:	7F0D2000

	106E50	7F0D2320
	106EB0	7F0D2380	NULL-> [8004EB00]
	106EBC	7F0D238C
	106F78	7F0D2448
	106F94	7F0D2464	???; display list generator
	107048	7F0D2518	???; display list generator
	107250	7F0D2720	V0= primary music track for stage A0
		accepts: A0=stage#
	107378	7F0D2848	V0= secondary music track for stage A0
		accepts: A0=stage#
	1073C0	7F0D2890	V0= x music track for stage A0
		accepts: A0=stage#
# Spectrum emulation
	107410	7F0D28E0	???; Spectrum-related
	1075B4	7F0D2A84	???; Spectrum-related, tied to game execution
		accepts: A0=p->spectrum.ROMs.game, A1=p->buffer[6000]
	1077B4	7F0D2C84	Spectrum: read player1's controller input as Kempston joystick
	107AF4	7F0D2FC4	initialize Spectrum and load game index #A0
		accepts: A0=game# (only permits 0-4, not 0-9)
	107EA4	7F0D3374	run loaded Spectrum game
		calls: 7F0D2C84; 7F0D382C; 7F0D2A84: A0=p->spectrum.ROMs.game, A1=p->spectrum.rdram
	107EE4	7F0D33B4	Spectrum: draw screen
		accepts: A0=p->display list
	108208	7F0D36D8	Spectrum: V0=input from port A2 using register A1
		accepts: A0=SP (unused), A1=key register, A2=port (1F=controller, FE=keyboard)
	108304	7F0D37D4	unconditional return
	10830C	7F0D37DC	Spectrum: V0= A3 written to port A2 or 0 if not required; A2 must be port 254
		accepts: A0=#cycles (unused), A1=spec.A (unused), A2=port# (must be FE), A3=value (nibble)
	10835C	7F0D382C	Spectrum: processor emulation
		uses TLB pointers at 8005C12C
			7F0D3A3C	00: NOP
			7F0D3A4C	01: LD BC,nn
			7F0D3A8C	02: LD (BC),A
			7F0D3B6C	03: INC BC
			7F0D3B98	04: INC B
			7F0D3BFC	05: DEC B
			7F0D3C64	06: LD B,n
			7F0D3C90	07: RLCA	;rotate left through carry accumulator
			7F0D3CC8	08: EX AF,AF'	;exchange register pair AF to shadow AF
			7F0D3CF8	09: ADD HL,BC
			7F0D3E18	0A: LD A,(BC)
			7F0D3E40	0B: DEC BC
			7F0D3E74	0C: INC C
			7F0D3ED8	0D: DEC C
			7F0D3F40	0E: LD C,n
			7F0D3F6C	0F: RRCA	;rotate right circular accumulator
			7F0D3FAC	10: DJNZ d	;decrement jump nonzero
108B30:	7F0D4000
			7F0D400C	11: LD DE,nn
			7F0D404C	12: LD (DE),A
			7F0D412C	13: INC DE
			7F0D4158	14: INC D
			7F0D41BC	15: DEC D
			7F0D4224	16: LD D,n
			7F0D4250	17: RLA	;rotate left accumulator
			7F0D4294	18: JR n
			7F0D42D0	19: ADD HL,DE
			7F0D43F0	1A: LD A,(DE)
			7F0D4418	1B: DEC DE
			7F0D444C	1C: INC E
			7F0D44B0	1D: DEC E
			7F0D4518	1E: LD E,n
			7F0D4544	1F: RRA	;rotate right accumulator
			7F0D4588	20: JR NZ,n
			7F0D45E0	21: LD HL,nn
			7F0D4698	22: LD (nn),HL
			7F0D4B18	23: INC HL
			7F0D4B78	24: INC H
			7F0D4CAC	25: DEC H
			7F0D4DEC	26: LD H,n
			7F0D4E88	27: DAA	;decimal adjust accumulator
			7F0D5014	28: JR Z,n
			7F0D5068	29: ADD HL,HL
			7F0D53E0	2A: LD HL,(nn)
			7F0D549C	2B: DEC HL
			7F0D5504	2C: INC L
			7F0D5628	2D: DEC L
			7F0D5758	2E: LD L,n
			7F0D57EC	2F: CPL	;complement accumulator
			7F0D581C	30: JR NC,n
			7F0D5874	31: LD SP,nn
			7F0D58B4	32: LD (nn),A
			7F0D5994	33: INC SP
			7F0D59B0	34: INC (HL)
			7F0D5B44	35: DEC (HL)
			7F0D5CE4	36: LD (HL),n
			7F0D5E2C	37: SCF	;set carry flag
			7F0D5E54	38: JR C,n
			7F0D5EA8	39: ADD HL,SP
			7F0D5FD8	3A: LD A,(nn)
10AB30:	7F0D6000
			7F0D6024	3B: DEC SP
			7F0D6040	3C: INC A
			7F0D60A4	3D: DEC A
			7F0D610C	3E: LD A,n
			7F0D6138	3F: CCF	;complement carry flag
			7F0D6174	40: LD B,B
			7F0D6184	41: LD B,C
			7F0D6198	42: LD B,D
			7F0D61AC	43: LD B,E
			7F0D61C0	44: LD B,H
			7F0D620C	45: LD B,L
			7F0D6258	46: LD B,(HL)
			7F0D62E8	47: LD B,A
			7F0D62FC	48: LD C,B
			7F0D6310	49: LD C,C
			7F0D6320	4A: LD C,D
			7F0D6334	4B: LD C,E
			7F0D6348	4C: LD C,H
			7F0D6394	4D: LD C,L
			7F0D63E0	4E: LD C,(HL)
			7F0D6470	4F: LD C,A
			7F0D6484	50: LD D,B
			7F0D6498	51: LD D,C
			7F0D64AC	52: LD D,D
			7F0D64BC	53: LD D,E
			7F0D64D0	54: LD D,H
			7F0D651C	55: LD D,L
			7F0D6568	56: LD D,(HL)
			7F0D65F8	57: LD D,A
			7F0D660C	58: LD E,B
			7F0D6620	59: LD E,C
			7F0D6634	5A: LD E,D
			7F0D6648	5B: LD E,E
			7F0D6658	5C: LD E,H
			7F0D66A4	5D: LD E,L
			7F0D66F0	5E: LD E,(HL)
			7F0D6780	5F: LD E,A
			7F0D6794	60: LD H,B
			7F0D67EC	61: LD H,C
			7F0D6844	62: LD H,D
			7F0D689C	63: LD H,E
			7F0D68F4	64: LD H,H
			7F0D6904	65: LD H,L
			7F0D6A18	66: LD H,(HL)
			7F0D6AA8	67: LD H,A
			7F0D6B00	68: LD L,B
			7F0D6B50	69: LD L,C
			7F0D6BA0	6A: LD L,D
			7F0D6BF0	6B: LD L,E
			7F0D6C40	6C: LD L,H
			7F0D6D4C	6D: LD L,L
			7F0D6D5C	6E: LD L,(HL)
			7F0D6DEC	6F: LD L,A
			7F0D6E3C	70: LD (HL),B
			7F0D6F58	71: LD (HL),C
			7F0D7074	72: LD (HL),D
			7F0D7190	73: LD (HL),E
			7F0D72AC	74: LD (HL),H
			7F0D73C8	75: LD (HL),L
			7F0D74E4	76: HALT	;halt (wait for interrupt 
			7F0D7524	77: LD (HL),A
			7F0D7640	78: LD A,B
			7F0D7654	79: LD A,C
			7F0D7668	7A: LD A,D
			7F0D767C	7B: LD A,E
			7F0D7690	7C: LD A,H
			7F0D76DC	7D: LD A,L
			7F0D7728	7E: LD A,(HL)
			7F0D77B8	7F: LD A,A
			7F0D77C8	80: ADD A,B
			7F0D7848	81: ADD A,C
			7F0D78C8	82: ADD A,D
			7F0D7948	83: ADD A,E
			7F0D79C8	84: ADD A,H
			7F0D7A84	85: ADD A,L
			7F0D7B40	86: ADD A,(HL)
			7F0D7C3C	87: ADD A,A
			7F0D7CBC	88: ADC A,B
			7F0D7D50	89: ADC A,C
			7F0D7DE4	8A: ADC A,D
			7F0D7E78	8B: ADC A,E
			7F0D7F0C	8C: ADC A,H
			7F0D7FDC	8D: ADC A,L
10CB30:	7F0D8000
			7F0D80AC	8E: ADC A,(HL)
			7F0D81BC	8F: ADC A,A
			7F0D8250	90: SUB B
			7F0D82CC	91: SUB C
			7F0D8348	92: SUB D
			7F0D83C4	93: SUB E
			7F0D8440	94: SUB H
			7F0D84F8	95: SUB L
			7F0D85B0	96: SUB (HL)
			7F0D86A8	97: SUB A
			7F0D8724	98: SBC A,B
			7F0D87AC	99: SBC A,C
			7F0D8834	9A: SBC A,D
			7F0D88BC	9B: SBC A,E
			7F0D8944	9C: SBC A,H
			7F0D8A08	9D: SBC A,L
			7F0D8ACC	9E: SBC A,(HL)
			7F0D8BD0	9F: SBC A,A
			7F0D8C58	A0: AND B
			7F0D8CA8	A1: AND C
			7F0D8CF8	A2: AND D
			7F0D8D48	A3: AND E
			7F0D8D98	A4: AND H
			7F0D8E2C	A5: AND L
			7F0D8EC0	A6: AND (HL)
			7F0D8F90	A7: AND A
			7F0D8FE0	A8: XOR B
			7F0D902C	A9: XOR C
			7F0D9078	AA: XOR D
			7F0D90C4	AB: XOR E
			7F0D9110	AC: XOR H
			7F0D91A0	AD: XOR L
			7F0D9230	AE: XOR (HL)
			7F0D92FC	AF: XOR A
			7F0D9348	B0: OR B
			7F0D9394	B1: OR C
			7F0D93E0	B2: OR D
			7F0D942C	B3: OR E
			7F0D9478	B4: OR H
			7F0D9508	B5: OR L
			7F0D9598	B6: OR (HL)
			7F0D9664	B7: OR A
			7F0D96B0	B8: CP B
			7F0D9730	B9: CP C
			7F0D97B0	BA: CP D
			7F0D9830	BB: CP E
			7F0D98B0	BC: CP H
			7F0D996C	BD: CP L
			7F0D9A28	BE: CP (HL)
			7F0D9B24	BF: CP A
			7F0D9BA4	C0: RET NZ
			7F0D9BF4	C1: POP BC
			7F0D9C24	C2: JP NZ,nn
			7F0D9C74	C3: JP nn
			7F0D9CAC	C4: CALL NZ,nn
			7F0D9E94	C5: PUSH BC
			7F0D9FFC	C6: ADD A,n
10EB30:	7F0DA000
			7F0DA098	C7: RST 00	;restart 0: normal start
			7F0DA228	C8: RET Z
			7F0DA278	C9: RET
			7F0DA2C0	CA: JP Z,nn
			7F0DA310	CB
				uses TLB pointer table at 8005C52C
				7F0DA414	CB.00: RLC B	;rotate left through carry
				7F0DA464	CB.01: RLC C
				7F0DA4B4	CB.02: RLC D
				7F0DA504	CB.03: RLC E
				7F0DA554	CB.04: RLC H
				7F0DA5A4	CB.05: RLC L
				7F0DA5F4	CB.06: RLC (HL)
				7F0DA718	CB.07: RLC A
				7F0DA768	CB.08: RRC B	;rotate right circular
				7F0DA7BC	CB.09: RRC C
				7F0DA810	CB.0A: RRC D
				7F0DA864	CB.0B: RRC E
				7F0DA8B8	CB.0C: RRC H
				7F0DA90C	CB.0D: RRC L
				7F0DA960	CB.0E: RRC (HL)
				7F0DAA8C	CB.0F: RRC A
				7F0DAAE0	CB.10: RL B	;rotate left
				7F0DAB34	CB.11: RL C
				7F0DAB88	CB.12: RL D
				7F0DABDC	CB.13: RL E
				7F0DAC30	CB.14: RL H
				7F0DAC84	CB.15: RL L
				7F0DACD8	CB.16: RL (HL)
				7F0DAE00	CB.17: RL A
				7F0DAE54	CB.18: RR B	;rotate right
				7F0DAEA8	CB.19: RR C
				7F0DAEFC	CB.1A: RR D
				7F0DAF50	CB.1B: RR E
				7F0DAFA4	CB.1C: RR H
				7F0DAFF8	CB.1D: RR L
				7F0DB04C	CB.1E: RR (HL)
				7F0DB174	CB.1F: RR A
				7F0DB1C8	CB.20: SLA B	;shift left arithmetic
				7F0DB210	CB.21: SLA C
				7F0DB258	CB.22: SLA D
				7F0DB2A0	CB.23: SLA E
				7F0DB2E8	CB.24: SLA H
				7F0DB330	CB.25: SLA L
				7F0DB378	CB.26: SLA (HL)
				7F0DB498	CB.27: SLA A
				7F0DB4E0	CB.28: SRA B	;shift right arithmetic
				7F0DB530	CB.29: SRA C
				7F0DB580	CB.2A: SRA D
				7F0DB5D0	CB.2B: SRA E
				7F0DB620	CB.2C: SRA H
				7F0DB670	CB.2D: SRA L
				7F0DB6C0	CB.2E: SRA (HL)
				7F0DB7E0	CB.2F: SRA A
				7F0DB830	CB.30: SLS B
				7F0DB87C	CB.31: SLS C
				7F0DB8C8	CB.32: SLS D
				7F0DB914	CB.33: SLS E
				7F0DB960	CB.34: SLS H
				7F0DB9AC	CB.35: SLS L
				7F0DB9F8	CB.36: SLS (HL)
				7F0DBB1C	CB.37: SLS A
				7F0DBB68	CB.38: SRL B	;shift right logical
				7F0DBBB0	CB.39: SRL C
				7F0DBBF8	CB.3A: SRL D
				7F0DBC40	CB.3B: SRL E
				7F0DBC88	CB.3C: SRL H
				7F0DBCD0	CB.3D: SRL L
				7F0DBD18	CB.3E: SRL (HL)
				7F0DBE38	CB.3F: SRL A
				7F0DBE80	CB.40-FF
					CB.40-7F BIT cmds use TLB pointer table at 8005C66C
						7F0DBF18	BIT x,B
						7F0DBF60	BIT x,C
						7F0DBFA8	BIT x,D
						7F0DBFF0	BIT x,E
110B30:	7F0DC000
						7F0DC038	BIT x,H
						7F0DC080	BIT x,L
						7F0DC0C8	BIT x,(HL)
						7F0DC1E4	BIT x,A
					CB.80-BF RES cmds use TLB pointer table at 8005C64C
						7F0DC22C	RES x,B
						7F0DC24C	RES x,C
						7F0DC26C	RES x,D
						7F0DC28C	RES x,E
						7F0DC2AC	RES x,H
						7F0DC2CC	RES x,L
						7F0DC2EC	RES x,(HL)
						7F0DC3D4	RES x,A
					CB.C0-FF SET cmds use TLB pointer table at 8005C62C
						7F0DC3F4	SET x,B
						7F0DC410	SET x,C
						7F0DC42C	SET x,D
						7F0DC448	SET x,E
						7F0DC464	SET x,H
						7F0DC480	SET x,L
						7F0DC49C	SET x,(HL)
						7F0DC580	SET x,A
			7F0DC5FC	CC: CALL Z,nn
			7F0DC7E4	CD: CALL nn
			7F0DC9B4	CE: ADC A,n
			7F0DCA64	CF: RST 08	;retsart 8: error restart
			7F0DCBF8	D0: RET NC
			7F0DCC48	D1: POP DE
			7F0DCC78	D2: JP NC,nn
			7F0DCCC8	D3: OUT (n),A
			7F0DCD14	D4: CALL NC,nn
			7F0DCEFC	D5: PUSH DE
			7F0DD064	D6: SUB n
			7F0DD0FC	D7: RST 10	;restart 10: print a char restart
			7F0DD290	D8: RET C
			7F0DD2E0	D9: EXX	;exchange alternate registers
			7F0DD350	DA: JP C,nn
			7F0DD3A0	DB: IN A,(n)
			7F0DD3F4	DC: CALL C,nn
			7F0DD5DC	DD	;next HL opcode sets IX
			7F0DD5F8	DE: SBC A,n
			7F0DD69C	DF: RST 18	;restart 18: collect char restart
			7F0DD830	E0: RET PO
			7F0DD880	E1: POP HL
			7F0DD92C	E2: JP PO,nn
			7F0DD97C	E3: EX (SP),HL
			7F0DDE6C	E4: CALL PO,nn
112B30:	7F0DE000
			7F0DE054	E5: PUSH HL
			7F0DE4D0	E6: AND n
			7F0DE540	E7: RST 20	;restart 20: collect next char restart
			7F0DE6D4	E8: RET PE
			7F0DE724	E9: JP (HL)
			7F0DE774	EA: JP PE,nn
			7F0DE7C4	EB: EX DE,HL
			7F0DE7EC	EC: CALL PE,nn
			7F0DE9D4	ED
			ED.40-7E cmds use TLB pointer table at 8005C71C
				7F0DEA68	ED.40: IN B,(C)
				7F0DEAD8	ED.41: OUT (C),B
				7F0DEB08	ED.42: SBC HL,BC
				7F0DEBDC	ED.43: LD (NN),BC
				7F0DED68	ED.44: NEG
				7F0DEDCC	ED.45: RETN	;return from NMI
				7F0DEE1C	ED.46: IM 0
				7F0DEE30	ED.47: LD I,A
				7F0DEE44	ED.48: IN C,(C)
				7F0DEEB4	ED.49: OUT (C),C
				7F0DEEE4	ED.4A: ADC HL,BC
				7F0DEFB0	ED.4B: LD BC,(NN)
				7F0DF000	ED.4C: [NEG]
				7F0DF064	ED.4D: RETI	;return from interrupt
				7F0DF0AC	ED.4E: [IM 0]
				7F0DF0C4	ED.4F: LD R,A
				7F0DF0E0	ED.50: IN D,(C)
				7F0DF150	ED.51: OUT (C),D
				7F0DF180	ED.52: SBC HL,DE
				7F0DF254	ED.53: LD (NN),DE
				7F0DF3E0	ED.54: [NEG]
				7F0DF444	ED.55: [RETN]
				7F0DF48C	ED.56: IM 1
				7F0DF4A4	ED.57: LD A,I
				7F0DF4E8	ED.58: IN E,(C)
				7F0DF558	ED.59: OUT (C),E
				7F0DF588	ED.5A: ADC HL,DE
				7F0DF654	ED.5B: LD DE,(nn)
				7F0DF6A4	ED.5C: [NEG]
				7F0DF708	ED.5D: [RETI]
				7F0DF750	ED.5E: IM 2
				7F0DF768	ED.5F: LD A,R
				7F0DF7C8	ED.60: IN H,(C)
				7F0DF838	ED.61: OUT (C),H
				7F0DF868	ED.62: SBC HL,HL
				7F0DF93C	ED.63: [LD (nn),HL]
				7F0DFAC8	ED.64: [NEG]
				7F0DFB2C	ED.65: [RETN]
				7F0DFB74	ED.66: [IM 0]
				7F0DFB88	ED.67: RRD	;rotate-right-digit
				7F0DFCE8	ED.68: IN L,(C)
				7F0DFD58	ED.69: OUT (C),L
				7F0DFD88	ED.6A: ADC HL,HL
				7F0DFE54	ED.6B: [LD HL,(nn)]
				7F0DFEA4	ED.6C: [NEG]
				7F0DFF08	ED.6D: [RETI]
				7F0DFF50	ED.6E: [IM 0]
				7F0DFF68	ED.6F: RLD
114B30:	7F0E0000
				7F0E00C8	ED.70: IN (C)
				7F0E013C	ED.71: OUT (C),0
				7F0E016C	ED.72: SBC HL,SP
				7F0E022C	ED.73: LD (nn),SP
				7F0E03DC	ED.74: [NEG]
				7F0E0440	ED.75: [RETN]
				7F0E0488	ED.76: [IM 1]
				7F0E04A0	ED.78: IN A,(C)
				7F0E0510	ED.79: OUT (C),A
				7F0E0540	ED.7A: ADC HL,SP
				7F0E05F8	ED.7B: LD SP,(nn)
				7F0E0658	ED.7C: [NEG]
				7F0E06BC	ED.7D: [RETI]
				7F0E0704	ED.7E: [IM 2]
			ED.A0-BB cmds use TLB pointer table at 8005C6AC
				7F0E071C	ED.A0: LDI	;load-increment (BC=counter, DE=target, HL=source)
				7F0E08A0	ED.A1: CPI	;compare-increment (BC=counter, DE=target, HL=source)
				7F0E09A0	ED.A2: INI	;input-increment (BC=counter, HL=target)
				7F0E0B08	ED.A3: OUTI	;output-increment (BC=counter, HL=target)
				7F0E0B9C	ED.A8: LDD	;load-decrement (BC=counter, DE=target, HL=source)
				7F0E0D30	ED.A9: CPD	;compare-decrement (BC=counter, DE=target, HL=source)
				7F0E0E38	ED.AA: IND	;input-decrement (BC=counter, HL=target)
				7F0E0FAC	ED.AB: OUTD	;output-decrement (BC=counter, HL=target)
				7F0E1048	ED.B0: LDIR	;load-increment-repeat>0 (BC=counter, DE=target, HL=source)
				7F0E11EC	ED.B1: CPIR	;compare-increment-repeat>0 (BC=counter, DE=target, HL=source)
				7F0E1310	ED.B2: INIR	;input-increment-repeat>0 (BC=counter, HL=target)
				7F0E1494	ED.B3: OTIR	;output-increment-repeat>0 (BC=counter, HL=target)
				7F0E1544	ED.B8: LDDR	;load-decrement-repeat>0 (BC=counter, DE=target, HL=source)
				7F0E16F8	ED.B9: CPDR	;compare-decrement-repeat>0 (BC=counter, DE=target, HL=source)
				7F0E1824	ED.BA: INDR	;input-decrement-repeat>0 (BC=counter, HL=target)
				7F0E19B4	ED.BB: OTDR	;output-decrement-repeat>0 (BC=counter, HL=target)
			7F0E1A7C	EE: XOR n
			7F0E1AE8	EF: RST 28	;restart 28: calculator restart
			7F0E1C7C	F0: RET P
			7F0E1CCC	F1: POP AF
			7F0E1CFC	F2: JP P,nn
			7F0E1D4C	F3: DI	;disable interrupts
			7F0E1D68	F4: CALL P,nn
			7F0E1F50	F5: PUSH AF
116B30:	7F0E2000
			7F0E20B8	F6: OR n
			7F0E2124	F7: RST 30	;restart 30: mak BC spaces restart
			7F0E22B8	F8: RET M
			7F0E2308	F9: LD SP,HL
			7F0E2358	FA: JP M,nn
			7F0E23A8	FB: EI	;enable interrupts
			7F0E23CC	FC: CALL M,nn
			7F0E25B4	FD	;next HL opcode sets IY
			7F0E25D0	FE: CP n
			7F0E266C	FF: RST 38	;restart 38: maskable interrupt restart
	117878	7F0E2D48
		:possibly actual end of TLB range:
	117880-1178A0	DL snippet: vertex colours + shade
	1178A0-1178C0	DL snippet: vertex colours + shade + depth buffer
	1178C0-117938	DL snippet: blender options for font
	117938-123040	8xxx japanese font
	123040-124AC0	Cxxx japanese font
	124AC0-	animations
	17BD48		unknown. 0x3C entries @ 0x44 each
	17CD38

234B30:		7F200000
		:end possible indexed TLB entry format:
24EB30:	7F21A000
		:end registered in TLB:
