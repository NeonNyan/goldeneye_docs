7F00A8E0:	3F410	menu 00 constructor: legal screen
	accepts: A0=display list target
ADDIU	SP,SP,FED8
SW	S1,0034 (SP)
LUI	T6,8003
ADDIU	S1,SP,00E4	;S1=SP+E4: copy location
SW	S4,0040 (SP)
ADDIU	T6,T6,AABC	;T6=8002AABC
OR	S4,A0,R0	;S4=A0: DL
SW	RA,0044 (SP)
SW	S3,003C (SP)
SW	S2,0038 (SP)
SW	S0,0030 (SP)
ADDIU	T9,T6,003C	;T9=8002AAF8
OR	T0,S1,R0	;T0=S1: copy location (volatile)
//7F00A914:	loop to copy
LW	AT,0000 (T6)	;AT=8002AABC: 
ADDIU	T6,T6,000C	;T6+=C
ADDIU	T0,T0,000C	;T0+=C
SW	AT,FFF4 (T0)
LW	AT,FFF8 (T6)
SW	AT,FFF8 (T0)
LW	AT,FFFC (T6)
BNE	T6,T9,7F00A914	;loop to copy range
SW	AT,FFFC (T0)
//7F00A938:	
LW	AT,0000 (T6)	;AT=8002AABC+40: source
OR	A0,S4,R0	;A0=S4: DL
JAL	7F01C0D0	;load image
SW	AT,0000 (T0)	;AT->S1+40: copy target
//7F00A948:	
MTC1	R0,F0		;F0=0.0
LUI	AT,3F80
MTC1	AT,F4		;F4=1.0 [3F800000]
ADDIU	S0,SP,00A0	;S0=SP+A0: 
MFC1	A1,F0		;A1=0
MFC1	A2,F0		;A2=0
OR	S4,V0,R0	;S4=V0: DL
OR	A0,S0,R0	;A0=S0: SP+A0: buffer for display list
LUI	A3,457A		;A3=4000.0 [457A0000]
SWC1	F0,0010 (SP)	;SP+10=0
SWC1	F0,0014 (SP)	;SP+14=0
SWC1	F0,0018 (SP)	;SP+18=0
SWC1	F0,001C (SP)	;SP+1C=0
SWC1	F0,0024 (SP)	;SP+24=0
JAL	7F059694
SWC1	F4,0020 (SP)	;SP+20=0
//7F00A988:	
LUI	S3,8003
ADDIU	S3,S3,A958	;S3=8002A958
LW	T1,0000 (S3)	;T1=8002A958: p->object instance
SW	S0,00E4 (SP)	;S0->SP+E4: buffer for display list above (SP+A0)
LW	T2,0008 (T1)	;T2=p->obj.header
LH	A0,000E (T2)	;A0=#obj.groups
SLL	T3,A0,0x6
JAL	7F0BD714	;allocate space for the group entries
OR	A0,T3,R0	;A0=#obj.groups * 0x40 (offset to group)
//7F00A9AC:
SW	V0,00F4 (SP)	;V0=p->allocated memory
OR	A0,S0,R0	;A0=S0: DL
JAL	7F058020	;copy submatrix from A0 to A1
OR	A1,V0,R0	;A1=p->allocated memory
LW	T4,00F4 (SP)	;T4=p->allocated memory
LW	T5,0000 (S3)	;T5=p->obj.instance
SW	T4,000C (T5)	;T4->obj.instance+C: matrix conversion
JAL	7F06EFC4	;something to do with parsing the object...
LW	A0,0000 (S3)	;A0=p->obj.instance
//7F00A9D0:
ADDIU	T8,R0,0003
SW	T8,00EC (SP)	; 3->SP+EC: 
SW	R0,00E8 (SP)	; 0->SP+E8: 
SW	S4,00F0 (SP)	;S4->SP+F0:
OR	A0,S1,R0	;A0=S1: copy location
JAL	7F074684
LW	A1,0000 (S3)	;A1=p->obj.instance
//7F00A9EC:
LW	V0,0000 (S3)
LW	S4,00F0 (SP)
OR	S0,R0,R0	;S0=0
LW	T7,0008 (V0)
OR	S1,R0,R0	;S1=0
ADDIU	S2,SP,0058	;S2=SP+58: 
LH	T9,000E (T7)
BLEZ	T9,7F00AA58
NOP
//7F00AA10:
LW	T6,000C (V0)
OR	A1,S2,R0
JAL	7F058020	;copy submatrix from A0 to A1
ADDU	A0,T6,S1
LW	T0,0000 (S3)
SLL	T2,S0,0x6
OR	A0,S2,R0
LW	T1,000C (T0)
JAL	7F058C9C
ADDU	A1,T1,T2
LW	V0,0000 (S3)
ADDIU	S0,S0,0001	;S0+=1
ADDIU	S1,S1,0040	;S1+=40
LW	T3,0008 (V0)
LH	T4,000E (T3)
SLT	AT,S0,T4
BNEL	AT,R0,7F00AA14
LW	T6,000C (V0)
//7F00AA58:	parse text entry list to display to screen
JAL	7F0ACD98	;??? - microcode constructor
OR	A0,S4,R0
LUI	S0,8003
LUI	S1,8003
LUI	S3,8004
LUI	S2,8004
OR	S4,V0,R0	;S4=V0: DL
ADDIU	S0,S0,A9CC	;S0=8002A9CC
ADDIU	S1,S1,AABC	;S1=8002AABC
ADDIU	S2,S2,0EB8	;S2=80040EB8
ADDIU	S3,S3,0EB4	;S3=80040EB4
//7F00AA84:	display text entries to screen
JAL	7F0C1DD8	;V0=p->text A0
LHU	A0,0006 (S0)	;A0=8002A9CC+6+offset:	text ID
LH	A1,0000 (S0)	;A1=8002A9CC+offset:	x pos
LH	A2,0002 (S0)	;A2=8002A9CC+2+offset:	y pos
LB	A3,0004 (S0)	;A3=8002A9CC+4+offset:	alignment
LW	T8,0000 (S2)	;T8=80040EB8: p->2nd font table
LW	T7,0000 (S3)	;T7=80040EB4: p->1st font table
SW	V0,0014 (SP)	;V0->SP+14: p->text
OR	A0,S4,R0	;A0=S4: DL
SW	R0,0010 (SP)	; 0->SP+10
SW	T8,0018 (SP)	;T8->SP+18: p->2nd font table
JAL	7F00A7E4	;display text to screen
SW	T7,001C (SP)	;T7=SP+1C: p->1st font table
//7F00AAB8:	loop for each text entry
LB	T5,0005 (S0)	;T5=8002A9CC+5+offset:	kill bytes
BNEZ	T5,7F00AACC	;return if final entry
ADDIU	S0,S0,0008	;S0+=8: next entry
BNE	S0,S1,7F00AA84	;branch if S0!=8002AABC (end of list)
OR	S4,V0,R0	;S4=V0: DL
//7F00AACC:	return
LW	RA,0044 (SP)
LW	S0,0030 (SP)
LW	S1,0034 (SP)
LW	S2,0038 (SP)
LW	S3,003C (SP)
LW	S4,0040 (SP)
JR	RA
ADDIU	SP,SP,0128

+_+

7F01C0D0:	50C00	insert image DL, stats at 800232A8
	accepts: A0=display list target
ADDIU	SP,SP,FFC8
SW	S0,0018 (SP)
SW	RA,001C (SP)
LUI	T6,BA00
ORI	T6,T6,1402	;T6=BA001402
LUI	T7,0030		;T7=00300000
SW	T7,0004 (A0)	;T7->A0+4: setothermode - fill
SW	T6,0000 (A0)	;T6->A0+0: setothermode - texture LUT, 
ADDIU	S0,A0,0008	;S0=A0+8
SW	S0,0030 (SP)	;SP+30=DL
JAL	7000441C	;returns V0=image width
ADDIU	SP,SP,0008
//7F01C100:
ADDIU	T8,V0,FFFF	;T8=value-1
LW	T1,0030 (SP)	;T1=DL
ANDI	T9,T8,0FFF	;T9=(value-1) & 0xFFF
LUI	AT,FF10
OR	T0,T9,AT	;T0=FF100xxx
JAL	70003C1C	;V0=800232A8+28: p->image?
SW	T0,0000 (T1)	;T0->DL: setcolourimage - 16bit rgba, width 0x13F
JAL	7000E8B0	;translates virtual address for pointer A0
OR	A0,V0,R0	;A0=V0: p->image?
//7F01C124:
LW	T2,0030 (SP)	;T2=DL
OR	V1,S0,R0	;V1=S0: DL
LUI	T4,0001
SW	V0,0004 (T2)	;V0->DL: setcolourimage - p->image
ORI	T4,T4,0001	;T4=00010001
LUI	T3,F700		;T3=F7000000
SW	T3,0000 (V1)	;T3->DL: setfillcolour
SW	T4,0004 (V1)	;T4->DL: setfillcolour - black, black
ADDIU	S0,S0,0008	;S0+=8: DL
SW	S0,0028 (SP)	;SP+28=S0: DL
JAL	7000441C	;V0=width
ADDIU	S0,S0,0008	;S0+=8
JAL	7000442C	;V0=height
SH	V0,0022 (SP)	;SP+22=V0: width
//7F01C15C:
LH	T9,0022 (SP)	;T9=SP+22: width
ADDIU	T5,V0,FFFF	;T5=height-1
LW	V1,0028 (SP)	;V1=SP+28: DL
ANDI	T6,T5,03FF	;T6=(height-1)& 0x3FF
ADDIU	T0,T9,FFFF	;T0=width-1
ANDI	T1,T0,03FF	;T1=(width-1) & 0x3FF
SLL	T7,T6,0x2	;T7=(height * 4) lower right y
LUI	AT,F600
OR	T8,T7,AT	;T8=F6000FFC
SLL	T2,T1,0xE	;T2=width * 0x4000: lower right x
OR	T3,T8,T2	;T3=F6000000 | lrx | lry
SW	T3,0000 (V1)	;T3->DL: fillrect - lrx 0x13F, lry 0xEF
SW	R0,0004 (V1)	; 0->DL: fillrect - ulx 0, uly 0
LW	RA,001C (SP)
OR	V0,S0,R0	;V0=S0: new DL address
LW	S0,0018 (SP)
JR	RA
ADDIU	SP,SP,0038

7000E8B0:	F4B0	
ADDIU	SP,SP,FFE8
SW	A0,0018 (SP)	;SP+18=A0: 
LW	T6,0018 (SP)	;T6=A0
LUI	AT,8000
SW	RA,0014 (SP)
SLTU	AT,T6,AT	;AT=TRUE if A0 < 80000000
BNEZ	AT,7000E8E8	;branch if not in 70- range
LUI	AT,A000
SLTU	AT,T6,AT	;AT=TRUE if A0 < A0000000
BEQ	AT,R0,7000E8E8	;branch if not in 80- range
LUI	AT,1FFF
ORI	AT,AT,FFFF	;AT=1FFFFFFF
BEQ	R0,R0,7000E91C
AND	V0,T6,AT	;V0=A0 & 1FFFFFFF: address mask
//7000E8E8:
LW	T7,0018 (SP)	;T7=A0
LUI	AT,A000
SLTU	AT,T7,AT	;AT=TRUE if A0 < A0000000
BNEZ	AT,7000E914	;branch if not in 80- range
LUI	AT,C000
SLTU	AT,T7,AT	;AT=TRUE if A0 < C0000000
BEQ	AT,R0,7000E914	;branch if not in A0- range
LUI	AT,1FFF
ORI	AT,AT,FFFF
BEQ	R0,R0,7000E91C
AND	V0,T7,AT	;V0=A0 & 1FFFFFFF: address mask
//7000E914:
JAL	70019020	;translate virtual address?
LW	A0,0018 (SP)
//7000E91C:
LW	RA,0014 (SP)
ADDIU	SP,SP,0018
JR	RA
NOP

7F0BD714:	F2244	allocate A0 space in geometry memory
	accepts: A0=size of data to allocate
	returns: V0=p->allocated space
LUI	A2,8009
ADDIU	A2,A2,C24C	;A2=8008C24C
LW	V0,0000 (A2)	;V0=8008C24C: p->next bit of space for DL
ADDIU	A0,A0,000F
ORI	T6,A0,000F
XORI	T7,T6,000F	;T7=A0 to nearest 0x10 boundry
ADDU	T8,V0,T7	;T8=DL target + size of data
JR	RA
SW	T8,0000 (A2)	;T8->8008C24C: updated DL position

7F058020:	8CB50	copy submatrix from A0 to A1
	fries: V0,V1,A0,A1,A2,F4,F6,F8,F10
OR	A2,A0,R0	;A2=A0: DL
ADDIU	A0,R0,0004	;A0=4
OR	V0,R0,R0	;V0=0
OR	V1,A1,R0	;V1=A1: allocated memory
//7F058030:	copy each line
LWC1	F4,0000 (A2)
ADDIU	V0,V0,0001	;V0++
ADDIU	V1,V1,0010	;V1+=0x10
SWC1	F4,FFF0 (V1)
LWC1	F6,0004 (A2)
ADDIU	A2,A2,0010	;A2+=0x10
SWC1	F6,FFF4 (V1)
LWC1	F8,FFF8 (A2)
SWC1	F8,FFF8 (V1)
LWC1	F10,FFFC (A2)
BNE	V0,A0,7F058030	;loop 4 times
SWC1	F10,FFFC (V1)
//7F058060:	return
JR	RA
NOP

7F06EFC4:	A3AF4	
ADDIU	SP,SP,FFE0
SW	RA,001C (SP)
SW	S1,0018 (SP)
SW	S0,0014 (SP)
LW	T6,0008 (A0)	;T6=A0+8: p->obj.header
OR	S1,A0,R0	;S1=A0: p->obj.instance
LW	S0,0000 (T6)	;S0=obj.header+0: p->obj.table
BEQL	S0,R0,7F06F0C0	;branch if invalid
LW	RA,001C (SP)
//7F06EFE8:
LHU	V0,0000 (S0)	;V0=entry type
ANDI	T7,V0,00FF	;T7=entry type (no flags)
ADDIU	T8,T7,FFFF	;T8=entry-1
SLTIU	AT,T8,0018	;AT=TRUE if type 1-18
BEQ	AT,R0,7F06F078	;branch if invalid type
SLL	T8,T8,0x2	;T8=type->offset
LUI	AT,8005
ADDU	AT,AT,T8
LW	T8,4C80 (AT)	;T8=80054C80+offset: TLB pointer for entry type
JR	T8
NOP
7F06F014:	type 8 - distance trigger
OR	A0,S1,R0
JAL	7F06E858
OR	A1,S0,R0
BEQ	R0,R0,7F06F07C
LW	V0,0014 (S0)
7F06F028:	type 9 - head/hat placement interlink
OR	A0,S1,R0
JAL	7F06EB3C
OR	A1,S0,R0
BEQ	R0,R0,7F06F07C
LW	V0,0014 (S0)
7F06F03C:	type 7 - unknown type
OR	A0,S1,R0
JAL	7F06ECF8
OR	A1,S0,R0
BEQ	R0,R0,7F06F07C
LW	V0,0014 (S0)
7F06F050:	type 12 -  handle/switch
OR	A0,S1,R0
JAL	7F06E9BC
OR	A1,S0,R0
BEQ	R0,R0,7F06F07C
LW	V0,0014 (S0)
7F06F064:	type 17 - placeholder for pointer to head
OR	A0,S1,R0
JAL	7F06EA08
OR	A1,S0,R0
BEQ	R0,R0,7F06F07C
LW	V0,0014 (S0)
7F06F078:	default
LW	V0,0014 (S0)
BEQ	V0,R0,7F06F08C
NOP
BEQ	R0,R0,7F06F0B4
OR	S0,V0,R0
//7F06F08C:
BEQ	S0,R0,7F06F0B4
NOP
//7F06F094:
LW	V0,000C (S0)
BEQL	V0,R0,7F06F0AC
LW	S0,0008 (S0)
BEQ	R0,R0,7F06F0B4
OR	S0,V0,R0
//7F06F0A8:
LW	S0,0008 (S0)
BNEL	S0,R0,7F06F098
LW	V0,000C (S0)
//7F06F0B4:
BNEL	S0,R0,7F06EFEC
LHU	V0,0000 (S0)
//7F06F0BC:	return
LW	RA,001C (SP)
LW	S0,0014 (SP)
LW	S1,0018 (SP)
JR	RA
ADDIU	SP,SP,0020
